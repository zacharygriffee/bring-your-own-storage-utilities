function getOriginalBodyPadding() {
  const style = window ? window.getComputedStyle(document.body, null) : {};

  return parseInt((style && style.getPropertyValue('padding-right')) || 0, 10);
}

function getScrollbarWidth() {
  let scrollDiv = document.createElement('div');
  // .modal-scrollbar-measure styles // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.4/scss/_modal.scss#L106-L113
  scrollDiv.style.position = 'absolute';
  scrollDiv.style.top = '-9999px';
  scrollDiv.style.width = '50px';
  scrollDiv.style.height = '50px';
  scrollDiv.style.overflow = 'scroll';
  document.body.appendChild(scrollDiv);
  const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
}

function setScrollbarWidth(padding) {
  document.body.style.paddingRight = padding > 0 ? `${padding}px` : null;
}

function isBodyOverflowing() {
  return window ? document.body.clientWidth < window.innerWidth : false;
}

function isObject(value) {
  const type = typeof value;
  return value !== null && (type === 'object' || type === 'function');
}

function conditionallyUpdateScrollbar() {
  const scrollbarWidth = getScrollbarWidth();
  // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.6/js/src/modal.js#L433
  const fixedContent = document.querySelectorAll('.fixed-top, .fixed-bottom, .is-fixed, .sticky-top')[0];
  const bodyPadding = fixedContent ? parseInt(fixedContent.style.paddingRight || 0, 10) : 0;

  if (isBodyOverflowing()) {
    setScrollbarWidth(bodyPadding + scrollbarWidth);
  }
}

function getColumnSizeClass(isXs, colWidth, colSize) {
  if (colSize === true || colSize === '') {
    return isXs ? 'col' : `col-${colWidth}`;
  } else if (colSize === 'auto') {
    return isXs ? 'col-auto' : `col-${colWidth}-auto`;
  }

  return isXs ? `col-${colSize}` : `col-${colWidth}-${colSize}`;
}

function browserEvent(target, ...args) {
  target.addEventListener(...args);

  return () => target.removeEventListener(...args);
}

function getNewCarouselActiveIndex(direction, items, activeIndex) {
  if (direction === 'prev') {
    return activeIndex === 0 ? items.length - 1 : activeIndex - 1;
  }

  if (direction === 'next') {
    return activeIndex === items.length - 1 ? 0 : activeIndex + 1;
  }
}

function toClassName(value) {
  let result = '';

  if (typeof value === 'string' || typeof value === 'number') {
    result += value;
  } else if (typeof value === 'object') {
    if (Array.isArray(value)) {
      result = value.map(toClassName).filter(Boolean).join(' ');
    } else {
      for (let key in value) {
        if (value[key]) {
          result && (result += ' ');
          result += key;
        }
      }
    }
  }

  return result;
}

const classnames = (...args) => args.map(toClassName).filter(Boolean).join(' ');

function getTransitionDuration(element) {
  if (!element) return 0;

  // Get transition-duration of the element
  let { transitionDuration, transitionDelay } = window.getComputedStyle(element);

  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay);

  // Return 0 if element or transition duration is not found
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }

  // If multiple durations are defined, take the first
  transitionDuration = transitionDuration.split(',')[0];
  transitionDelay = transitionDelay.split(',')[0];

  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * 1000;
}

function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

/* nodeModulesSveltestrapSveltestrapDistAccordionAccordionSvelte.svelte generated by Svelte v4.2.8 */




function create_fragment$1s(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	let div_levels = [
		{ class: /*classes*/ ctx[1] },
		{ "data-bs-theme": /*theme*/ ctx[0] },
		/*$$restProps*/ ctx[3]
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*theme*/ 1) && { "data-bs-theme": /*theme*/ ctx[0] },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1s($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","flush","stayOpen","theme"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let $open;
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = SvelteInternal.createEventDispatcher();
	let { class: className = '' } = $$props;
	let { flush = false } = $$props;
	let { stayOpen = false } = $$props;
	let { theme = null } = $$props;
	const open = SvelteStore.writable(null);
	SvelteInternal.component_subscribe($$self, open, value => $$invalidate(9, $open = value));

	SvelteInternal.setContext('accordion', {
		open,
		stayOpen,
		/**
 * Toggles the open state of the accordion based on the provided ID.
 * @param {HTMLDivElement} element - The accordion item element
 */
		toggle: element => {
			if ($open === element) {
				open.set(null);
			} else {
				open.set(element);
			}

			dispatch('toggle', { [element]: $open === element });
		}
	});

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('flush' in $$new_props) $$invalidate(5, flush = $$new_props.flush);
		if ('stayOpen' in $$new_props) $$invalidate(6, stayOpen = $$new_props.stayOpen);
		if ('theme' in $$new_props) $$invalidate(0, theme = $$new_props.theme);
		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, flush*/ 48) {
			$$invalidate(1, classes = classnames(className, 'accordion', { 'accordion-flush': flush }));
		}
	};

	return [theme, classes, open, $$restProps, className, flush, stayOpen, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistAccordionAccordionSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$1s, create_fragment$1s, SvelteInternal.safe_not_equal, {
			class: 4,
			flush: 5,
			stayOpen: 6,
			theme: 0
		});
	}

	get class() {
		return this.$$.ctx[4];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get flush() {
		return this.$$.ctx[5];
	}

	set flush(flush) {
		this.$$set({ flush });
		SvelteInternal.flush();
	}

	get stayOpen() {
		return this.$$.ctx[6];
	}

	set stayOpen(stayOpen) {
		this.$$set({ stayOpen });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[0];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistAccordionHeaderAccordionHeaderSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$1r(ctx) {
	let h2;
	let button;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let h2_levels = [{ class: "accordion-header" }, /*$$restProps*/ ctx[1]];
	let h2_data = {};

	for (let i = 0; i < h2_levels.length; i += 1) {
		h2_data = SvelteInternal.assign(h2_data, h2_levels[i]);
	}

	return {
		c() {
			h2 = SvelteInternal.element("h2");
			button = SvelteInternal.element("button");
			if (default_slot) default_slot.c();
			SvelteInternal.attr(button, "type", "button");
			SvelteInternal.attr(button, "class", /*classes*/ ctx[0]);
			SvelteInternal.set_attributes(h2, h2_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, h2, anchor);
			SvelteInternal.append(h2, button);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(button, "click", /*click_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				SvelteInternal.attr(button, "class", /*classes*/ ctx[0]);
			}

			SvelteInternal.set_attributes(h2, h2_data = SvelteInternal.get_spread_update(h2_levels, [
				{ class: "accordion-header" },
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(h2);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$1r($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'accordion-button'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots, click_handler];
}

class NodeModulesSveltestrapSveltestrapDistAccordionHeaderAccordionHeaderSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$1r, create_fragment$1r, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

function backdropIn(node) {
  node.style.display = 'block';

  const duration = getTransitionDuration(node);

  return {
    duration,
    tick: (t) => {
      if (t === 0) {
        node.classList.add('show');
      }
    }
  };
}

function backdropOut(node) {
  node.classList.remove('show');
  const duration = getTransitionDuration(node);

  return {
    duration,
    tick: (t) => {
      if (t === 0) {
        node.style.display = 'none';
      }
    }
  };
}

function collapseOut(node, params) {
  const dimension = params.horizontal ? 'width' : 'height';
  node.style[dimension] = `${node.getBoundingClientRect()[dimension]}px`;
  node.classList.add('collapsing');
  node.classList.remove('collapse', 'show');
  const duration = getTransitionDuration(node);

  return {
    duration,
    tick: (t) => {
      if (t > 0) {
        node.style[dimension] = '';
      } else if (t === 0) {
        node.classList.remove('collapsing');
        node.classList.add('collapse');
      }
    }
  };
}

function collapseIn(node, params) {
  const horizontal = params.horizontal;
  const dimension = horizontal ? 'width' : 'height';
  node.classList.add('collapsing');
  node.classList.remove('collapse', 'show');
  node.style[dimension] = 0;
  const duration = getTransitionDuration(node);

  return {
    duration,
    tick: (t) => {
      if (t < 1) {
        if (horizontal) {
          node.style.width = `${node.scrollWidth}px`;
        } else {
          node.style.height = `${node.scrollHeight}px`;
        }
      } else {
        node.classList.remove('collapsing');
        node.classList.add('collapse', 'show');
        node.style[dimension] = '';
      }
    }
  };
}

function modalIn(node) {
  node.style.display = 'block';
  const duration = getTransitionDuration(node);

  return {
    duration,
    tick: (t) => {
      if (t > 0) {
        node.classList.add('show');
      }
    }
  };
}

function modalOut(node) {
  node.classList.remove('show');
  const duration = getTransitionDuration(node);

  return {
    duration,
    tick: (t) => {
      if (t === 1) {
        node.style.display = 'none';
      }
    }
  };
}

const defaultToggleEvents = ['touchstart', 'click'];

var toggle = (toggler, togglerFn) => {
  let unbindEvents;

  if (typeof toggler === 'string' && typeof window !== 'undefined' && document && document.createElement) {
    let selection = document.querySelectorAll(toggler);
    if (!selection.length) {
      selection = document.querySelectorAll(`#${toggler}`);
    }
    if (!selection.length) {
      throw new Error(`The target '${toggler}' could not be identified in the dom, tip: check spelling`);
    }

    defaultToggleEvents.forEach((event) => {
      selection.forEach((element) => {
        element.addEventListener(event, togglerFn);
      });
    });

    unbindEvents = () => {
      defaultToggleEvents.forEach((event) => {
        selection.forEach((element) => {
          element.removeEventListener(event, togglerFn);
        });
      });
    };
  }

  return () => {
    if (typeof unbindEvents === 'function') {
      unbindEvents();
      unbindEvents = undefined;
    }
  };
};

/* nodeModulesSveltestrapSveltestrapDistCollapseCollapseSvelte.svelte generated by Svelte v4.2.8 */


function create_if_block$z(ctx) {
	let div;
	let div_style_value;
	let div_intro;
	let div_outro;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	let div_levels = [
		{
			style: div_style_value = /*navbar*/ ctx[2] ? undefined : 'overflow: hidden;'
		},
		/*$$restProps*/ ctx[9],
		{ class: /*classes*/ ctx[8] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(div, "introstart", /*introstart_handler*/ ctx[17]),
					SvelteInternal.listen(div, "introend", /*introend_handler*/ ctx[18]),
					SvelteInternal.listen(div, "outrostart", /*outrostart_handler*/ ctx[19]),
					SvelteInternal.listen(div, "outroend", /*outroend_handler*/ ctx[20]),
					SvelteInternal.listen(div, "introstart", function () {
						if (SvelteInternal.is_function(/*onEntering*/ ctx[3])) /*onEntering*/ ctx[3].apply(this, arguments);
					}),
					SvelteInternal.listen(div, "introend", function () {
						if (SvelteInternal.is_function(/*onEntered*/ ctx[4])) /*onEntered*/ ctx[4].apply(this, arguments);
					}),
					SvelteInternal.listen(div, "outrostart", function () {
						if (SvelteInternal.is_function(/*onExiting*/ ctx[5])) /*onExiting*/ ctx[5].apply(this, arguments);
					}),
					SvelteInternal.listen(div, "outroend", function () {
						if (SvelteInternal.is_function(/*onExited*/ ctx[6])) /*onExited*/ ctx[6].apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[15],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[15])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				(!current || dirty & /*navbar*/ 4 && div_style_value !== (div_style_value = /*navbar*/ ctx[2] ? undefined : 'overflow: hidden;')) && { style: div_style_value },
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				(!current || dirty & /*classes*/ 256) && { class: /*classes*/ ctx[8] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);

			if (local) {
				SvelteInternal.add_render_callback(() => {
					if (!current) return;
					if (div_outro) div_outro.end(1);
					div_intro = SvelteInternal.create_in_transition(div, collapseIn, { horizontal: /*horizontal*/ ctx[1] });
					div_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			if (div_intro) div_intro.invalidate();

			if (local) {
				div_outro = SvelteInternal.create_out_transition(div, collapseOut, { horizontal: /*horizontal*/ ctx[1] });
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
			if (detaching && div_outro) div_outro.end();
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

function create_fragment$1q(ctx) {
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;
	SvelteInternal.add_render_callback(/*onwindowresize*/ ctx[21]);
	let if_block = /*isOpen*/ ctx[0] && create_if_block$z(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(window, "resize", /*onwindowresize*/ ctx[21]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						SvelteInternal.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$z(ctx);
					if_block.c();
					SvelteInternal.transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				SvelteInternal.check_outros();
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$1q($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"isOpen","class","horizontal","navbar","onEntering","onEntered","onExiting","onExited","expand","toggler"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = SvelteInternal.createEventDispatcher();
	let { isOpen = false } = $$props;
	let { class: className = '' } = $$props;
	let { horizontal = false } = $$props;
	let { navbar = false } = $$props;
	let { onEntering = () => dispatch('opening') } = $$props;
	let { onEntered = () => dispatch('open') } = $$props;
	let { onExiting = () => dispatch('closing') } = $$props;
	let { onExited = () => dispatch('close') } = $$props;
	let { expand = false } = $$props;
	let { toggler = null } = $$props;

	SvelteInternal.onMount(() => toggle(toggler, e => {
		$$invalidate(0, isOpen = !isOpen);
		e.preventDefault();
	}));

	let windowWidth = 0;
	let _wasMaximized = false;

	// TODO wrong to hardcode these here - come from Bootstrap CSS only
	const minWidth = {};

	minWidth['xs'] = 0;
	minWidth['sm'] = 576;
	minWidth['md'] = 768;
	minWidth['lg'] = 992;
	minWidth['xl'] = 1200;

	function notify() {
		dispatch('update', isOpen);
	}

	function introstart_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function introend_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function outrostart_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function outroend_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function onwindowresize() {
		$$invalidate(7, windowWidth = window.innerWidth);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ('class' in $$new_props) $$invalidate(10, className = $$new_props.class);
		if ('horizontal' in $$new_props) $$invalidate(1, horizontal = $$new_props.horizontal);
		if ('navbar' in $$new_props) $$invalidate(2, navbar = $$new_props.navbar);
		if ('onEntering' in $$new_props) $$invalidate(3, onEntering = $$new_props.onEntering);
		if ('onEntered' in $$new_props) $$invalidate(4, onEntered = $$new_props.onEntered);
		if ('onExiting' in $$new_props) $$invalidate(5, onExiting = $$new_props.onExiting);
		if ('onExited' in $$new_props) $$invalidate(6, onExited = $$new_props.onExited);
		if ('expand' in $$new_props) $$invalidate(11, expand = $$new_props.expand);
		if ('toggler' in $$new_props) $$invalidate(12, toggler = $$new_props.toggler);
		if ('$$scope' in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, horizontal, navbar*/ 1030) {
			$$invalidate(8, classes = classnames(className, {
				'collapse-horizontal': horizontal,
				'navbar-collapse': navbar
			}));
		}

		if ($$self.$$.dirty & /*navbar, expand, windowWidth, minWidth, isOpen, _wasMaximized*/ 26757) {
			if (navbar && expand) {
				if (windowWidth >= minWidth[expand] && !isOpen) {
					$$invalidate(0, isOpen = true);
					$$invalidate(13, _wasMaximized = true);
					notify();
				} else if (windowWidth < minWidth[expand] && _wasMaximized) {
					$$invalidate(0, isOpen = false);
					$$invalidate(13, _wasMaximized = false);
					notify();
				}
			}
		}
	};

	return [
		isOpen,
		horizontal,
		navbar,
		onEntering,
		onEntered,
		onExiting,
		onExited,
		windowWidth,
		classes,
		$$restProps,
		className,
		expand,
		toggler,
		_wasMaximized,
		minWidth,
		$$scope,
		slots,
		introstart_handler,
		introend_handler,
		outrostart_handler,
		outroend_handler,
		onwindowresize
	];
}

class NodeModulesSveltestrapSveltestrapDistCollapseCollapseSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$1q, create_fragment$1q, SvelteInternal.safe_not_equal, {
			isOpen: 0,
			class: 10,
			horizontal: 1,
			navbar: 2,
			onEntering: 3,
			onEntered: 4,
			onExiting: 5,
			onExited: 6,
			expand: 11,
			toggler: 12
		});
	}

	get isOpen() {
		return this.$$.ctx[0];
	}

	set isOpen(isOpen) {
		this.$$set({ isOpen });
		SvelteInternal.flush();
	}

	get class() {
		return this.$$.ctx[10];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get horizontal() {
		return this.$$.ctx[1];
	}

	set horizontal(horizontal) {
		this.$$set({ horizontal });
		SvelteInternal.flush();
	}

	get navbar() {
		return this.$$.ctx[2];
	}

	set navbar(navbar) {
		this.$$set({ navbar });
		SvelteInternal.flush();
	}

	get onEntering() {
		return this.$$.ctx[3];
	}

	set onEntering(onEntering) {
		this.$$set({ onEntering });
		SvelteInternal.flush();
	}

	get onEntered() {
		return this.$$.ctx[4];
	}

	set onEntered(onEntered) {
		this.$$set({ onEntered });
		SvelteInternal.flush();
	}

	get onExiting() {
		return this.$$.ctx[5];
	}

	set onExiting(onExiting) {
		this.$$set({ onExiting });
		SvelteInternal.flush();
	}

	get onExited() {
		return this.$$.ctx[6];
	}

	set onExited(onExited) {
		this.$$set({ onExited });
		SvelteInternal.flush();
	}

	get expand() {
		return this.$$.ctx[11];
	}

	set expand(expand) {
		this.$$set({ expand });
		SvelteInternal.flush();
	}

	get toggler() {
		return this.$$.ctx[12];
	}

	set toggler(toggler) {
		this.$$set({ toggler });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistAccordionItemAccordionItemSvelte.svelte generated by Svelte v4.2.8 */

const get_header_slot_changes$2 = dirty => ({});
const get_header_slot_context$2 = ctx => ({});

// (60:2) <AccordionHeader on:click={onToggle} class={!isOpen && 'collapsed'}>
function create_default_slot_1$6(ctx) {
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[9].header;
	const header_slot = SvelteInternal.create_slot(header_slot_template, ctx, /*$$scope*/ ctx[15], get_header_slot_context$2);

	return {
		c() {
			if (header_slot) header_slot.c();
			t0 = SvelteInternal.space();
			t1 = SvelteInternal.text(/*header*/ ctx[0]);
		},
		m(target, anchor) {
			if (header_slot) {
				header_slot.m(target, anchor);
			}

			SvelteInternal.insert(target, t0, anchor);
			SvelteInternal.insert(target, t1, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					SvelteInternal.update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[15],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[15])
						: SvelteInternal.get_slot_changes(header_slot_template, /*$$scope*/ ctx[15], dirty, get_header_slot_changes$2),
						get_header_slot_context$2
					);
				}
			}

			if (!current || dirty & /*header*/ 1) SvelteInternal.set_data(t1, /*header*/ ctx[0]);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t0);
				SvelteInternal.detach(t1);
			}

			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (64:2) <Collapse {isOpen} class="accordion-collapse" on:introstart on:introend on:outrostart on:outroend>
function create_default_slot$d(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.attr(div, "class", "accordion-body");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[15],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[15])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$1p(ctx) {
	let div;
	let accordionheader;
	let t;
	let collapse;
	let current;

	accordionheader = new NodeModulesSveltestrapSveltestrapDistAccordionHeaderAccordionHeaderSvelte({
			props: {
				class: !/*isOpen*/ ctx[2] && 'collapsed',
				$$slots: { default: [create_default_slot_1$6] },
				$$scope: { ctx }
			}
		});

	accordionheader.$on("click", /*onToggle*/ ctx[5]);

	collapse = new NodeModulesSveltestrapSveltestrapDistCollapseCollapseSvelte({
			props: {
				isOpen: /*isOpen*/ ctx[2],
				class: "accordion-collapse",
				$$slots: { default: [create_default_slot$d] },
				$$scope: { ctx }
			}
		});

	collapse.$on("introstart", /*introstart_handler*/ ctx[10]);
	collapse.$on("introend", /*introend_handler*/ ctx[11]);
	collapse.$on("outrostart", /*outrostart_handler*/ ctx[12]);
	collapse.$on("outroend", /*outroend_handler*/ ctx[13]);

	return {
		c() {
			div = SvelteInternal.element("div");
			SvelteInternal.create_component(accordionheader.$$.fragment);
			t = SvelteInternal.space();
			SvelteInternal.create_component(collapse.$$.fragment);
			SvelteInternal.attr(div, "class", /*classes*/ ctx[3]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			SvelteInternal.mount_component(accordionheader, div, null);
			SvelteInternal.append(div, t);
			SvelteInternal.mount_component(collapse, div, null);
			/*div_binding*/ ctx[14](div);
			current = true;
		},
		p(ctx, [dirty]) {
			const accordionheader_changes = {};
			if (dirty & /*isOpen*/ 4) accordionheader_changes.class = !/*isOpen*/ ctx[2] && 'collapsed';

			if (dirty & /*$$scope, header*/ 32769) {
				accordionheader_changes.$$scope = { dirty, ctx };
			}

			accordionheader.$set(accordionheader_changes);
			const collapse_changes = {};
			if (dirty & /*isOpen*/ 4) collapse_changes.isOpen = /*isOpen*/ ctx[2];

			if (dirty & /*$$scope*/ 32768) {
				collapse_changes.$$scope = { dirty, ctx };
			}

			collapse.$set(collapse_changes);

			if (!current || dirty & /*classes*/ 8) {
				SvelteInternal.attr(div, "class", /*classes*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(accordionheader.$$.fragment, local);
			SvelteInternal.transition_in(collapse.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(accordionheader.$$.fragment, local);
			SvelteInternal.transition_out(collapse.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			SvelteInternal.destroy_component(accordionheader);
			SvelteInternal.destroy_component(collapse);
			/*div_binding*/ ctx[14](null);
		}
	};
}

function instance$1p($$self, $$props, $$invalidate) {
	let classes;
	let isOpen;
	let $open;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { header = '' } = $$props;
	let { active = false } = $$props;
	const dispatch = SvelteInternal.createEventDispatcher();
	const { stayOpen, toggle, open } = SvelteInternal.getContext('accordion');
	SvelteInternal.component_subscribe($$self, open, value => $$invalidate(8, $open = value));

	/**
 * @type {HTMLDivElement}
 */
	let accordionRef;

	SvelteInternal.onMount(() => {
		if (active) {
			toggle(accordionRef);
		}
	});

	const onToggle = () => {
		if (stayOpen) {
			$$invalidate(6, active = !active);
		}

		toggle(accordionRef);
		dispatch('toggle', !isOpen);
	};

	function introstart_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function introend_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function outrostart_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function outroend_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function div_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			accordionRef = $$value;
			$$invalidate(1, accordionRef);
		});
	}

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(7, className = $$props.class);
		if ('header' in $$props) $$invalidate(0, header = $$props.header);
		if ('active' in $$props) $$invalidate(6, active = $$props.active);
		if ('$$scope' in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 128) {
			$$invalidate(3, classes = classnames(className, 'accordion-item'));
		}

		if ($$self.$$.dirty & /*active, $open, accordionRef*/ 322) {
			$$invalidate(2, isOpen = stayOpen ? active : $open === accordionRef);
		}
	};

	return [
		header,
		accordionRef,
		isOpen,
		classes,
		open,
		onToggle,
		active,
		className,
		$open,
		slots,
		introstart_handler,
		introend_handler,
		outrostart_handler,
		outroend_handler,
		div_binding,
		$$scope
	];
}

class NodeModulesSveltestrapSveltestrapDistAccordionItemAccordionItemSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$1p, create_fragment$1p, SvelteInternal.safe_not_equal, { class: 7, header: 0, active: 6 });
	}

	get class() {
		return this.$$.ctx[7];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get header() {
		return this.$$.ctx[0];
	}

	set header(header) {
		this.$$set({ header });
		SvelteInternal.flush();
	}

	get active() {
		return this.$$.ctx[6];
	}

	set active(active) {
		this.$$set({ active });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistAlertAlertSvelte.svelte generated by Svelte v4.2.8 */

const get_heading_slot_changes = dirty => ({});
const get_heading_slot_context = ctx => ({});

// (96:0) {#if isOpen}
function create_if_block$y(ctx) {
	let div;
	let t0;
	let t1;
	let current_block_type_index;
	let if_block2;
	let div_transition;
	let current;
	let if_block0 = (/*heading*/ ctx[3] || /*$$slots*/ ctx[11].heading) && create_if_block_3$5(ctx);
	let if_block1 = /*showClose*/ ctx[6] && create_if_block_2$c(ctx);
	const if_block_creators = [create_if_block_1$k, create_else_block$s];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let div_levels = [
		/*$$restProps*/ ctx[10],
		{ "data-bs-theme": /*theme*/ ctx[4] },
		{ class: /*classes*/ ctx[8] },
		{ role: "alert" }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (if_block0) if_block0.c();
			t0 = SvelteInternal.space();
			if (if_block1) if_block1.c();
			t1 = SvelteInternal.space();
			if_block2.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			SvelteInternal.append(div, t0);
			if (if_block1) if_block1.m(div, null);
			SvelteInternal.append(div, t1);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*heading*/ ctx[3] || /*$$slots*/ ctx[11].heading) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*heading, $$slots*/ 2056) {
						SvelteInternal.transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$5(ctx);
					if_block0.c();
					SvelteInternal.transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				SvelteInternal.check_outros();
			}

			if (/*showClose*/ ctx[6]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$c(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block2, 1);
				if_block2.m(div, null);
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 1024 && /*$$restProps*/ ctx[10],
				(!current || dirty & /*theme*/ 16) && { "data-bs-theme": /*theme*/ ctx[4] },
				(!current || dirty & /*classes*/ 256) && { class: /*classes*/ ctx[8] },
				{ role: "alert" }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block0);
			SvelteInternal.transition_in(if_block2);

			if (local) {
				SvelteInternal.add_render_callback(() => {
					if (!current) return;
					if (!div_transition) div_transition = SvelteInternal.create_bidirectional_transition(div, SvelteTransition.fade, /*transition*/ ctx[5], true);
					div_transition.run(1);
				});
			}

			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block0);
			SvelteInternal.transition_out(if_block2);

			if (local) {
				if (!div_transition) div_transition = SvelteInternal.create_bidirectional_transition(div, SvelteTransition.fade, /*transition*/ ctx[5], false);
				div_transition.run(0);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if_blocks[current_block_type_index].d();
			if (detaching && div_transition) div_transition.end();
		}
	};
}

// (98:4) {#if heading || $$slots.heading}
function create_if_block_3$5(ctx) {
	let h4;
	let t;
	let current;
	const heading_slot_template = /*#slots*/ ctx[19].heading;
	const heading_slot = SvelteInternal.create_slot(heading_slot_template, ctx, /*$$scope*/ ctx[18], get_heading_slot_context);

	return {
		c() {
			h4 = SvelteInternal.element("h4");
			t = SvelteInternal.text(/*heading*/ ctx[3]);
			if (heading_slot) heading_slot.c();
			SvelteInternal.attr(h4, "class", "alert-heading");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, h4, anchor);
			SvelteInternal.append(h4, t);

			if (heading_slot) {
				heading_slot.m(h4, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*heading*/ 8) SvelteInternal.set_data(t, /*heading*/ ctx[3]);

			if (heading_slot) {
				if (heading_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					SvelteInternal.update_slot_base(
						heading_slot,
						heading_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: SvelteInternal.get_slot_changes(heading_slot_template, /*$$scope*/ ctx[18], dirty, get_heading_slot_changes),
						get_heading_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(heading_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(heading_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(h4);
			}

			if (heading_slot) heading_slot.d(detaching);
		}
	};
}

// (103:4) {#if showClose}
function create_if_block_2$c(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = SvelteInternal.element("button");
			SvelteInternal.attr(button, "type", "button");
			SvelteInternal.attr(button, "class", /*closeClassNames*/ ctx[7]);
			SvelteInternal.attr(button, "aria-label", /*closeAriaLabel*/ ctx[2]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, button, anchor);

			if (!mounted) {
				dispose = SvelteInternal.listen(button, "click", function () {
					if (SvelteInternal.is_function(/*handleToggle*/ ctx[9])) /*handleToggle*/ ctx[9].apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*closeClassNames*/ 128) {
				SvelteInternal.attr(button, "class", /*closeClassNames*/ ctx[7]);
			}

			if (dirty & /*closeAriaLabel*/ 4) {
				SvelteInternal.attr(button, "aria-label", /*closeAriaLabel*/ ctx[2]);
			}
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (108:4) {:else}
function create_else_block$s(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[19].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (106:4) {#if children}
function create_if_block_1$k(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*children*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 2) SvelteInternal.set_data(t, /*children*/ ctx[1]);
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

function create_fragment$1o(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*isOpen*/ ctx[0] && create_if_block$y(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						SvelteInternal.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$y(ctx);
					if_block.c();
					SvelteInternal.transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				SvelteInternal.check_outros();
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function instance$1o($$self, $$props, $$invalidate) {
	let showClose;
	let handleToggle;
	let classes;
	let closeClassNames;

	const omit_props_names = [
		"class","children","closeAriaLabel","closeClassName","color","dismissible","fade","heading","isOpen","toggle","theme","transition"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = SvelteInternal.compute_slots(slots);
	let { class: className = '' } = $$props;
	let { children = undefined } = $$props;
	let { closeAriaLabel = 'Close' } = $$props;
	let { closeClassName = '' } = $$props;
	let { color = 'success' } = $$props;
	let { dismissible = false } = $$props;
	let { fade = true } = $$props;
	let { heading = '' } = $$props;
	let { isOpen = true } = $$props;
	let { toggle = undefined } = $$props;
	let { theme = undefined } = $$props;
	let { transition = { duration: fade ? 400 : 0 } } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(10, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(12, className = $$new_props.class);
		if ('children' in $$new_props) $$invalidate(1, children = $$new_props.children);
		if ('closeAriaLabel' in $$new_props) $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
		if ('closeClassName' in $$new_props) $$invalidate(13, closeClassName = $$new_props.closeClassName);
		if ('color' in $$new_props) $$invalidate(14, color = $$new_props.color);
		if ('dismissible' in $$new_props) $$invalidate(15, dismissible = $$new_props.dismissible);
		if ('fade' in $$new_props) $$invalidate(16, fade = $$new_props.fade);
		if ('heading' in $$new_props) $$invalidate(3, heading = $$new_props.heading);
		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ('toggle' in $$new_props) $$invalidate(17, toggle = $$new_props.toggle);
		if ('theme' in $$new_props) $$invalidate(4, theme = $$new_props.theme);
		if ('transition' in $$new_props) $$invalidate(5, transition = $$new_props.transition);
		if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*dismissible, toggle*/ 163840) {
			$$invalidate(6, showClose = dismissible || toggle);
		}

		if ($$self.$$.dirty & /*toggle*/ 131072) {
			$$invalidate(9, handleToggle = toggle || (() => $$invalidate(0, isOpen = false)));
		}

		if ($$self.$$.dirty & /*className, color, showClose*/ 20544) {
			$$invalidate(8, classes = classnames(className, 'alert', `alert-${color}`, { 'alert-dismissible': showClose }));
		}

		if ($$self.$$.dirty & /*closeClassName*/ 8192) {
			$$invalidate(7, closeClassNames = classnames('btn-close', closeClassName));
		}
	};

	return [
		isOpen,
		children,
		closeAriaLabel,
		heading,
		theme,
		transition,
		showClose,
		closeClassNames,
		classes,
		handleToggle,
		$$restProps,
		$$slots,
		className,
		closeClassName,
		color,
		dismissible,
		fade,
		toggle,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistAlertAlertSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$1o, create_fragment$1o, SvelteInternal.safe_not_equal, {
			class: 12,
			children: 1,
			closeAriaLabel: 2,
			closeClassName: 13,
			color: 14,
			dismissible: 15,
			fade: 16,
			heading: 3,
			isOpen: 0,
			toggle: 17,
			theme: 4,
			transition: 5
		});
	}

	get class() {
		return this.$$.ctx[12];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get children() {
		return this.$$.ctx[1];
	}

	set children(children) {
		this.$$set({ children });
		SvelteInternal.flush();
	}

	get closeAriaLabel() {
		return this.$$.ctx[2];
	}

	set closeAriaLabel(closeAriaLabel) {
		this.$$set({ closeAriaLabel });
		SvelteInternal.flush();
	}

	get closeClassName() {
		return this.$$.ctx[13];
	}

	set closeClassName(closeClassName) {
		this.$$set({ closeClassName });
		SvelteInternal.flush();
	}

	get color() {
		return this.$$.ctx[14];
	}

	set color(color) {
		this.$$set({ color });
		SvelteInternal.flush();
	}

	get dismissible() {
		return this.$$.ctx[15];
	}

	set dismissible(dismissible) {
		this.$$set({ dismissible });
		SvelteInternal.flush();
	}

	get fade() {
		return this.$$.ctx[16];
	}

	set fade(fade) {
		this.$$set({ fade });
		SvelteInternal.flush();
	}

	get heading() {
		return this.$$.ctx[3];
	}

	set heading(heading) {
		this.$$set({ heading });
		SvelteInternal.flush();
	}

	get isOpen() {
		return this.$$.ctx[0];
	}

	set isOpen(isOpen) {
		this.$$set({ isOpen });
		SvelteInternal.flush();
	}

	get toggle() {
		return this.$$.ctx[17];
	}

	set toggle(toggle) {
		this.$$set({ toggle });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[4];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}

	get transition() {
		return this.$$.ctx[5];
	}

	set transition(transition) {
		this.$$set({ transition });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistAlertUncontrolledAlertSvelte.svelte generated by Svelte v4.2.8 */


function create_default_slot$c(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$1n(ctx) {
	let alert;
	let current;
	const alert_spread_levels = [/*$$restProps*/ ctx[0], { dismissible: true }];

	let alert_props = {
		$$slots: { default: [create_default_slot$c] },
		$$scope: { ctx }
	};

	for (let i = 0; i < alert_spread_levels.length; i += 1) {
		alert_props = SvelteInternal.assign(alert_props, alert_spread_levels[i]);
	}

	alert = new NodeModulesSveltestrapSveltestrapDistAlertAlertSvelte({ props: alert_props });

	return {
		c() {
			SvelteInternal.create_component(alert.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(alert, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const alert_changes = (dirty & /*$$restProps*/ 1)
			? SvelteInternal.get_spread_update(alert_spread_levels, [SvelteInternal.get_spread_object(/*$$restProps*/ ctx[0]), alert_spread_levels[1]])
			: {};

			if (dirty & /*$$scope*/ 4) {
				alert_changes.$$scope = { dirty, ctx };
			}

			alert.$set(alert_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(alert.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(alert.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(alert, detaching);
		}
	};
}

function instance$1n($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(0, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('$$scope' in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
	};

	return [$$restProps, slots, $$scope];
}

class NodeModulesSveltestrapSveltestrapDistAlertUncontrolledAlertSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$1n, create_fragment$1n, SvelteInternal.safe_not_equal, {});
	}
}

/* nodeModulesSveltestrapSveltestrapDistBadgeBadgeSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block_1$3(ctx) {
	let span;
	let current_block_type_index;
	let if_block0;
	let t;
	let current;
	const if_block_creators = [create_if_block_4$3, create_else_block_2$2];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*children*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = (/*positioned*/ ctx[4] || /*indicator*/ ctx[3]) && create_if_block_3$4(ctx);

	let span_levels = [
		/*$$restProps*/ ctx[7],
		{ class: /*classes*/ ctx[6] },
		{ "data-bs-theme": /*theme*/ ctx[5] }
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = SvelteInternal.assign(span_data, span_levels[i]);
	}

	return {
		c() {
			span = SvelteInternal.element("span");
			if_block0.c();
			t = SvelteInternal.space();
			if (if_block1) if_block1.c();
			SvelteInternal.set_attributes(span, span_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, span, anchor);
			if_blocks[current_block_type_index].m(span, null);
			SvelteInternal.append(span, t);
			if (if_block1) if_block1.m(span, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block0, 1);
				if_block0.m(span, t);
			}

			if (/*positioned*/ ctx[4] || /*indicator*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$4(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			SvelteInternal.set_attributes(span, span_data = SvelteInternal.get_spread_update(span_levels, [
				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7],
				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] },
				(!current || dirty & /*theme*/ 32) && { "data-bs-theme": /*theme*/ ctx[5] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block0);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(span);
			}

			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
		}
	};
}

// (90:0) {#if href}
function create_if_block$x(ctx) {
	let a;
	let current_block_type_index;
	let if_block0;
	let t;
	let current;
	const if_block_creators = [create_if_block_2$b, create_else_block$r];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*children*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = (/*positioned*/ ctx[4] || /*indicator*/ ctx[3]) && create_if_block_1$j(ctx);

	let a_levels = [
		/*$$restProps*/ ctx[7],
		{ href: /*href*/ ctx[2] },
		{ class: /*classes*/ ctx[6] },
		{ "data-bs-theme": /*theme*/ ctx[5] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = SvelteInternal.assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = SvelteInternal.element("a");
			if_block0.c();
			t = SvelteInternal.space();
			if (if_block1) if_block1.c();
			SvelteInternal.set_attributes(a, a_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, a, anchor);
			if_blocks[current_block_type_index].m(a, null);
			SvelteInternal.append(a, t);
			if (if_block1) if_block1.m(a, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block0, 1);
				if_block0.m(a, t);
			}

			if (/*positioned*/ ctx[4] || /*indicator*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$j(ctx);
					if_block1.c();
					if_block1.m(a, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			SvelteInternal.set_attributes(a, a_data = SvelteInternal.get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7],
				(!current || dirty & /*href*/ 4) && { href: /*href*/ ctx[2] },
				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] },
				(!current || dirty & /*theme*/ 32) && { "data-bs-theme": /*theme*/ ctx[5] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block0);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(a);
			}

			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
		}
	};
}

// (105:4) {:else}
function create_else_block_2$2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (103:4) {#if children}
function create_if_block_4$3(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*children*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 2) SvelteInternal.set_data(t, /*children*/ ctx[1]);
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (108:4) {#if positioned || indicator}
function create_if_block_3$4(ctx) {
	let span;
	let t;

	return {
		c() {
			span = SvelteInternal.element("span");
			t = SvelteInternal.text(/*ariaLabel*/ ctx[0]);
			SvelteInternal.attr(span, "class", "visually-hidden");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, span, anchor);
			SvelteInternal.append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*ariaLabel*/ 1) SvelteInternal.set_data(t, /*ariaLabel*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(span);
			}
		}
	};
}

// (94:4) {:else}
function create_else_block$r(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (92:4) {#if children}
function create_if_block_2$b(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*children*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 2) SvelteInternal.set_data(t, /*children*/ ctx[1]);
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (97:4) {#if positioned || indicator}
function create_if_block_1$j(ctx) {
	let span;
	let t;

	return {
		c() {
			span = SvelteInternal.element("span");
			t = SvelteInternal.text(/*ariaLabel*/ ctx[0]);
			SvelteInternal.attr(span, "class", "visually-hidden");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, span, anchor);
			SvelteInternal.append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*ariaLabel*/ 1) SvelteInternal.set_data(t, /*ariaLabel*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(span);
			}
		}
	};
}

function create_fragment$1m(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$x, create_else_block_1$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$1m($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"ariaLabel","border","class","children","color","href","indicator","pill","positioned","placement","shadow","theme"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { ariaLabel = '' } = $$props;
	let { border = false } = $$props;
	let { class: className = '' } = $$props;
	let { children = '' } = $$props;
	let { color = 'secondary' } = $$props;
	let { href = '' } = $$props;
	let { indicator = false } = $$props;
	let { pill = false } = $$props;
	let { positioned = false } = $$props;
	let { placement = 'top-0 start-100' } = $$props;
	let { shadow = false } = $$props;
	let { theme = null } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('ariaLabel' in $$new_props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
		if ('border' in $$new_props) $$invalidate(8, border = $$new_props.border);
		if ('class' in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ('children' in $$new_props) $$invalidate(1, children = $$new_props.children);
		if ('color' in $$new_props) $$invalidate(10, color = $$new_props.color);
		if ('href' in $$new_props) $$invalidate(2, href = $$new_props.href);
		if ('indicator' in $$new_props) $$invalidate(3, indicator = $$new_props.indicator);
		if ('pill' in $$new_props) $$invalidate(11, pill = $$new_props.pill);
		if ('positioned' in $$new_props) $$invalidate(4, positioned = $$new_props.positioned);
		if ('placement' in $$new_props) $$invalidate(12, placement = $$new_props.placement);
		if ('shadow' in $$new_props) $$invalidate(13, shadow = $$new_props.shadow);
		if ('theme' in $$new_props) $$invalidate(5, theme = $$new_props.theme);
		if ('$$scope' in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*color, pill, positioned, placement, indicator, border, shadow, className*/ 16152) {
			$$invalidate(6, classes = classnames(
				'badge',
				`text-bg-${color}`,
				pill ? 'rounded-pill' : false,
				positioned
				? 'position-absolute translate-middle'
				: false,
				positioned ? placement : false,
				indicator ? 'p-2' : false,
				border
				? typeof border === 'string' ? border : 'border'
				: false,
				shadow
				? typeof shadow === 'string' ? shadow : 'shadow'
				: false,
				className
			));
		}
	};

	return [
		ariaLabel,
		children,
		href,
		indicator,
		positioned,
		theme,
		classes,
		$$restProps,
		border,
		className,
		color,
		pill,
		placement,
		shadow,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistBadgeBadgeSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$1m, create_fragment$1m, SvelteInternal.safe_not_equal, {
			ariaLabel: 0,
			border: 8,
			class: 9,
			children: 1,
			color: 10,
			href: 2,
			indicator: 3,
			pill: 11,
			positioned: 4,
			placement: 12,
			shadow: 13,
			theme: 5
		});
	}

	get ariaLabel() {
		return this.$$.ctx[0];
	}

	set ariaLabel(ariaLabel) {
		this.$$set({ ariaLabel });
		SvelteInternal.flush();
	}

	get border() {
		return this.$$.ctx[8];
	}

	set border(border) {
		this.$$set({ border });
		SvelteInternal.flush();
	}

	get class() {
		return this.$$.ctx[9];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get children() {
		return this.$$.ctx[1];
	}

	set children(children) {
		this.$$set({ children });
		SvelteInternal.flush();
	}

	get color() {
		return this.$$.ctx[10];
	}

	set color(color) {
		this.$$set({ color });
		SvelteInternal.flush();
	}

	get href() {
		return this.$$.ctx[2];
	}

	set href(href) {
		this.$$set({ href });
		SvelteInternal.flush();
	}

	get indicator() {
		return this.$$.ctx[3];
	}

	set indicator(indicator) {
		this.$$set({ indicator });
		SvelteInternal.flush();
	}

	get pill() {
		return this.$$.ctx[11];
	}

	set pill(pill) {
		this.$$set({ pill });
		SvelteInternal.flush();
	}

	get positioned() {
		return this.$$.ctx[4];
	}

	set positioned(positioned) {
		this.$$set({ positioned });
		SvelteInternal.flush();
	}

	get placement() {
		return this.$$.ctx[12];
	}

	set placement(placement) {
		this.$$set({ placement });
		SvelteInternal.flush();
	}

	get shadow() {
		return this.$$.ctx[13];
	}

	set shadow(shadow) {
		this.$$set({ shadow });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[5];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistBreadcrumbBreadcrumbSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block$q(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (42:4) {#if children}
function create_if_block$w(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*children*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 2) SvelteInternal.set_data(t, /*children*/ ctx[1]);
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

function create_fragment$1l(ctx) {
	let nav;
	let ol;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$w, create_else_block$q];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let nav_levels = [
		{ style: /*styles*/ ctx[2] },
		/*$$restProps*/ ctx[4],
		{ class: /*className*/ ctx[0] }
	];

	let nav_data = {};

	for (let i = 0; i < nav_levels.length; i += 1) {
		nav_data = SvelteInternal.assign(nav_data, nav_levels[i]);
	}

	return {
		c() {
			nav = SvelteInternal.element("nav");
			ol = SvelteInternal.element("ol");
			if_block.c();
			SvelteInternal.attr(ol, "class", /*listClasses*/ ctx[3]);
			SvelteInternal.set_attributes(nav, nav_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, nav, anchor);
			SvelteInternal.append(nav, ol);
			if_blocks[current_block_type_index].m(ol, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(ol, null);
			}

			if (!current || dirty & /*listClasses*/ 8) {
				SvelteInternal.attr(ol, "class", /*listClasses*/ ctx[3]);
			}

			SvelteInternal.set_attributes(nav, nav_data = SvelteInternal.get_spread_update(nav_levels, [
				(!current || dirty & /*styles*/ 4) && { style: /*styles*/ ctx[2] },
				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(nav);
			}

			if_blocks[current_block_type_index].d();
		}
	};
}

function instance$1l($$self, $$props, $$invalidate) {
	let listClasses;
	let styles;
	const omit_props_names = ["class","children","divider","listClassName","style"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { children = '' } = $$props;
	let { divider = '' } = $$props;
	let { listClassName = '' } = $$props;
	let { style = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ('children' in $$new_props) $$invalidate(1, children = $$new_props.children);
		if ('divider' in $$new_props) $$invalidate(5, divider = $$new_props.divider);
		if ('listClassName' in $$new_props) $$invalidate(6, listClassName = $$new_props.listClassName);
		if ('style' in $$new_props) $$invalidate(7, style = $$new_props.style);
		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*listClassName*/ 64) {
			$$invalidate(3, listClasses = classnames('breadcrumb', listClassName));
		}

		if ($$self.$$.dirty & /*divider, style*/ 160) {
			$$invalidate(2, styles = divider
			? `--bs-breadcrumb-divider: '${divider}'; ${style || ''}`
			: style);
		}
	};

	return [
		className,
		children,
		styles,
		listClasses,
		$$restProps,
		divider,
		listClassName,
		style,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistBreadcrumbBreadcrumbSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$1l, create_fragment$1l, SvelteInternal.safe_not_equal, {
			class: 0,
			children: 1,
			divider: 5,
			listClassName: 6,
			style: 7
		});
	}

	get class() {
		return this.$$.ctx[0];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get children() {
		return this.$$.ctx[1];
	}

	set children(children) {
		this.$$set({ children });
		SvelteInternal.flush();
	}

	get divider() {
		return this.$$.ctx[5];
	}

	set divider(divider) {
		this.$$set({ divider });
		SvelteInternal.flush();
	}

	get listClassName() {
		return this.$$.ctx[6];
	}

	set listClassName(listClassName) {
		this.$$set({ listClassName });
		SvelteInternal.flush();
	}

	get style() {
		return this.$$.ctx[7];
	}

	set style(style) {
		this.$$set({ style });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistBreadcrumbItemBreadcrumbItemSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block$p(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (27:2) {#if children}
function create_if_block$v(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*children*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 2) SvelteInternal.set_data(t, /*children*/ ctx[1]);
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

function create_fragment$1k(ctx) {
	let li;
	let current_block_type_index;
	let if_block;
	let li_aria_current_value;
	let current;
	const if_block_creators = [create_if_block$v, create_else_block$p];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let li_levels = [
		/*$$restProps*/ ctx[3],
		{ class: /*classes*/ ctx[2] },
		{
			"aria-current": li_aria_current_value = /*active*/ ctx[0] ? 'page' : undefined
		}
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = SvelteInternal.assign(li_data, li_levels[i]);
	}

	return {
		c() {
			li = SvelteInternal.element("li");
			if_block.c();
			SvelteInternal.set_attributes(li, li_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, li, anchor);
			if_blocks[current_block_type_index].m(li, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(li, null);
			}

			SvelteInternal.set_attributes(li, li_data = SvelteInternal.get_spread_update(li_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				(!current || dirty & /*active*/ 1 && li_aria_current_value !== (li_aria_current_value = /*active*/ ctx[0] ? 'page' : undefined)) && { "aria-current": li_aria_current_value }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(li);
			}

			if_blocks[current_block_type_index].d();
		}
	};
}

function instance$1k($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","active","children"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { active = false } = $$props;
	let { children = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('active' in $$new_props) $$invalidate(0, active = $$new_props.active);
		if ('children' in $$new_props) $$invalidate(1, children = $$new_props.children);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, active*/ 17) {
			$$invalidate(2, classes = classnames(className, active ? 'active' : false, 'breadcrumb-item'));
		}
	};

	return [active, children, classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistBreadcrumbItemBreadcrumbItemSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$1k, create_fragment$1k, SvelteInternal.safe_not_equal, { class: 4, active: 0, children: 1 });
	}

	get class() {
		return this.$$.ctx[4];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get active() {
		return this.$$.ctx[0];
	}

	set active(active) {
		this.$$set({ active });
		SvelteInternal.flush();
	}

	get children() {
		return this.$$.ctx[1];
	}

	set children(children) {
		this.$$set({ children });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistButtonButtonSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block_1$2(ctx) {
	let button;
	let button_aria_label_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
	const default_slot_or_fallback = default_slot || fallback_block$9(ctx);

	let button_levels = [
		/*$$restProps*/ ctx[8],
		{ class: /*classes*/ ctx[6] },
		{ disabled: /*disabled*/ ctx[2] },
		{ value: /*value*/ ctx[4] },
		{
			"aria-label": button_aria_label_value = /*ariaLabel*/ ctx[7] || /*defaultAriaLabel*/ ctx[5]
		}
	];

	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = SvelteInternal.assign(button_data, button_levels[i]);
	}

	return {
		c() {
			button = SvelteInternal.element("button");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			SvelteInternal.set_attributes(button, button_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, button, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(button, null);
			}

			if (button.autofocus) button.focus();
			/*button_binding*/ ctx[21](button);
			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(button, "click", /*click_handler_1*/ ctx[19]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[16],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[16])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*children, $$scope*/ 65538)) {
					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			SvelteInternal.set_attributes(button, button_data = SvelteInternal.get_spread_update(button_levels, [
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] },
				(!current || dirty & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] },
				(!current || dirty & /*value*/ 16) && { value: /*value*/ ctx[4] },
				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 160 && button_aria_label_value !== (button_aria_label_value = /*ariaLabel*/ ctx[7] || /*defaultAriaLabel*/ ctx[5])) && { "aria-label": button_aria_label_value }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(button);
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			/*button_binding*/ ctx[21](null);
			mounted = false;
			dispose();
		}
	};
}

// (93:0) {#if href}
function create_if_block$u(ctx) {
	let a;
	let current_block_type_index;
	let if_block;
	let a_aria_label_value;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$i, create_else_block$o];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*children*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let a_levels = [
		/*$$restProps*/ ctx[8],
		{ class: /*classes*/ ctx[6] },
		{ href: /*href*/ ctx[3] },
		{
			"aria-label": a_aria_label_value = /*ariaLabel*/ ctx[7] || /*defaultAriaLabel*/ ctx[5]
		}
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = SvelteInternal.assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = SvelteInternal.element("a");
			if_block.c();
			SvelteInternal.set_attributes(a, a_data);
			SvelteInternal.toggle_class(a, "disabled", /*disabled*/ ctx[2]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, a, anchor);
			if_blocks[current_block_type_index].m(a, null);
			/*a_binding*/ ctx[20](a);
			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(a, "click", /*click_handler*/ ctx[18]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(a, null);
			}

			SvelteInternal.set_attributes(a, a_data = SvelteInternal.get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] },
				(!current || dirty & /*href*/ 8) && { href: /*href*/ ctx[3] },
				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 160 && a_aria_label_value !== (a_aria_label_value = /*ariaLabel*/ ctx[7] || /*defaultAriaLabel*/ ctx[5])) && { "aria-label": a_aria_label_value }
			]));

			SvelteInternal.toggle_class(a, "disabled", /*disabled*/ ctx[2]);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(a);
			}

			if_blocks[current_block_type_index].d();
			/*a_binding*/ ctx[20](null);
			mounted = false;
			dispose();
		}
	};
}

// (122:6) {:else}
function create_else_block_2$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[16],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[16])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (120:6) {#if children}
function create_if_block_2$a(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*children*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 2) SvelteInternal.set_data(t, /*children*/ ctx[1]);
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (119:10)        
function fallback_block$9(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_2$a, create_else_block_2$1];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*children*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

// (105:4) {:else}
function create_else_block$o(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 65536)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[16],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[16])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (103:4) {#if children}
function create_if_block_1$i(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*children*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 2) SvelteInternal.set_data(t, /*children*/ ctx[1]);
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

function create_fragment$1j(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$u, create_else_block_1$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[3]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$1j($$self, $$props, $$invalidate) {
	let ariaLabel;
	let classes;
	let defaultAriaLabel;

	const omit_props_names = [
		"class","active","block","children","close","color","disabled","href","inner","outline","size","value"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { active = false } = $$props;
	let { block = false } = $$props;
	let { children = '' } = $$props;
	let { close = false } = $$props;
	let { color = 'secondary' } = $$props;
	let { disabled = false } = $$props;
	let { href = '' } = $$props;
	let { inner = undefined } = $$props;
	let { outline = false } = $$props;
	let { size = '' } = $$props;
	let { value = '' } = $$props;

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function a_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(0, inner);
		});
	}

	function button_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(0, inner);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(22, $$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props)));
		$$invalidate(8, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ('active' in $$new_props) $$invalidate(10, active = $$new_props.active);
		if ('block' in $$new_props) $$invalidate(11, block = $$new_props.block);
		if ('children' in $$new_props) $$invalidate(1, children = $$new_props.children);
		if ('close' in $$new_props) $$invalidate(12, close = $$new_props.close);
		if ('color' in $$new_props) $$invalidate(13, color = $$new_props.color);
		if ('disabled' in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ('href' in $$new_props) $$invalidate(3, href = $$new_props.href);
		if ('inner' in $$new_props) $$invalidate(0, inner = $$new_props.inner);
		if ('outline' in $$new_props) $$invalidate(14, outline = $$new_props.outline);
		if ('size' in $$new_props) $$invalidate(15, size = $$new_props.size);
		if ('value' in $$new_props) $$invalidate(4, value = $$new_props.value);
		if ('$$scope' in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$$invalidate(7, ariaLabel = $$props['aria-label']);

		if ($$self.$$.dirty & /*className, close, outline, color, size, block, active*/ 65024) {
			$$invalidate(6, classes = classnames(className, close ? 'btn-close' : 'btn', close || `btn${outline ? '-outline' : ''}-${color}`, size ? `btn-${size}` : false, block ? 'd-block w-100' : false, { active }));
		}

		if ($$self.$$.dirty & /*close*/ 4096) {
			$$invalidate(5, defaultAriaLabel = close ? 'Close' : null);
		}
	};

	$$props = SvelteInternal.exclude_internal_props($$props);

	return [
		inner,
		children,
		disabled,
		href,
		value,
		defaultAriaLabel,
		classes,
		ariaLabel,
		$$restProps,
		className,
		active,
		block,
		close,
		color,
		outline,
		size,
		$$scope,
		slots,
		click_handler,
		click_handler_1,
		a_binding,
		button_binding
	];
}

class NodeModulesSveltestrapSveltestrapDistButtonButtonSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$1j, create_fragment$1j, SvelteInternal.safe_not_equal, {
			class: 9,
			active: 10,
			block: 11,
			children: 1,
			close: 12,
			color: 13,
			disabled: 2,
			href: 3,
			inner: 0,
			outline: 14,
			size: 15,
			value: 4
		});
	}

	get class() {
		return this.$$.ctx[9];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get active() {
		return this.$$.ctx[10];
	}

	set active(active) {
		this.$$set({ active });
		SvelteInternal.flush();
	}

	get block() {
		return this.$$.ctx[11];
	}

	set block(block) {
		this.$$set({ block });
		SvelteInternal.flush();
	}

	get children() {
		return this.$$.ctx[1];
	}

	set children(children) {
		this.$$set({ children });
		SvelteInternal.flush();
	}

	get close() {
		return this.$$.ctx[12];
	}

	set close(close) {
		this.$$set({ close });
		SvelteInternal.flush();
	}

	get color() {
		return this.$$.ctx[13];
	}

	set color(color) {
		this.$$set({ color });
		SvelteInternal.flush();
	}

	get disabled() {
		return this.$$.ctx[2];
	}

	set disabled(disabled) {
		this.$$set({ disabled });
		SvelteInternal.flush();
	}

	get href() {
		return this.$$.ctx[3];
	}

	set href(href) {
		this.$$set({ href });
		SvelteInternal.flush();
	}

	get inner() {
		return this.$$.ctx[0];
	}

	set inner(inner) {
		this.$$set({ inner });
		SvelteInternal.flush();
	}

	get outline() {
		return this.$$.ctx[14];
	}

	set outline(outline) {
		this.$$set({ outline });
		SvelteInternal.flush();
	}

	get size() {
		return this.$$.ctx[15];
	}

	set size(size) {
		this.$$set({ size });
		SvelteInternal.flush();
	}

	get value() {
		return this.$$.ctx[4];
	}

	set value(value) {
		this.$$set({ value });
		SvelteInternal.flush();
	}
}

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$2,
  requires: ['computeStyles']
};

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

var max = Math.max;
var min = Math.min;
var round = Math.round;

function getUAString() {
  var uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }

  return navigator.userAgent;
}

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  var _ref = isElement(element) ? getWindow(element) : window,
      visualViewport = _ref.visualViewport;

  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());

  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect$1(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect$1,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

function getVariation(placement) {
  return placement.split('-')[1];
}

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
      y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, getWindow(popper)) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

var hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$1[matched];
  });
}

var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases  research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = offset + overflow[mainSide];
    var max$1 = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? top : left;

    var _altSide = mainAxis === 'x' ? bottom : right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
            _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            effect = _ref.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

// Code derived from https://github.com/bryanmylee/svelte-popperjs/blob/master/src/index.ts
function createPopperActions(initOptions) {
  let contentNode;
  let options = initOptions;
  let popperInstance = null;
  let referenceNode;

  const initPopper = () => {
    if (referenceNode && contentNode) {
      popperInstance = createPopper(referenceNode, contentNode, options);
    }
  };

  const deinitPopper = () => {
    if (popperInstance) {
      popperInstance.destroy();
      popperInstance = null;
    }
  };

  const referenceAction = (node) => {
    referenceNode = node;
    initPopper();
    return {
      destroy() {
        deinitPopper();
      }
    };
  };

  const contentAction = (node, contentOptions) => {
    contentNode = node;
    options = Object.assign(Object.assign({}, initOptions), contentOptions);
    initPopper();

    return {
      update(newContentOptions) {
        options = Object.assign(Object.assign({}, initOptions), newContentOptions);
        if (popperInstance && options) {
          popperInstance.setOptions(options);
        }
      },
      destroy() {
        deinitPopper();
      }
    };
  };

  return [referenceAction, contentAction, () => popperInstance];
}

const createContext = () => SvelteStore.writable({});

/* nodeModulesSveltestrapSveltestrapDistDropdownDropdownSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block$n(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[20].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

	let div_levels = [
		/*$$restProps*/ ctx[4],
		{ class: /*classes*/ ctx[3] },
		{ "data-bs-theme": /*theme*/ ctx[1] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[22](div);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				(!current || dirty & /*theme*/ 2) && { "data-bs-theme": /*theme*/ ctx[1] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[22](null);
		}
	};
}

// (186:0) {#if nav}
function create_if_block$t(ctx) {
	let li;
	let current;
	const default_slot_template = /*#slots*/ ctx[20].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

	let li_levels = [
		/*$$restProps*/ ctx[4],
		{ class: /*classes*/ ctx[3] },
		{ "data-bs-theme": /*theme*/ ctx[1] }
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = SvelteInternal.assign(li_data, li_levels[i]);
	}

	return {
		c() {
			li = SvelteInternal.element("li");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(li, li_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, li, anchor);

			if (default_slot) {
				default_slot.m(li, null);
			}

			/*li_binding*/ ctx[21](li);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(li, li_data = SvelteInternal.get_spread_update(li_levels, [
				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				(!current || dirty & /*theme*/ 2) && { "data-bs-theme": /*theme*/ ctx[1] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(li);
			}

			if (default_slot) default_slot.d(detaching);
			/*li_binding*/ ctx[21](null);
		}
	};
}

function create_fragment$1i(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$t, create_else_block$n];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*nav*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$1i($$self, $$props, $$invalidate) {
	let subItemIsActive;
	let classes;
	let handleToggle;

	const omit_props_names = [
		"class","active","autoClose","direction","dropup","group","inNavbar","isOpen","nav","setActiveFromChild","size","theme","toggle"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const noop = () => undefined;
	let context = createContext();
	SvelteInternal.setContext('dropdownContext', context);
	const navbarContext = SvelteInternal.getContext('navbar');
	let { class: className = '' } = $$props;
	let { active = false } = $$props;
	let { autoClose = true } = $$props;
	let { direction = 'down' } = $$props;
	let { dropup = false } = $$props;
	let { group = false } = $$props;
	let { inNavbar = navbarContext ? navbarContext.inNavbar : false } = $$props;
	let { isOpen = false } = $$props;
	let { nav = false } = $$props;
	let { setActiveFromChild = false } = $$props;
	let { size = '' } = $$props;
	let { theme = null } = $$props;
	let { toggle = undefined } = $$props;
	const [popperRef, popperContent] = createPopperActions();
	const validDirections = ['up', 'down', 'left', 'right', 'start', 'end'];

	if (validDirections.indexOf(direction) === -1) {
		throw new Error(`Invalid direction sent: '${direction}' is not one of 'up', 'down', 'left', 'right', 'start', 'end'`);
	}

	let component;
	let dropdownDirection;

	function handleDocumentClick(e) {
		if (e && (e.which === 3 || e.type === 'keyup' && e.which !== 9)) return;

		if (component.contains(e.target) && component !== e.target && (e.type !== 'keyup' || e.which === 9)) {
			return;
		}

		if (autoClose === true || autoClose === 'outside') {
			handleToggle(e);
		}
	}

	SvelteInternal.onDestroy(() => {
		if (typeof document !== 'undefined') {
			['click', 'touchstart', 'keyup'].forEach(event => document.removeEventListener(event, handleDocumentClick, true));
		}
	});

	function li_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			component = $$value;
			$$invalidate(2, component);
		});
	}

	function div_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			component = $$value;
			$$invalidate(2, component);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('active' in $$new_props) $$invalidate(7, active = $$new_props.active);
		if ('autoClose' in $$new_props) $$invalidate(8, autoClose = $$new_props.autoClose);
		if ('direction' in $$new_props) $$invalidate(9, direction = $$new_props.direction);
		if ('dropup' in $$new_props) $$invalidate(10, dropup = $$new_props.dropup);
		if ('group' in $$new_props) $$invalidate(11, group = $$new_props.group);
		if ('inNavbar' in $$new_props) $$invalidate(12, inNavbar = $$new_props.inNavbar);
		if ('isOpen' in $$new_props) $$invalidate(5, isOpen = $$new_props.isOpen);
		if ('nav' in $$new_props) $$invalidate(0, nav = $$new_props.nav);
		if ('setActiveFromChild' in $$new_props) $$invalidate(13, setActiveFromChild = $$new_props.setActiveFromChild);
		if ('size' in $$new_props) $$invalidate(14, size = $$new_props.size);
		if ('theme' in $$new_props) $$invalidate(1, theme = $$new_props.theme);
		if ('toggle' in $$new_props) $$invalidate(15, toggle = $$new_props.toggle);
		if ('$$scope' in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*setActiveFromChild, component*/ 8196) {
			$$invalidate(18, subItemIsActive = !!(setActiveFromChild && component && typeof component.querySelector === 'function' && component.querySelector('.active')));
		}

		if ($$self.$$.dirty & /*direction*/ 512) {
			{
				if (direction === 'left') $$invalidate(16, dropdownDirection = 'start'); else if (direction === 'right') $$invalidate(16, dropdownDirection = 'end'); else $$invalidate(16, dropdownDirection = direction);
			}
		}

		if ($$self.$$.dirty & /*toggle, isOpen*/ 32800) {
			$$invalidate(17, handleToggle = toggle || (() => $$invalidate(5, isOpen = !isOpen)));
		}

		if ($$self.$$.dirty & /*className, direction, dropdownDirection, nav, active, setActiveFromChild, subItemIsActive, group, size, isOpen*/ 355041) {
			$$invalidate(3, classes = classnames(className, direction !== 'down' && `drop${dropdownDirection}`, nav && active ? 'active' : false, setActiveFromChild && subItemIsActive ? 'active' : false, {
				'btn-group': group,
				[`btn-group-${size}`]: !!size,
				dropdown: !group,
				show: isOpen,
				'nav-item': nav
			}));
		}

		if ($$self.$$.dirty & /*isOpen*/ 32) {
			{
				if (typeof document !== 'undefined') {
					if (isOpen) {
						['click', 'touchstart', 'keyup'].forEach(event => document.addEventListener(event, handleDocumentClick, true));
					} else {
						['click', 'touchstart', 'keyup'].forEach(event => document.removeEventListener(event, handleDocumentClick, true));
					}
				}
			}
		}

		if ($$self.$$.dirty & /*handleToggle, isOpen, autoClose, direction, dropup, nav, inNavbar*/ 136993) {
			{
				context.update(() => {
					return {
						toggle: handleToggle,
						isOpen,
						autoClose,
						direction: direction === 'down' && dropup ? 'up' : direction,
						inNavbar: nav || inNavbar,
						popperRef: nav ? noop : popperRef,
						popperContent: nav ? noop : popperContent
					};
				});
			}
		}
	};

	return [
		nav,
		theme,
		component,
		classes,
		$$restProps,
		isOpen,
		className,
		active,
		autoClose,
		direction,
		dropup,
		group,
		inNavbar,
		setActiveFromChild,
		size,
		toggle,
		dropdownDirection,
		handleToggle,
		subItemIsActive,
		$$scope,
		slots,
		li_binding,
		div_binding
	];
}

class NodeModulesSveltestrapSveltestrapDistDropdownDropdownSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$1i, create_fragment$1i, SvelteInternal.safe_not_equal, {
			class: 6,
			active: 7,
			autoClose: 8,
			direction: 9,
			dropup: 10,
			group: 11,
			inNavbar: 12,
			isOpen: 5,
			nav: 0,
			setActiveFromChild: 13,
			size: 14,
			theme: 1,
			toggle: 15
		});
	}

	get class() {
		return this.$$.ctx[6];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get active() {
		return this.$$.ctx[7];
	}

	set active(active) {
		this.$$set({ active });
		SvelteInternal.flush();
	}

	get autoClose() {
		return this.$$.ctx[8];
	}

	set autoClose(autoClose) {
		this.$$set({ autoClose });
		SvelteInternal.flush();
	}

	get direction() {
		return this.$$.ctx[9];
	}

	set direction(direction) {
		this.$$set({ direction });
		SvelteInternal.flush();
	}

	get dropup() {
		return this.$$.ctx[10];
	}

	set dropup(dropup) {
		this.$$set({ dropup });
		SvelteInternal.flush();
	}

	get group() {
		return this.$$.ctx[11];
	}

	set group(group) {
		this.$$set({ group });
		SvelteInternal.flush();
	}

	get inNavbar() {
		return this.$$.ctx[12];
	}

	set inNavbar(inNavbar) {
		this.$$set({ inNavbar });
		SvelteInternal.flush();
	}

	get isOpen() {
		return this.$$.ctx[5];
	}

	set isOpen(isOpen) {
		this.$$set({ isOpen });
		SvelteInternal.flush();
	}

	get nav() {
		return this.$$.ctx[0];
	}

	set nav(nav) {
		this.$$set({ nav });
		SvelteInternal.flush();
	}

	get setActiveFromChild() {
		return this.$$.ctx[13];
	}

	set setActiveFromChild(setActiveFromChild) {
		this.$$set({ setActiveFromChild });
		SvelteInternal.flush();
	}

	get size() {
		return this.$$.ctx[14];
	}

	set size(size) {
		this.$$set({ size });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[1];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}

	get toggle() {
		return this.$$.ctx[15];
	}

	set toggle(toggle) {
		this.$$set({ toggle });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistButtonDropdownButtonDropdownSvelte.svelte generated by Svelte v4.2.8 */


function create_default_slot$b(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$1h(ctx) {
	let dropdown;
	let current;
	const dropdown_spread_levels = [/*$$restProps*/ ctx[0], { group: true }];

	let dropdown_props = {
		$$slots: { default: [create_default_slot$b] },
		$$scope: { ctx }
	};

	for (let i = 0; i < dropdown_spread_levels.length; i += 1) {
		dropdown_props = SvelteInternal.assign(dropdown_props, dropdown_spread_levels[i]);
	}

	dropdown = new NodeModulesSveltestrapSveltestrapDistDropdownDropdownSvelte({ props: dropdown_props });
	dropdown.$on("click", /*click_handler*/ ctx[2]);

	return {
		c() {
			SvelteInternal.create_component(dropdown.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(dropdown, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const dropdown_changes = (dirty & /*$$restProps*/ 1)
			? SvelteInternal.get_spread_update(dropdown_spread_levels, [SvelteInternal.get_spread_object(/*$$restProps*/ ctx[0]), dropdown_spread_levels[1]])
			: {};

			if (dirty & /*$$scope*/ 8) {
				dropdown_changes.$$scope = { dirty, ctx };
			}

			dropdown.$set(dropdown_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(dropdown.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(dropdown.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(dropdown, detaching);
		}
	};
}

function instance$1h($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(0, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	return [$$restProps, slots, click_handler, $$scope];
}

class NodeModulesSveltestrapSveltestrapDistButtonDropdownButtonDropdownSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$1h, create_fragment$1h, SvelteInternal.safe_not_equal, {});
	}
}

/* nodeModulesSveltestrapSveltestrapDistButtonGroupButtonGroupSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$1g(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1g($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","size","vertical"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { size = '' } = $$props;
	let { vertical = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('size' in $$new_props) $$invalidate(3, size = $$new_props.size);
		if ('vertical' in $$new_props) $$invalidate(4, vertical = $$new_props.vertical);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, size, vertical*/ 28) {
			$$invalidate(0, classes = classnames(className, size ? `btn-group-${size}` : false, vertical ? 'btn-group-vertical' : 'btn-group'));
		}
	};

	return [classes, $$restProps, className, size, vertical, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistButtonGroupButtonGroupSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$1g, create_fragment$1g, SvelteInternal.safe_not_equal, { class: 2, size: 3, vertical: 4 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get size() {
		return this.$$.ctx[3];
	}

	set size(size) {
		this.$$set({ size });
		SvelteInternal.flush();
	}

	get vertical() {
		return this.$$.ctx[4];
	}

	set vertical(vertical) {
		this.$$set({ vertical });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistButtonToolbarButtonToolbarSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$1f(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { role: "toolbar" }, { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				{ role: "toolbar" },
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1f($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'btn-toolbar'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistButtonToolbarButtonToolbarSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$1f, create_fragment$1f, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCardCardSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$1e(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	let div_levels = [
		/*$$restProps*/ ctx[2],
		{ "data-bs-theme": /*theme*/ ctx[0] },
		{ class: /*classes*/ ctx[1] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(div, "click", /*click_handler*/ ctx[10]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*theme*/ 1) && { "data-bs-theme": /*theme*/ ctx[0] },
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$1e($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","body","color","inverse","outline","theme"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { body = false } = $$props;
	let { color = '' } = $$props;
	let { inverse = false } = $$props;
	let { outline = false } = $$props;
	let { theme = null } = $$props;

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('body' in $$new_props) $$invalidate(4, body = $$new_props.body);
		if ('color' in $$new_props) $$invalidate(5, color = $$new_props.color);
		if ('inverse' in $$new_props) $$invalidate(6, inverse = $$new_props.inverse);
		if ('outline' in $$new_props) $$invalidate(7, outline = $$new_props.outline);
		if ('theme' in $$new_props) $$invalidate(0, theme = $$new_props.theme);
		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, inverse, body, color, outline*/ 248) {
			$$invalidate(1, classes = classnames(className, 'card', inverse ? 'text-white' : false, body ? 'card-body' : false, color ? `${outline ? 'border' : 'bg'}-${color}` : false));
		}
	};

	return [
		theme,
		classes,
		$$restProps,
		className,
		body,
		color,
		inverse,
		outline,
		$$scope,
		slots,
		click_handler
	];
}

class NodeModulesSveltestrapSveltestrapDistCardCardSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$1e, create_fragment$1e, SvelteInternal.safe_not_equal, {
			class: 3,
			body: 4,
			color: 5,
			inverse: 6,
			outline: 7,
			theme: 0
		});
	}

	get class() {
		return this.$$.ctx[3];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get body() {
		return this.$$.ctx[4];
	}

	set body(body) {
		this.$$set({ body });
		SvelteInternal.flush();
	}

	get color() {
		return this.$$.ctx[5];
	}

	set color(color) {
		this.$$set({ color });
		SvelteInternal.flush();
	}

	get inverse() {
		return this.$$.ctx[6];
	}

	set inverse(inverse) {
		this.$$set({ inverse });
		SvelteInternal.flush();
	}

	get outline() {
		return this.$$.ctx[7];
	}

	set outline(outline) {
		this.$$set({ outline });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[0];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCardBodyCardBodySvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$1d(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1d($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'card-body'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistCardBodyCardBodySvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$1d, create_fragment$1d, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCardColumnsCardColumnsSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$1c(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1c($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'card-columns'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistCardColumnsCardColumnsSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$1c, create_fragment$1c, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCardDeckCardDeckSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$1b(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1b($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'card-deck'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistCardDeckCardDeckSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$1b, create_fragment$1b, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCardFooterCardFooterSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$1a(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1a($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'card-footer'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistCardFooterCardFooterSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$1a, create_fragment$1a, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCardGroupCardGroupSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$19(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$19($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'card-group'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistCardGroupCardGroupSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$19, create_fragment$19, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCardHeaderCardHeaderSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block$m(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(div, "click", /*click_handler_1*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (11:0) {#if tag === 'h3'}
function create_if_block$s(ctx) {
	let h3;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let h3_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
	let h3_data = {};

	for (let i = 0; i < h3_levels.length; i += 1) {
		h3_data = SvelteInternal.assign(h3_data, h3_levels[i]);
	}

	return {
		c() {
			h3 = SvelteInternal.element("h3");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(h3, h3_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, h3, anchor);

			if (default_slot) {
				default_slot.m(h3, null);
			}

			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(h3, "click", /*click_handler*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(h3, h3_data = SvelteInternal.get_spread_update(h3_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(h3);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$18(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$s, create_else_block$m];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[0] === 'h3') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$18($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","tag"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { tag = 'div' } = $$props;

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('tag' in $$new_props) $$invalidate(0, tag = $$new_props.tag);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 8) {
			$$invalidate(1, classes = classnames(className, 'card-header'));
		}
	};

	return [
		tag,
		classes,
		$$restProps,
		className,
		$$scope,
		slots,
		click_handler,
		click_handler_1
	];
}

class NodeModulesSveltestrapSveltestrapDistCardHeaderCardHeaderSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$18, create_fragment$18, SvelteInternal.safe_not_equal, { class: 3, tag: 0 });
	}

	get class() {
		return this.$$.ctx[3];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get tag() {
		return this.$$.ctx[0];
	}

	set tag(tag) {
		this.$$set({ tag });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCardImgCardImgSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$17(ctx) {
	let img;
	let img_src_value;

	let img_levels = [
		/*$$restProps*/ ctx[3],
		{ class: /*classes*/ ctx[2] },
		{ src: img_src_value = /*src*/ ctx[0] },
		{ alt: /*alt*/ ctx[1] }
	];

	let img_data = {};

	for (let i = 0; i < img_levels.length; i += 1) {
		img_data = SvelteInternal.assign(img_data, img_levels[i]);
	}

	return {
		c() {
			img = SvelteInternal.element("img");
			SvelteInternal.set_attributes(img, img_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, img, anchor);
		},
		p(ctx, [dirty]) {
			SvelteInternal.set_attributes(img, img_data = SvelteInternal.get_spread_update(img_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				dirty & /*classes*/ 4 && { class: /*classes*/ ctx[2] },
				dirty & /*src*/ 1 && !SvelteInternal.src_url_equal(img.src, img_src_value = /*src*/ ctx[0]) && { src: img_src_value },
				dirty & /*alt*/ 2 && { alt: /*alt*/ ctx[1] }
			]));
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(img);
			}
		}
	};
}

function instance$17($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","top","bottom","src","alt"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { class: className = '' } = $$props;
	let { top = false } = $$props;
	let { bottom = false } = $$props;
	let { src } = $$props;
	let { alt = '' } = $$props;
	let classes = '';

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('top' in $$new_props) $$invalidate(5, top = $$new_props.top);
		if ('bottom' in $$new_props) $$invalidate(6, bottom = $$new_props.bottom);
		if ('src' in $$new_props) $$invalidate(0, src = $$new_props.src);
		if ('alt' in $$new_props) $$invalidate(1, alt = $$new_props.alt);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*top, bottom, className*/ 112) {
			{
				let cardImgClassName = 'card-img';

				if (top) {
					cardImgClassName = 'card-img-top';
				}

				if (bottom) {
					cardImgClassName = 'card-img-bottom';
				}

				$$invalidate(2, classes = classnames(className, cardImgClassName));
			}
		}
	};

	return [src, alt, classes, $$restProps, className, top, bottom];
}

class NodeModulesSveltestrapSveltestrapDistCardImgCardImgSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$17, create_fragment$17, SvelteInternal.safe_not_equal, {
			class: 4,
			top: 5,
			bottom: 6,
			src: 0,
			alt: 1
		});
	}

	get class() {
		return this.$$.ctx[4];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get top() {
		return this.$$.ctx[5];
	}

	set top(top) {
		this.$$set({ top });
		SvelteInternal.flush();
	}

	get bottom() {
		return this.$$.ctx[6];
	}

	set bottom(bottom) {
		this.$$set({ bottom });
		SvelteInternal.flush();
	}

	get src() {
		return this.$$.ctx[0];
	}

	set src(src) {
		this.$$set({ src });
		SvelteInternal.flush();
	}

	get alt() {
		return this.$$.ctx[1];
	}

	set alt(alt) {
		this.$$set({ alt });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCardImgOverlayCardImgOverlaySvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$16(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$16($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'card-img-overlay'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistCardImgOverlayCardImgOverlaySvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$16, create_fragment$16, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCardLinkCardLinkSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$15(ctx) {
	let a;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let a_levels = [
		/*$$restProps*/ ctx[2],
		{ class: /*classes*/ ctx[1] },
		{ href: /*href*/ ctx[0] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = SvelteInternal.assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = SvelteInternal.element("a");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(a, a_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(a, a_data = SvelteInternal.get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(a);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$15($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","href"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { href = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('href' in $$new_props) $$invalidate(0, href = $$new_props.href);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 8) {
			$$invalidate(1, classes = classnames(className, 'card-link'));
		}
	};

	return [href, classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistCardLinkCardLinkSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$15, create_fragment$15, SvelteInternal.safe_not_equal, { class: 3, href: 0 });
	}

	get class() {
		return this.$$.ctx[3];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get href() {
		return this.$$.ctx[0];
	}

	set href(href) {
		this.$$set({ href });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCardSubtitleCardSubtitleSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$14(ctx) {
	let h6;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let h6_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let h6_data = {};

	for (let i = 0; i < h6_levels.length; i += 1) {
		h6_data = SvelteInternal.assign(h6_data, h6_levels[i]);
	}

	return {
		c() {
			h6 = SvelteInternal.element("h6");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(h6, h6_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, h6, anchor);

			if (default_slot) {
				default_slot.m(h6, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(h6, h6_data = SvelteInternal.get_spread_update(h6_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(h6);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$14($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'card-subtitle'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistCardSubtitleCardSubtitleSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$14, create_fragment$14, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCardTextCardTextSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$13(ctx) {
	let p;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let p_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let p_data = {};

	for (let i = 0; i < p_levels.length; i += 1) {
		p_data = SvelteInternal.assign(p_data, p_levels[i]);
	}

	return {
		c() {
			p = SvelteInternal.element("p");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(p, p_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(p, p_data = SvelteInternal.get_spread_update(p_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(p);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$13($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'card-text'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistCardTextCardTextSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$13, create_fragment$13, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCardTitleCardTitleSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$12(ctx) {
	let h5;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let h5_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let h5_data = {};

	for (let i = 0; i < h5_levels.length; i += 1) {
		h5_data = SvelteInternal.assign(h5_data, h5_levels[i]);
	}

	return {
		c() {
			h5 = SvelteInternal.element("h5");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(h5, h5_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, h5, anchor);

			if (default_slot) {
				default_slot.m(h5, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(h5, h5_data = SvelteInternal.get_spread_update(h5_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(h5);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$12($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'card-title'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistCardTitleCardTitleSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$12, create_fragment$12, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCarouselCarouselSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$11(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	let div_levels = [
		/*$$restProps*/ ctx[6],
		{ role: "presentation" },
		{ class: /*classes*/ ctx[2] },
		{ "data-bs-theme": /*theme*/ ctx[1] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(window, "keydown", /*handleKeydown*/ ctx[3]),
					SvelteInternal.listen(div, "mouseenter", /*mouseenter_handler*/ ctx[15]),
					SvelteInternal.listen(div, "mouseleave", /*mouseleave_handler*/ ctx[16])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				{ role: "presentation" },
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				(!current || dirty & /*theme*/ 2) && { "data-bs-theme": /*theme*/ ctx[1] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

function instance$11($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","activeIndex","interval","items","keyboard","pause","ride","theme"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let classes = '';
	let { class: className = '' } = $$props;
	let { activeIndex = 0 } = $$props;
	let { interval = 5000 } = $$props;
	let { items = [] } = $$props;
	let { keyboard = true } = $$props;
	let { pause = true } = $$props;
	let { ride = true } = $$props;
	let { theme = null } = $$props;
	let _rideTimeoutId = false;
	let _removeVisibilityChangeListener = false;

	SvelteInternal.onMount(() => {
		setRideTimeout();

		_removeVisibilityChangeListener = browserEvent(document, 'visibilitychange', () => {
			if (document.visibilityState === 'hidden') {
				clearRideTimeout();
			} else {
				setRideTimeout();
			}
		});
	});

	SvelteInternal.onDestroy(() => {
		if (_rideTimeoutId) {
			clearTimeout(_rideTimeoutId);
		}

		if (_removeVisibilityChangeListener) {
			_removeVisibilityChangeListener();
		}
	});

	function handleKeydown(event) {
		if (!keyboard) {
			return;
		}

		let direction = '';

		if (event.key === 'ArrowLeft') {
			direction = 'prev';
		} else if (event.key === 'ArrowRight') {
			direction = 'next';
		} else {
			return;
		}

		$$invalidate(7, activeIndex = getNewCarouselActiveIndex(direction, items, activeIndex));
	}

	function setRideTimeout() {
		clearRideTimeout();

		if (ride) {
			_rideTimeoutId = setTimeout(autoNext, interval);
		}
	}

	function clearRideTimeout() {
		if (_rideTimeoutId) {
			clearTimeout(_rideTimeoutId);
		}
	}

	function autoNext() {
		$$invalidate(7, activeIndex = getNewCarouselActiveIndex('next', items, activeIndex));
	}

	const mouseenter_handler = () => pause ? clearRideTimeout() : undefined;
	const mouseleave_handler = () => pause ? setRideTimeout() : undefined;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ('activeIndex' in $$new_props) $$invalidate(7, activeIndex = $$new_props.activeIndex);
		if ('interval' in $$new_props) $$invalidate(9, interval = $$new_props.interval);
		if ('items' in $$new_props) $$invalidate(10, items = $$new_props.items);
		if ('keyboard' in $$new_props) $$invalidate(11, keyboard = $$new_props.keyboard);
		if ('pause' in $$new_props) $$invalidate(0, pause = $$new_props.pause);
		if ('ride' in $$new_props) $$invalidate(12, ride = $$new_props.ride);
		if ('theme' in $$new_props) $$invalidate(1, theme = $$new_props.theme);
		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 256) {
			$$invalidate(2, classes = classnames(className, 'carousel', 'slide'));
		}
	};

	return [
		pause,
		theme,
		classes,
		handleKeydown,
		setRideTimeout,
		clearRideTimeout,
		$$restProps,
		activeIndex,
		className,
		interval,
		items,
		keyboard,
		ride,
		$$scope,
		slots,
		mouseenter_handler,
		mouseleave_handler
	];
}

class NodeModulesSveltestrapSveltestrapDistCarouselCarouselSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$11, create_fragment$11, SvelteInternal.safe_not_equal, {
			class: 8,
			activeIndex: 7,
			interval: 9,
			items: 10,
			keyboard: 11,
			pause: 0,
			ride: 12,
			theme: 1
		});
	}

	get class() {
		return this.$$.ctx[8];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get activeIndex() {
		return this.$$.ctx[7];
	}

	set activeIndex(activeIndex) {
		this.$$set({ activeIndex });
		SvelteInternal.flush();
	}

	get interval() {
		return this.$$.ctx[9];
	}

	set interval(interval) {
		this.$$set({ interval });
		SvelteInternal.flush();
	}

	get items() {
		return this.$$.ctx[10];
	}

	set items(items) {
		this.$$set({ items });
		SvelteInternal.flush();
	}

	get keyboard() {
		return this.$$.ctx[11];
	}

	set keyboard(keyboard) {
		this.$$set({ keyboard });
		SvelteInternal.flush();
	}

	get pause() {
		return this.$$.ctx[0];
	}

	set pause(pause) {
		this.$$set({ pause });
		SvelteInternal.flush();
	}

	get ride() {
		return this.$$.ctx[12];
	}

	set ride(ride) {
		this.$$set({ ride });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[1];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCarouselCaptionCarouselCaptionSvelte.svelte generated by Svelte v4.2.8 */


function create_if_block_1$h(ctx) {
	let h5;
	let t;

	return {
		c() {
			h5 = SvelteInternal.element("h5");
			t = SvelteInternal.text(/*captionHeader*/ ctx[0]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, h5, anchor);
			SvelteInternal.append(h5, t);
		},
		p(ctx, dirty) {
			if (dirty & /*captionHeader*/ 1) SvelteInternal.set_data(t, /*captionHeader*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(h5);
			}
		}
	};
}

// (15:2) {#if captionText}
function create_if_block$r(ctx) {
	let p;
	let t;

	return {
		c() {
			p = SvelteInternal.element("p");
			t = SvelteInternal.text(/*captionText*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, p, anchor);
			SvelteInternal.append(p, t);
		},
		p(ctx, dirty) {
			if (dirty & /*captionText*/ 2) SvelteInternal.set_data(t, /*captionText*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(p);
			}
		}
	};
}

function create_fragment$10(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let if_block0 = /*captionHeader*/ ctx[0] && create_if_block_1$h(ctx);
	let if_block1 = /*captionText*/ ctx[1] && create_if_block$r(ctx);
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (if_block0) if_block0.c();
			t0 = SvelteInternal.space();
			if (if_block1) if_block1.c();
			t1 = SvelteInternal.space();
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			SvelteInternal.append(div, t0);
			if (if_block1) if_block1.m(div, null);
			SvelteInternal.append(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (/*captionHeader*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$h(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*captionText*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$r(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$10($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","captionHeader","captionText"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let classes = '';
	let { class: className = '' } = $$props;
	let { captionHeader = '' } = $$props;
	let { captionText = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('captionHeader' in $$new_props) $$invalidate(0, captionHeader = $$new_props.captionHeader);
		if ('captionText' in $$new_props) $$invalidate(1, captionText = $$new_props.captionText);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 16) {
			$$invalidate(2, classes = classnames(className, 'carousel-caption', 'd-none', 'd-md-block'));
		}
	};

	return [captionHeader, captionText, classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistCarouselCaptionCarouselCaptionSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$10, create_fragment$10, SvelteInternal.safe_not_equal, {
			class: 4,
			captionHeader: 0,
			captionText: 1
		});
	}

	get class() {
		return this.$$.ctx[4];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get captionHeader() {
		return this.$$.ctx[0];
	}

	set captionHeader(captionHeader) {
		this.$$set({ captionHeader });
		SvelteInternal.flush();
	}

	get captionText() {
		return this.$$.ctx[1];
	}

	set captionText(captionText) {
		this.$$set({ captionText });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCarouselControlCarouselControlSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$$(ctx) {
	let a;
	let span0;
	let span0_class_value;
	let t0;
	let span1;
	let t1;
	let a_href_value;
	let mounted;
	let dispose;

	let a_levels = [
		/*$$restProps*/ ctx[4],
		{ class: /*classes*/ ctx[1] },
		{ role: "button" },
		{
			href: a_href_value = "#" + /*direction*/ ctx[0]
		}
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = SvelteInternal.assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = SvelteInternal.element("a");
			span0 = SvelteInternal.element("span");
			t0 = SvelteInternal.space();
			span1 = SvelteInternal.element("span");
			t1 = SvelteInternal.text(/*screenText*/ ctx[2]);
			SvelteInternal.attr(span0, "class", span0_class_value = "carousel-control-" + /*direction*/ ctx[0] + "-icon");
			SvelteInternal.attr(span0, "aria-hidden", "true");
			SvelteInternal.attr(span1, "class", "visually-hidden");
			SvelteInternal.set_attributes(a, a_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, a, anchor);
			SvelteInternal.append(a, span0);
			SvelteInternal.append(a, t0);
			SvelteInternal.append(a, span1);
			SvelteInternal.append(span1, t1);

			if (!mounted) {
				dispose = SvelteInternal.listen(a, "click", SvelteInternal.prevent_default(/*clickHandler*/ ctx[3]));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*direction*/ 1 && span0_class_value !== (span0_class_value = "carousel-control-" + /*direction*/ ctx[0] + "-icon")) {
				SvelteInternal.attr(span0, "class", span0_class_value);
			}

			if (dirty & /*screenText*/ 4) SvelteInternal.set_data(t1, /*screenText*/ ctx[2]);

			SvelteInternal.set_attributes(a, a_data = SvelteInternal.get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
				dirty & /*classes*/ 2 && { class: /*classes*/ ctx[1] },
				{ role: "button" },
				dirty & /*direction*/ 1 && a_href_value !== (a_href_value = "#" + /*direction*/ ctx[0]) && { href: a_href_value }
			]));
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(a);
			}

			mounted = false;
			dispose();
		}
	};
}

function instance$$($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","direction","directionText","activeIndex","items","wrap"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { class: className = '' } = $$props;
	let { direction = '' } = $$props;
	let { directionText = '' } = $$props;
	let { activeIndex = 0 } = $$props;
	let { items = [] } = $$props;
	let { wrap = true } = $$props;
	let classes = '';
	let screenText = '';

	function clickHandler() {
		const endOrBeginning = direction === 'next' && activeIndex + 1 > items.length - 1 || direction === 'prev' && activeIndex - 1 < 0;

		if (!wrap && endOrBeginning) {
			return;
		}

		$$invalidate(5, activeIndex = getNewCarouselActiveIndex(direction, items, activeIndex));
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('direction' in $$new_props) $$invalidate(0, direction = $$new_props.direction);
		if ('directionText' in $$new_props) $$invalidate(7, directionText = $$new_props.directionText);
		if ('activeIndex' in $$new_props) $$invalidate(5, activeIndex = $$new_props.activeIndex);
		if ('items' in $$new_props) $$invalidate(8, items = $$new_props.items);
		if ('wrap' in $$new_props) $$invalidate(9, wrap = $$new_props.wrap);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*direction, className*/ 65) {
			$$invalidate(1, classes = classnames(`carousel-control-${direction}`, className));
		}

		if ($$self.$$.dirty & /*directionText, direction*/ 129) {
			$$invalidate(2, screenText = directionText
			? directionText
			: direction === 'next' ? 'Next' : 'Previous');
		}
	};

	return [
		direction,
		classes,
		screenText,
		clickHandler,
		$$restProps,
		activeIndex,
		className,
		directionText,
		items,
		wrap
	];
}

class NodeModulesSveltestrapSveltestrapDistCarouselControlCarouselControlSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$$, create_fragment$$, SvelteInternal.safe_not_equal, {
			class: 6,
			direction: 0,
			directionText: 7,
			activeIndex: 5,
			items: 8,
			wrap: 9
		});
	}

	get class() {
		return this.$$.ctx[6];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get direction() {
		return this.$$.ctx[0];
	}

	set direction(direction) {
		this.$$set({ direction });
		SvelteInternal.flush();
	}

	get directionText() {
		return this.$$.ctx[7];
	}

	set directionText(directionText) {
		this.$$set({ directionText });
		SvelteInternal.flush();
	}

	get activeIndex() {
		return this.$$.ctx[5];
	}

	set activeIndex(activeIndex) {
		this.$$set({ activeIndex });
		SvelteInternal.flush();
	}

	get items() {
		return this.$$.ctx[8];
	}

	set items(items) {
		this.$$set({ items });
		SvelteInternal.flush();
	}

	get wrap() {
		return this.$$.ctx[9];
	}

	set wrap(wrap) {
		this.$$set({ wrap });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCarouselIndicatorsCarouselIndicatorsSvelte.svelte generated by Svelte v4.2.8 */


function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	child_ctx[8] = i;
	return child_ctx;
}

// (14:2) {#each items as item, index}
function create_each_block$2(ctx) {
	let button;
	let t0_value = (/*item*/ ctx[6].title ? /*item*/ ctx[6].title : '') + "";
	let t0;
	let t1;
	let button_aria_current_value;
	let button_aria_label_value;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[5](/*index*/ ctx[8]);
	}

	return {
		c() {
			button = SvelteInternal.element("button");
			t0 = SvelteInternal.text(t0_value);
			t1 = SvelteInternal.space();
			SvelteInternal.attr(button, "data-bs-target", "");
			SvelteInternal.attr(button, "aria-current", button_aria_current_value = /*activeIndex*/ ctx[0] === /*index*/ ctx[8]);
			SvelteInternal.attr(button, "aria-label", button_aria_label_value = /*item*/ ctx[6].title);
			SvelteInternal.toggle_class(button, "active", /*activeIndex*/ ctx[0] === /*index*/ ctx[8]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, button, anchor);
			SvelteInternal.append(button, t0);
			SvelteInternal.append(button, t1);

			if (!mounted) {
				dispose = SvelteInternal.listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*items*/ 2 && t0_value !== (t0_value = (/*item*/ ctx[6].title ? /*item*/ ctx[6].title : '') + "")) SvelteInternal.set_data(t0, t0_value);

			if (dirty & /*activeIndex*/ 1 && button_aria_current_value !== (button_aria_current_value = /*activeIndex*/ ctx[0] === /*index*/ ctx[8])) {
				SvelteInternal.attr(button, "aria-current", button_aria_current_value);
			}

			if (dirty & /*items*/ 2 && button_aria_label_value !== (button_aria_label_value = /*item*/ ctx[6].title)) {
				SvelteInternal.attr(button, "aria-label", button_aria_label_value);
			}

			if (dirty & /*activeIndex*/ 1) {
				SvelteInternal.toggle_class(button, "active", /*activeIndex*/ ctx[0] === /*index*/ ctx[8]);
			}
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

function create_fragment$_(ctx) {
	let div;
	let each_value = SvelteInternal.ensure_array_like(/*items*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	let div_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*activeIndex, items*/ 3) {
				each_value = SvelteInternal.ensure_array_like(/*items*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				dirty & /*classes*/ 4 && { class: /*classes*/ ctx[2] }
			]));
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			SvelteInternal.destroy_each(each_blocks, detaching);
		}
	};
}

function instance$_($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","items","activeIndex"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { class: className = '' } = $$props;
	let classes = '';
	let { items = [] } = $$props;
	let { activeIndex = 0 } = $$props;
	const click_handler = index => $$invalidate(0, activeIndex = index);

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('items' in $$new_props) $$invalidate(1, items = $$new_props.items);
		if ('activeIndex' in $$new_props) $$invalidate(0, activeIndex = $$new_props.activeIndex);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 16) {
			$$invalidate(2, classes = classnames(className, 'carousel-indicators'));
		}
	};

	return [activeIndex, items, classes, $$restProps, className, click_handler];
}

class NodeModulesSveltestrapSveltestrapDistCarouselIndicatorsCarouselIndicatorsSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$_, create_fragment$_, SvelteInternal.safe_not_equal, { class: 4, items: 1, activeIndex: 0 });
	}

	get class() {
		return this.$$.ctx[4];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get items() {
		return this.$$.ctx[1];
	}

	set items(items) {
		this.$$set({ items });
		SvelteInternal.flush();
	}

	get activeIndex() {
		return this.$$.ctx[0];
	}

	set activeIndex(activeIndex) {
		this.$$set({ activeIndex });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistCarouselItemCarouselItemSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$Z(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	let div_levels = [
		/*$$restProps*/ ctx[3],
		{
			class: div_class_value = "" + (/*classes*/ ctx[2] + " active")
		}
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
			SvelteInternal.toggle_class(div, "active", /*itemIndex*/ ctx[0] === /*activeIndex*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4 && div_class_value !== (div_class_value = "" + (/*classes*/ ctx[2] + " active"))) && { class: div_class_value }
			]));

			SvelteInternal.toggle_class(div, "active", /*itemIndex*/ ctx[0] === /*activeIndex*/ ctx[1]);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$Z($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","itemIndex","activeIndex"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let classes = '';
	let { class: className = '' } = $$props;
	let { itemIndex = 0 } = $$props;
	let { activeIndex = 0 } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('itemIndex' in $$new_props) $$invalidate(0, itemIndex = $$new_props.itemIndex);
		if ('activeIndex' in $$new_props) $$invalidate(1, activeIndex = $$new_props.activeIndex);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 16) {
			$$invalidate(2, classes = classnames(className, 'carousel-item'));
		}
	};

	return [itemIndex, activeIndex, classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistCarouselItemCarouselItemSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$Z, create_fragment$Z, SvelteInternal.safe_not_equal, { class: 4, itemIndex: 0, activeIndex: 1 });
	}

	get class() {
		return this.$$.ctx[4];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get itemIndex() {
		return this.$$.ctx[0];
	}

	set itemIndex(itemIndex) {
		this.$$set({ itemIndex });
		SvelteInternal.flush();
	}

	get activeIndex() {
		return this.$$.ctx[1];
	}

	set activeIndex(activeIndex) {
		this.$$set({ activeIndex });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistColColSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$Y(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	let div_levels = [
		/*$$restProps*/ ctx[1],
		{
			class: div_class_value = /*colClasses*/ ctx[0].join(' ')
		}
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				{ class: div_class_value }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$Y($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","xs","sm","md","lg","xl","xxl"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { xs = undefined } = $$props;
	let { sm = undefined } = $$props;
	let { md = undefined } = $$props;
	let { lg = undefined } = $$props;
	let { xl = undefined } = $$props;
	let { xxl = undefined } = $$props;
	const colClasses = [];
	const lookup = { xs, sm, md, lg, xl, xxl };

	Object.keys(lookup).forEach(colWidth => {
		const columnProp = lookup[colWidth];

		if (!columnProp && columnProp !== '') {
			return; //no value for this width
		}

		const isXs = colWidth === 'xs';

		if (isObject(columnProp)) {
			const colSizeInterfix = isXs ? '-' : `-${colWidth}-`;
			const colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);

			if (columnProp.size || columnProp.size === '') {
				colClasses.push(colClass);
			}

			if (columnProp.push) {
				colClasses.push(`push${colSizeInterfix}${columnProp.push}`);
			}

			if (columnProp.pull) {
				colClasses.push(`pull${colSizeInterfix}${columnProp.pull}`);
			}

			if (columnProp.offset) {
				colClasses.push(`offset${colSizeInterfix}${columnProp.offset}`);
			}

			if (columnProp.order) {
				colClasses.push(`order${colSizeInterfix}${columnProp.order}`);
			}
		} else {
			colClasses.push(getColumnSizeClass(isXs, colWidth, columnProp));
		}
	});

	if (!colClasses.length) {
		colClasses.push('col');
	}

	if (className) {
		colClasses.push(className);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('xs' in $$new_props) $$invalidate(3, xs = $$new_props.xs);
		if ('sm' in $$new_props) $$invalidate(4, sm = $$new_props.sm);
		if ('md' in $$new_props) $$invalidate(5, md = $$new_props.md);
		if ('lg' in $$new_props) $$invalidate(6, lg = $$new_props.lg);
		if ('xl' in $$new_props) $$invalidate(7, xl = $$new_props.xl);
		if ('xxl' in $$new_props) $$invalidate(8, xxl = $$new_props.xxl);
		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	return [colClasses, $$restProps, className, xs, sm, md, lg, xl, xxl, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistColColSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$Y, create_fragment$Y, SvelteInternal.safe_not_equal, {
			class: 2,
			xs: 3,
			sm: 4,
			md: 5,
			lg: 6,
			xl: 7,
			xxl: 8
		});
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get xs() {
		return this.$$.ctx[3];
	}

	set xs(xs) {
		this.$$set({ xs });
		SvelteInternal.flush();
	}

	get sm() {
		return this.$$.ctx[4];
	}

	set sm(sm) {
		this.$$set({ sm });
		SvelteInternal.flush();
	}

	get md() {
		return this.$$.ctx[5];
	}

	set md(md) {
		this.$$set({ md });
		SvelteInternal.flush();
	}

	get lg() {
		return this.$$.ctx[6];
	}

	set lg(lg) {
		this.$$set({ lg });
		SvelteInternal.flush();
	}

	get xl() {
		return this.$$.ctx[7];
	}

	set xl(xl) {
		this.$$set({ xl });
		SvelteInternal.flush();
	}

	get xxl() {
		return this.$$.ctx[8];
	}

	set xxl(xxl) {
		this.$$set({ xxl });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistColumnColumnSvelte.svelte generated by Svelte v4.2.8 */




const get_header_slot_changes$1 = dirty => ({});
const get_header_slot_context$1 = ctx => ({});
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});

// (27:0) {:else}
function create_else_block$l(ctx) {
	let td;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let td_levels = [{ class: /*className*/ ctx[0] }, /*$$restProps*/ ctx[7]];
	let td_data = {};

	for (let i = 0; i < td_levels.length; i += 1) {
		td_data = SvelteInternal.assign(td_data, td_levels[i]);
	}

	return {
		c() {
			td = SvelteInternal.element("td");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(td, td_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, td, anchor);

			if (default_slot) {
				default_slot.m(td, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(td, td_data = SvelteInternal.get_spread_update(td_levels, [
				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7]
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(td);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (22:15) 
function create_if_block_3$3(ctx) {
	let th;
	let t;
	let current;
	let if_block = /*header*/ ctx[2] && create_if_block_4$2(ctx);
	const header_slot_template = /*#slots*/ ctx[9].header;
	const header_slot = SvelteInternal.create_slot(header_slot_template, ctx, /*$$scope*/ ctx[8], get_header_slot_context$1);
	let th_levels = [/*$$restProps*/ ctx[7]];
	let th_data = {};

	for (let i = 0; i < th_levels.length; i += 1) {
		th_data = SvelteInternal.assign(th_data, th_levels[i]);
	}

	return {
		c() {
			th = SvelteInternal.element("th");
			if (if_block) if_block.c();
			t = SvelteInternal.space();
			if (header_slot) header_slot.c();
			SvelteInternal.set_attributes(th, th_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, th, anchor);
			if (if_block) if_block.m(th, null);
			SvelteInternal.append(th, t);

			if (header_slot) {
				header_slot.m(th, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*header*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4$2(ctx);
					if_block.c();
					if_block.m(th, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					SvelteInternal.update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: SvelteInternal.get_slot_changes(header_slot_template, /*$$scope*/ ctx[8], dirty, get_header_slot_changes$1),
						get_header_slot_context$1
					);
				}
			}

			SvelteInternal.set_attributes(th, th_data = SvelteInternal.get_spread_update(th_levels, [dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7]]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(th);
			}

			if (if_block) if_block.d();
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (17:15) 
function create_if_block_1$g(ctx) {
	let th;
	let t;
	let current;
	let if_block = /*footer*/ ctx[1] && create_if_block_2$9(ctx);
	const footer_slot_template = /*#slots*/ ctx[9].footer;
	const footer_slot = SvelteInternal.create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[8], get_footer_slot_context);
	let th_levels = [/*$$restProps*/ ctx[7]];
	let th_data = {};

	for (let i = 0; i < th_levels.length; i += 1) {
		th_data = SvelteInternal.assign(th_data, th_levels[i]);
	}

	return {
		c() {
			th = SvelteInternal.element("th");
			if (if_block) if_block.c();
			t = SvelteInternal.space();
			if (footer_slot) footer_slot.c();
			SvelteInternal.set_attributes(th, th_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, th, anchor);
			if (if_block) if_block.m(th, null);
			SvelteInternal.append(th, t);

			if (footer_slot) {
				footer_slot.m(th, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*footer*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$9(ctx);
					if_block.c();
					if_block.m(th, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					SvelteInternal.update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: SvelteInternal.get_slot_changes(footer_slot_template, /*$$scope*/ ctx[8], dirty, get_footer_slot_changes),
						get_footer_slot_context
					);
				}
			}

			SvelteInternal.set_attributes(th, th_data = SvelteInternal.get_spread_update(th_levels, [dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7]]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(th);
			}

			if (if_block) if_block.d();
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

// (15:0) {#if colgroup}
function create_if_block$q(ctx) {
	let col;

	return {
		c() {
			col = SvelteInternal.element("col");
			SvelteInternal.set_style(col, "width", /*width*/ ctx[3]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, col, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*width*/ 8) {
				SvelteInternal.set_style(col, "width", /*width*/ ctx[3]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(col);
			}
		}
	};
}

// (24:4) {#if header}
function create_if_block_4$2(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*header*/ ctx[2]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*header*/ 4) SvelteInternal.set_data(t, /*header*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (19:4) {#if footer}
function create_if_block_2$9(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*footer*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*footer*/ 2) SvelteInternal.set_data(t, /*footer*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

function create_fragment$X(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$q, create_if_block_1$g, create_if_block_3$3, create_else_block$l];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*colgroup*/ ctx[4]) return 0;
		if (/*foot*/ ctx[6]) return 1;
		if (/*head*/ ctx[5]) return 2;
		return 3;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$X($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","footer","header","width"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { footer = undefined } = $$props;
	let { header = undefined } = $$props;
	let { width = undefined } = $$props;
	const colgroup = SvelteInternal.getContext('colgroup');
	const head = SvelteInternal.getContext('header');
	const foot = SvelteInternal.getContext('footer');

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ('footer' in $$new_props) $$invalidate(1, footer = $$new_props.footer);
		if ('header' in $$new_props) $$invalidate(2, header = $$new_props.header);
		if ('width' in $$new_props) $$invalidate(3, width = $$new_props.width);
		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	return [
		className,
		footer,
		header,
		width,
		colgroup,
		head,
		foot,
		$$restProps,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistColumnColumnSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$X, create_fragment$X, SvelteInternal.safe_not_equal, { class: 0, footer: 1, header: 2, width: 3 });
	}

	get class() {
		return this.$$.ctx[0];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get footer() {
		return this.$$.ctx[1];
	}

	set footer(footer) {
		this.$$set({ footer });
		SvelteInternal.flush();
	}

	get header() {
		return this.$$.ctx[2];
	}

	set header(header) {
		this.$$set({ header });
		SvelteInternal.flush();
	}

	get width() {
		return this.$$.ctx[3];
	}

	set width(width) {
		this.$$set({ width });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistContainerContainerSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$W(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$W($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","sm","md","lg","xl","xxl","fluid"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { sm = undefined } = $$props;
	let { md = undefined } = $$props;
	let { lg = undefined } = $$props;
	let { xl = undefined } = $$props;
	let { xxl = undefined } = $$props;
	let { fluid = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('sm' in $$new_props) $$invalidate(3, sm = $$new_props.sm);
		if ('md' in $$new_props) $$invalidate(4, md = $$new_props.md);
		if ('lg' in $$new_props) $$invalidate(5, lg = $$new_props.lg);
		if ('xl' in $$new_props) $$invalidate(6, xl = $$new_props.xl);
		if ('xxl' in $$new_props) $$invalidate(7, xxl = $$new_props.xxl);
		if ('fluid' in $$new_props) $$invalidate(8, fluid = $$new_props.fluid);
		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, sm, md, lg, xl, xxl, fluid*/ 508) {
			$$invalidate(0, classes = classnames(className, {
				'container-sm': sm,
				'container-md': md,
				'container-lg': lg,
				'container-xl': xl,
				'container-xxl': xxl,
				'container-fluid': fluid,
				container: !sm && !md && !lg && !xl && !xxl && !fluid
			}));
		}
	};

	return [classes, $$restProps, className, sm, md, lg, xl, xxl, fluid, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistContainerContainerSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$W, create_fragment$W, SvelteInternal.safe_not_equal, {
			class: 2,
			sm: 3,
			md: 4,
			lg: 5,
			xl: 6,
			xxl: 7,
			fluid: 8
		});
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get sm() {
		return this.$$.ctx[3];
	}

	set sm(sm) {
		this.$$set({ sm });
		SvelteInternal.flush();
	}

	get md() {
		return this.$$.ctx[4];
	}

	set md(md) {
		this.$$set({ md });
		SvelteInternal.flush();
	}

	get lg() {
		return this.$$.ctx[5];
	}

	set lg(lg) {
		this.$$set({ lg });
		SvelteInternal.flush();
	}

	get xl() {
		return this.$$.ctx[6];
	}

	set xl(xl) {
		this.$$set({ xl });
		SvelteInternal.flush();
	}

	get xxl() {
		return this.$$.ctx[7];
	}

	set xxl(xxl) {
		this.$$set({ xxl });
		SvelteInternal.flush();
	}

	get fluid() {
		return this.$$.ctx[8];
	}

	set fluid(fluid) {
		this.$$set({ fluid });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistDropdownItemDropdownItemSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block$k(ctx) {
	let button;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let button_levels = [{ type: "button" }, /*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = SvelteInternal.assign(button_data, button_levels[i]);
	}

	return {
		c() {
			button = SvelteInternal.element("button");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(button, button_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			if (button.autofocus) button.focus();
			current = true;

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(button, "click", /*click_handler_1*/ ctx[14]),
					SvelteInternal.listen(button, "click", /*handleItemClick*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(button, button_data = SvelteInternal.get_spread_update(button_levels, [
				{ type: "button" },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(button);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (47:17) 
function create_if_block_2$8(ctx) {
	let a;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let a_levels = [
		/*$$restProps*/ ctx[6],
		{ click: "" },
		{ href: /*href*/ ctx[2] },
		{ class: /*classes*/ ctx[3] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = SvelteInternal.assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = SvelteInternal.element("a");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(a, a_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(a, "click", /*handleItemClick*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(a, a_data = SvelteInternal.get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				{ click: "" },
				(!current || dirty & /*href*/ 4) && { href: /*href*/ ctx[2] },
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(a);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (42:20) 
function create_if_block_1$f(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let div_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(div, "click", /*click_handler*/ ctx[13]),
					SvelteInternal.listen(div, "click", /*handleItemClick*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (38:2) {#if header}
function create_if_block$p(ctx) {
	let h6;
	let current;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let h6_levels = [/*$$restProps*/ ctx[6], { class: /*classes*/ ctx[3] }];
	let h6_data = {};

	for (let i = 0; i < h6_levels.length; i += 1) {
		h6_data = SvelteInternal.assign(h6_data, h6_levels[i]);
	}

	return {
		c() {
			h6 = SvelteInternal.element("h6");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(h6, h6_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, h6, anchor);

			if (default_slot) {
				default_slot.m(h6, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(h6, h6_data = SvelteInternal.get_spread_update(h6_levels, [
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(h6);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$V(ctx) {
	let li;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$p, create_if_block_1$f, create_if_block_2$8, create_else_block$k];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*header*/ ctx[1]) return 0;
		if (/*divider*/ ctx[0]) return 1;
		if (/*href*/ ctx[2]) return 2;
		return 3;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			li = SvelteInternal.element("li");
			if_block.c();
		},
		m(target, anchor) {
			SvelteInternal.insert(target, li, anchor);
			if_blocks[current_block_type_index].m(li, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(li, null);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(li);
			}

			if_blocks[current_block_type_index].d();
		}
	};
}

function instance$V($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","active","disabled","divider","header","toggle","href"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let $context;
	let { $$slots: slots = {}, $$scope } = $$props;
	const context = SvelteInternal.getContext('dropdownContext');
	SvelteInternal.component_subscribe($$self, context, value => $$invalidate(15, $context = value));
	let { class: className = '' } = $$props;
	let { active = false } = $$props;
	let { disabled = false } = $$props;
	let { divider = false } = $$props;
	let { header = false } = $$props;
	let { toggle = true } = $$props;
	let { href = '' } = $$props;

	function handleItemClick(e) {
		if (disabled || header || divider) {
			e.preventDefault();
			return;
		}

		if (toggle && ($context.autoClose === true || $context.autoClose === 'inside')) {
			$context.toggle(e);
		}
	}

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ('active' in $$new_props) $$invalidate(8, active = $$new_props.active);
		if ('disabled' in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
		if ('divider' in $$new_props) $$invalidate(0, divider = $$new_props.divider);
		if ('header' in $$new_props) $$invalidate(1, header = $$new_props.header);
		if ('toggle' in $$new_props) $$invalidate(10, toggle = $$new_props.toggle);
		if ('href' in $$new_props) $$invalidate(2, href = $$new_props.href);
		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, disabled, divider, header, active*/ 899) {
			$$invalidate(3, classes = classnames(className, {
				disabled,
				'dropdown-item': !divider && !header,
				active,
				'dropdown-header': header,
				'dropdown-divider': divider
			}));
		}
	};

	return [
		divider,
		header,
		href,
		classes,
		context,
		handleItemClick,
		$$restProps,
		className,
		active,
		disabled,
		toggle,
		$$scope,
		slots,
		click_handler,
		click_handler_1
	];
}

class NodeModulesSveltestrapSveltestrapDistDropdownItemDropdownItemSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$V, create_fragment$V, SvelteInternal.safe_not_equal, {
			class: 7,
			active: 8,
			disabled: 9,
			divider: 0,
			header: 1,
			toggle: 10,
			href: 2
		});
	}

	get class() {
		return this.$$.ctx[7];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get active() {
		return this.$$.ctx[8];
	}

	set active(active) {
		this.$$set({ active });
		SvelteInternal.flush();
	}

	get disabled() {
		return this.$$.ctx[9];
	}

	set disabled(disabled) {
		this.$$set({ disabled });
		SvelteInternal.flush();
	}

	get divider() {
		return this.$$.ctx[0];
	}

	set divider(divider) {
		this.$$set({ divider });
		SvelteInternal.flush();
	}

	get header() {
		return this.$$.ctx[1];
	}

	set header(header) {
		this.$$set({ header });
		SvelteInternal.flush();
	}

	get toggle() {
		return this.$$.ctx[10];
	}

	set toggle(toggle) {
		this.$$set({ toggle });
		SvelteInternal.flush();
	}

	get href() {
		return this.$$.ctx[2];
	}

	set href(href) {
		this.$$set({ href });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistDropdownMenuDropdownMenuSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$U(ctx) {
	let ul;
	let ul_data_bs_popper_value;
	let $context_popperContent_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	let ul_levels = [
		/*$$restProps*/ ctx[4],
		{ class: /*classes*/ ctx[1] },
		{
			"data-bs-popper": ul_data_bs_popper_value = /*$context*/ ctx[0].inNavbar ? 'static' : undefined
		}
	];

	let ul_data = {};

	for (let i = 0; i < ul_levels.length; i += 1) {
		ul_data = SvelteInternal.assign(ul_data, ul_levels[i]);
	}

	return {
		c() {
			ul = SvelteInternal.element("ul");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(ul, ul_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;

			if (!mounted) {
				dispose = SvelteInternal.action_destroyer($context_popperContent_action = /*$context*/ ctx[0].popperContent(ul, /*popperOptions*/ ctx[2]));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(ul, ul_data = SvelteInternal.get_spread_update(ul_levels, [
				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*$context*/ 1 && ul_data_bs_popper_value !== (ul_data_bs_popper_value = /*$context*/ ctx[0].inNavbar ? 'static' : undefined)) && {
					"data-bs-popper": ul_data_bs_popper_value
				}
			]));

			if ($context_popperContent_action && SvelteInternal.is_function($context_popperContent_action.update) && dirty & /*popperOptions*/ 4) $context_popperContent_action.update.call(null, /*popperOptions*/ ctx[2]);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(ul);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$U($$self, $$props, $$invalidate) {
	let popperOptions;
	let classes;
	const omit_props_names = ["class","end","right"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let $context;
	let { $$slots: slots = {}, $$scope } = $$props;
	const context = SvelteInternal.getContext('dropdownContext');
	SvelteInternal.component_subscribe($$self, context, value => $$invalidate(0, $context = value));
	let { class: className = '' } = $$props;
	let { end = false } = $$props;
	let { right = false } = $$props;

	const popperPlacement = (direction, end) => {
		let prefix = direction;

		if (direction === 'up') {
			prefix = 'top';
		}

		if (direction === 'down') {
			prefix = 'bottom';
		}

		let suffix = end ? 'end' : 'start';
		return `${prefix}-${suffix}`;
	};

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('end' in $$new_props) $$invalidate(6, end = $$new_props.end);
		if ('right' in $$new_props) $$invalidate(7, right = $$new_props.right);
		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$context, end, right*/ 193) {
			$$invalidate(2, popperOptions = {
				modifiers: [
					{ name: 'flip' },
					{
						name: 'offset',
						options: { offset: [0, 2] }
					}
				],
				placement: popperPlacement($context.direction, end || right)
			});
		}

		if ($$self.$$.dirty & /*className, end, right, $context*/ 225) {
			$$invalidate(1, classes = classnames(className, 'dropdown-menu', {
				'dropdown-menu-end': end || right,
				show: $context.isOpen
			}));
		}
	};

	return [
		$context,
		classes,
		popperOptions,
		context,
		$$restProps,
		className,
		end,
		right,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistDropdownMenuDropdownMenuSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$U, create_fragment$U, SvelteInternal.safe_not_equal, { class: 5, end: 6, right: 7 });
	}

	get class() {
		return this.$$.ctx[5];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get end() {
		return this.$$.ctx[6];
	}

	set end(end) {
		this.$$set({ end });
		SvelteInternal.flush();
	}

	get right() {
		return this.$$.ctx[7];
	}

	set right(right) {
		this.$$set({ right });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistDropdownToggleDropdownToggleSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block$j(ctx) {
	let button;
	let button_aria_expanded_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[20].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
	const default_slot_or_fallback = default_slot || fallback_block_3(ctx);

	let button_levels = [
		/*$$restProps*/ ctx[9],
		{ type: "button" },
		{
			"aria-expanded": button_aria_expanded_value = /*$context*/ ctx[5].isOpen
		},
		{ class: /*btnClasses*/ ctx[6] }
	];

	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = SvelteInternal.assign(button_data, button_levels[i]);
	}

	return {
		c() {
			button = SvelteInternal.element("button");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			SvelteInternal.set_attributes(button, button_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, button, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(button, null);
			}

			if (button.autofocus) button.focus();
			/*button_binding*/ ctx[28](button);
			current = true;

			if (!mounted) {
				dispose = [
					SvelteInternal.action_destroyer(/*$context*/ ctx[5].popperRef(button)),
					SvelteInternal.listen(button, "click", /*click_handler_3*/ ctx[24]),
					SvelteInternal.listen(button, "click", /*toggleButton*/ ctx[8])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/ 2)) {
					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			SvelteInternal.set_attributes(button, button_data = SvelteInternal.get_spread_update(button_levels, [
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				{ type: "button" },
				(!current || dirty & /*$context*/ 32 && button_aria_expanded_value !== (button_aria_expanded_value = /*$context*/ ctx[5].isOpen)) && {
					"aria-expanded": button_aria_expanded_value
				},
				(!current || dirty & /*btnClasses*/ 64) && { class: /*btnClasses*/ ctx[6] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(button);
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			/*button_binding*/ ctx[28](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (82:25) 
function create_if_block_2$7(ctx) {
	let span;
	let span_aria_expanded_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[20].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
	const default_slot_or_fallback = default_slot || fallback_block_2(ctx);

	let span_levels = [
		/*$$restProps*/ ctx[9],
		{
			"aria-expanded": span_aria_expanded_value = /*$context*/ ctx[5].isOpen
		},
		{ class: /*classes*/ ctx[4] }
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = SvelteInternal.assign(span_data, span_levels[i]);
	}

	return {
		c() {
			span = SvelteInternal.element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			SvelteInternal.set_attributes(span, span_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, span, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			/*span_binding*/ ctx[27](span);
			current = true;

			if (!mounted) {
				dispose = [
					SvelteInternal.action_destroyer(/*$context*/ ctx[5].popperRef(span)),
					SvelteInternal.listen(span, "click", /*click_handler_2*/ ctx[23]),
					SvelteInternal.listen(span, "click", /*toggleButton*/ ctx[8])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/ 2)) {
					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			SvelteInternal.set_attributes(span, span_data = SvelteInternal.get_spread_update(span_levels, [
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				(!current || dirty & /*$context*/ 32 && span_aria_expanded_value !== (span_aria_expanded_value = /*$context*/ ctx[5].isOpen)) && {
					"aria-expanded": span_aria_expanded_value
				},
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(span);
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			/*span_binding*/ ctx[27](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (67:24) 
function create_if_block_1$e(ctx) {
	let div;
	let div_aria_expanded_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[20].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
	const default_slot_or_fallback = default_slot || fallback_block_1(ctx);

	let div_levels = [
		/*$$restProps*/ ctx[9],
		{
			"aria-expanded": div_aria_expanded_value = /*$context*/ ctx[5].isOpen
		},
		{ class: /*classes*/ ctx[4] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(div, null);
			}

			/*div_binding*/ ctx[26](div);
			current = true;

			if (!mounted) {
				dispose = [
					SvelteInternal.action_destroyer(/*$context*/ ctx[5].popperRef(div)),
					SvelteInternal.listen(div, "click", /*click_handler_1*/ ctx[22]),
					SvelteInternal.listen(div, "click", /*toggleButton*/ ctx[8])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/ 2)) {
					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				(!current || dirty & /*$context*/ 32 && div_aria_expanded_value !== (div_aria_expanded_value = /*$context*/ ctx[5].isOpen)) && { "aria-expanded": div_aria_expanded_value },
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			/*div_binding*/ ctx[26](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (52:0) {#if nav}
function create_if_block$o(ctx) {
	let a;
	let a_aria_expanded_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[20].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
	const default_slot_or_fallback = default_slot || fallback_block$8(ctx);

	let a_levels = [
		/*$$restProps*/ ctx[9],
		{ href: "#nav" },
		{
			"aria-expanded": a_aria_expanded_value = /*$context*/ ctx[5].isOpen
		},
		{ class: /*classes*/ ctx[4] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = SvelteInternal.assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = SvelteInternal.element("a");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			SvelteInternal.set_attributes(a, a_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, a, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(a, null);
			}

			/*a_binding*/ ctx[25](a);
			current = true;

			if (!mounted) {
				dispose = [
					SvelteInternal.action_destroyer(/*$context*/ ctx[5].popperRef(a)),
					SvelteInternal.listen(a, "click", /*click_handler*/ ctx[21]),
					SvelteInternal.listen(a, "click", /*toggleButton*/ ctx[8])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/ 2)) {
					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			SvelteInternal.set_attributes(a, a_data = SvelteInternal.get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				{ href: "#nav" },
				(!current || dirty & /*$context*/ 32 && a_aria_expanded_value !== (a_aria_expanded_value = /*$context*/ ctx[5].isOpen)) && { "aria-expanded": a_aria_expanded_value },
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(a);
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			/*a_binding*/ ctx[25](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (108:10)        
function fallback_block_3(ctx) {
	let span;
	let t;

	return {
		c() {
			span = SvelteInternal.element("span");
			t = SvelteInternal.text(/*ariaLabel*/ ctx[1]);
			SvelteInternal.attr(span, "class", "visually-hidden");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, span, anchor);
			SvelteInternal.append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*ariaLabel*/ 2) SvelteInternal.set_data(t, /*ariaLabel*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(span);
			}
		}
	};
}

// (93:10)        
function fallback_block_2(ctx) {
	let span;
	let t;

	return {
		c() {
			span = SvelteInternal.element("span");
			t = SvelteInternal.text(/*ariaLabel*/ ctx[1]);
			SvelteInternal.attr(span, "class", "visually-hidden");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, span, anchor);
			SvelteInternal.append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*ariaLabel*/ 2) SvelteInternal.set_data(t, /*ariaLabel*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(span);
			}
		}
	};
}

// (78:10)        
function fallback_block_1(ctx) {
	let span;
	let t;

	return {
		c() {
			span = SvelteInternal.element("span");
			t = SvelteInternal.text(/*ariaLabel*/ ctx[1]);
			SvelteInternal.attr(span, "class", "visually-hidden");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, span, anchor);
			SvelteInternal.append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*ariaLabel*/ 2) SvelteInternal.set_data(t, /*ariaLabel*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(span);
			}
		}
	};
}

// (63:10)        
function fallback_block$8(ctx) {
	let span;
	let t;

	return {
		c() {
			span = SvelteInternal.element("span");
			t = SvelteInternal.text(/*ariaLabel*/ ctx[1]);
			SvelteInternal.attr(span, "class", "visually-hidden");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, span, anchor);
			SvelteInternal.append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*ariaLabel*/ 2) SvelteInternal.set_data(t, /*ariaLabel*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(span);
			}
		}
	};
}

function create_fragment$T(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$o, create_if_block_1$e, create_if_block_2$7, create_else_block$j];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*nav*/ ctx[2]) return 0;
		if (/*tag*/ ctx[3] === 'div') return 1;
		if (/*tag*/ ctx[3] === 'span') return 2;
		return 3;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$T($$self, $$props, $$invalidate) {
	let classes;
	let btnClasses;

	const omit_props_names = [
		"class","ariaLabel","active","block","caret","color","disabled","inner","nav","outline","size","split","tag"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let $context;
	let { $$slots: slots = {}, $$scope } = $$props;
	const context = SvelteInternal.getContext('dropdownContext');
	SvelteInternal.component_subscribe($$self, context, value => $$invalidate(5, $context = value));
	let { class: className = '' } = $$props;
	let { ariaLabel = 'Toggle Dropdown' } = $$props;
	let { active = false } = $$props;
	let { block = false } = $$props;
	let { caret = false } = $$props;
	let { color = 'secondary' } = $$props;
	let { disabled = false } = $$props;
	let { inner = undefined } = $$props;
	let { nav = false } = $$props;
	let { outline = false } = $$props;
	let { size = '' } = $$props;
	let { split = false } = $$props;
	let { tag = null } = $$props;

	function toggleButton(e) {
		if (disabled) {
			e.preventDefault();
			return;
		}

		if (nav) {
			e.preventDefault();
		}

		$context.toggle(e);
	}

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function click_handler_2(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function click_handler_3(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function a_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(0, inner);
		});
	}

	function div_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(0, inner);
		});
	}

	function span_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(0, inner);
		});
	}

	function button_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(0, inner);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(10, className = $$new_props.class);
		if ('ariaLabel' in $$new_props) $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
		if ('active' in $$new_props) $$invalidate(11, active = $$new_props.active);
		if ('block' in $$new_props) $$invalidate(12, block = $$new_props.block);
		if ('caret' in $$new_props) $$invalidate(13, caret = $$new_props.caret);
		if ('color' in $$new_props) $$invalidate(14, color = $$new_props.color);
		if ('disabled' in $$new_props) $$invalidate(15, disabled = $$new_props.disabled);
		if ('inner' in $$new_props) $$invalidate(0, inner = $$new_props.inner);
		if ('nav' in $$new_props) $$invalidate(2, nav = $$new_props.nav);
		if ('outline' in $$new_props) $$invalidate(16, outline = $$new_props.outline);
		if ('size' in $$new_props) $$invalidate(17, size = $$new_props.size);
		if ('split' in $$new_props) $$invalidate(18, split = $$new_props.split);
		if ('tag' in $$new_props) $$invalidate(3, tag = $$new_props.tag);
		if ('$$scope' in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, caret, split, nav, $context*/ 271396) {
			$$invalidate(4, classes = classnames(className, {
				'dropdown-toggle': caret || split,
				'dropdown-toggle-split': split,
				'nav-link': nav,
				show: $context.isOpen
			}));
		}

		if ($$self.$$.dirty & /*classes, outline, color, size, block, active*/ 219152) {
			$$invalidate(6, btnClasses = classnames(classes, 'btn', `btn${outline ? '-outline' : ''}-${color}`, size ? `btn-${size}` : false, block ? 'd-block w-100' : false, { active }));
		}
	};

	return [
		inner,
		ariaLabel,
		nav,
		tag,
		classes,
		$context,
		btnClasses,
		context,
		toggleButton,
		$$restProps,
		className,
		active,
		block,
		caret,
		color,
		disabled,
		outline,
		size,
		split,
		$$scope,
		slots,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		a_binding,
		div_binding,
		span_binding,
		button_binding
	];
}

class NodeModulesSveltestrapSveltestrapDistDropdownToggleDropdownToggleSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$T, create_fragment$T, SvelteInternal.safe_not_equal, {
			class: 10,
			ariaLabel: 1,
			active: 11,
			block: 12,
			caret: 13,
			color: 14,
			disabled: 15,
			inner: 0,
			nav: 2,
			outline: 16,
			size: 17,
			split: 18,
			tag: 3
		});
	}

	get class() {
		return this.$$.ctx[10];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get ariaLabel() {
		return this.$$.ctx[1];
	}

	set ariaLabel(ariaLabel) {
		this.$$set({ ariaLabel });
		SvelteInternal.flush();
	}

	get active() {
		return this.$$.ctx[11];
	}

	set active(active) {
		this.$$set({ active });
		SvelteInternal.flush();
	}

	get block() {
		return this.$$.ctx[12];
	}

	set block(block) {
		this.$$set({ block });
		SvelteInternal.flush();
	}

	get caret() {
		return this.$$.ctx[13];
	}

	set caret(caret) {
		this.$$set({ caret });
		SvelteInternal.flush();
	}

	get color() {
		return this.$$.ctx[14];
	}

	set color(color) {
		this.$$set({ color });
		SvelteInternal.flush();
	}

	get disabled() {
		return this.$$.ctx[15];
	}

	set disabled(disabled) {
		this.$$set({ disabled });
		SvelteInternal.flush();
	}

	get inner() {
		return this.$$.ctx[0];
	}

	set inner(inner) {
		this.$$set({ inner });
		SvelteInternal.flush();
	}

	get nav() {
		return this.$$.ctx[2];
	}

	set nav(nav) {
		this.$$set({ nav });
		SvelteInternal.flush();
	}

	get outline() {
		return this.$$.ctx[16];
	}

	set outline(outline) {
		this.$$set({ outline });
		SvelteInternal.flush();
	}

	get size() {
		return this.$$.ctx[17];
	}

	set size(size) {
		this.$$set({ size });
		SvelteInternal.flush();
	}

	get split() {
		return this.$$.ctx[18];
	}

	set split(split) {
		this.$$set({ split });
		SvelteInternal.flush();
	}

	get tag() {
		return this.$$.ctx[3];
	}

	set tag(tag) {
		this.$$set({ tag });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistFadeFadeSvelte.svelte generated by Svelte v4.2.8 */


function create_if_block$n(ctx) {
	let div;
	let div_transition;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let div_levels = [/*$$restProps*/ ctx[6], { class: /*className*/ ctx[1] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(div, "introstart", /*introstart_handler*/ ctx[10]),
					SvelteInternal.listen(div, "introend", /*introend_handler*/ ctx[11]),
					SvelteInternal.listen(div, "outrostart", /*outrostart_handler*/ ctx[12]),
					SvelteInternal.listen(div, "outroend", /*outroend_handler*/ ctx[13]),
					SvelteInternal.listen(div, "introstart", function () {
						if (SvelteInternal.is_function(/*onEntering*/ ctx[2])) /*onEntering*/ ctx[2].apply(this, arguments);
					}),
					SvelteInternal.listen(div, "introend", function () {
						if (SvelteInternal.is_function(/*onEntered*/ ctx[3])) /*onEntered*/ ctx[3].apply(this, arguments);
					}),
					SvelteInternal.listen(div, "outrostart", function () {
						if (SvelteInternal.is_function(/*onExiting*/ ctx[4])) /*onExiting*/ ctx[4].apply(this, arguments);
					}),
					SvelteInternal.listen(div, "outroend", function () {
						if (SvelteInternal.is_function(/*onExited*/ ctx[5])) /*onExited*/ ctx[5].apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
				(!current || dirty & /*className*/ 2) && { class: /*className*/ ctx[1] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);

			if (local) {
				SvelteInternal.add_render_callback(() => {
					if (!current) return;
					if (!div_transition) div_transition = SvelteInternal.create_bidirectional_transition(div, SvelteTransition.fade, {}, true);
					div_transition.run(1);
				});
			}

			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);

			if (local) {
				if (!div_transition) div_transition = SvelteInternal.create_bidirectional_transition(div, SvelteTransition.fade, {}, false);
				div_transition.run(0);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
			if (detaching && div_transition) div_transition.end();
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

function create_fragment$S(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*isOpen*/ ctx[0] && create_if_block$n(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						SvelteInternal.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$n(ctx);
					if_block.c();
					SvelteInternal.transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				SvelteInternal.check_outros();
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function instance$S($$self, $$props, $$invalidate) {
	const omit_props_names = ["isOpen","class","onEntering","onEntered","onExiting","onExited","toggler"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = SvelteInternal.createEventDispatcher();
	let { isOpen = false } = $$props;
	let { class: className = '' } = $$props;
	let { onEntering = () => dispatch('opening') } = $$props;
	let { onEntered = () => dispatch('open') } = $$props;
	let { onExiting = () => dispatch('closing') } = $$props;
	let { onExited = () => dispatch('close') } = $$props;
	let { toggler = null } = $$props;

	SvelteInternal.onMount(() => toggle(toggler, e => {
		$$invalidate(0, isOpen = !isOpen);
		e.preventDefault();
	}));

	function introstart_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function introend_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function outrostart_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function outroend_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ('onEntering' in $$new_props) $$invalidate(2, onEntering = $$new_props.onEntering);
		if ('onEntered' in $$new_props) $$invalidate(3, onEntered = $$new_props.onEntered);
		if ('onExiting' in $$new_props) $$invalidate(4, onExiting = $$new_props.onExiting);
		if ('onExited' in $$new_props) $$invalidate(5, onExited = $$new_props.onExited);
		if ('toggler' in $$new_props) $$invalidate(7, toggler = $$new_props.toggler);
		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	return [
		isOpen,
		className,
		onEntering,
		onEntered,
		onExiting,
		onExited,
		$$restProps,
		toggler,
		$$scope,
		slots,
		introstart_handler,
		introend_handler,
		outrostart_handler,
		outroend_handler
	];
}

class NodeModulesSveltestrapSveltestrapDistFadeFadeSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$S, create_fragment$S, SvelteInternal.safe_not_equal, {
			isOpen: 0,
			class: 1,
			onEntering: 2,
			onEntered: 3,
			onExiting: 4,
			onExited: 5,
			toggler: 7
		});
	}

	get isOpen() {
		return this.$$.ctx[0];
	}

	set isOpen(isOpen) {
		this.$$set({ isOpen });
		SvelteInternal.flush();
	}

	get class() {
		return this.$$.ctx[1];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get onEntering() {
		return this.$$.ctx[2];
	}

	set onEntering(onEntering) {
		this.$$set({ onEntering });
		SvelteInternal.flush();
	}

	get onEntered() {
		return this.$$.ctx[3];
	}

	set onEntered(onEntered) {
		this.$$set({ onEntered });
		SvelteInternal.flush();
	}

	get onExiting() {
		return this.$$.ctx[4];
	}

	set onExiting(onExiting) {
		this.$$set({ onExiting });
		SvelteInternal.flush();
	}

	get onExited() {
		return this.$$.ctx[5];
	}

	set onExited(onExited) {
		this.$$set({ onExited });
		SvelteInternal.flush();
	}

	get toggler() {
		return this.$$.ctx[7];
	}

	set toggler(toggler) {
		this.$$set({ toggler });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistFigureFigureSvelte.svelte generated by Svelte v4.2.8 */

const get_caption_slot_changes = dirty => ({});
const get_caption_slot_context = ctx => ({});

// (36:2) {#if caption || $$slots.caption}
function create_if_block$m(ctx) {
	let figcaption;
	let t;
	let current;
	const caption_slot_template = /*#slots*/ ctx[7].caption;
	const caption_slot = SvelteInternal.create_slot(caption_slot_template, ctx, /*$$scope*/ ctx[6], get_caption_slot_context);

	return {
		c() {
			figcaption = SvelteInternal.element("figcaption");
			t = SvelteInternal.text(/*caption*/ ctx[1]);
			if (caption_slot) caption_slot.c();
			SvelteInternal.attr(figcaption, "class", "figure-caption");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, figcaption, anchor);
			SvelteInternal.append(figcaption, t);

			if (caption_slot) {
				caption_slot.m(figcaption, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*caption*/ 2) SvelteInternal.set_data(t, /*caption*/ ctx[1]);

			if (caption_slot) {
				if (caption_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					SvelteInternal.update_slot_base(
						caption_slot,
						caption_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: SvelteInternal.get_slot_changes(caption_slot_template, /*$$scope*/ ctx[6], dirty, get_caption_slot_changes),
						get_caption_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(caption_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(caption_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(figcaption);
			}

			if (caption_slot) caption_slot.d(detaching);
		}
	};
}

function create_fragment$R(ctx) {
	let img;
	let t0;
	let figure;
	let t1;
	let current;
	let img_levels = [{ alt: /*alt*/ ctx[0] }, /*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
	let img_data = {};

	for (let i = 0; i < img_levels.length; i += 1) {
		img_data = SvelteInternal.assign(img_data, img_levels[i]);
	}

	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let if_block = (/*caption*/ ctx[1] || /*$$slots*/ ctx[4].caption) && create_if_block$m(ctx);
	let figure_levels = [{ class: /*classes*/ ctx[2] }, /*$$restProps*/ ctx[3]];
	let figure_data = {};

	for (let i = 0; i < figure_levels.length; i += 1) {
		figure_data = SvelteInternal.assign(figure_data, figure_levels[i]);
	}

	return {
		c() {
			img = SvelteInternal.element("img");
			t0 = SvelteInternal.space();
			figure = SvelteInternal.element("figure");
			if (default_slot) default_slot.c();
			t1 = SvelteInternal.space();
			if (if_block) if_block.c();
			SvelteInternal.set_attributes(img, img_data);
			SvelteInternal.set_attributes(figure, figure_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, img, anchor);
			SvelteInternal.insert(target, t0, anchor);
			SvelteInternal.insert(target, figure, anchor);

			if (default_slot) {
				default_slot.m(figure, null);
			}

			SvelteInternal.append(figure, t1);
			if (if_block) if_block.m(figure, null);
			current = true;
		},
		p(ctx, [dirty]) {
			SvelteInternal.set_attributes(img, img_data = SvelteInternal.get_spread_update(img_levels, [
				(!current || dirty & /*alt*/ 1) && { alt: /*alt*/ ctx[0] },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
			]));

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}

			if (/*caption*/ ctx[1] || /*$$slots*/ ctx[4].caption) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*caption, $$slots*/ 18) {
						SvelteInternal.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$m(ctx);
					if_block.c();
					SvelteInternal.transition_in(if_block, 1);
					if_block.m(figure, null);
				}
			} else if (if_block) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				SvelteInternal.check_outros();
			}

			SvelteInternal.set_attributes(figure, figure_data = SvelteInternal.get_spread_update(figure_levels, [
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(img);
				SvelteInternal.detach(t0);
				SvelteInternal.detach(figure);
			}

			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
		}
	};
}

function instance$R($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","alt","caption"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = SvelteInternal.compute_slots(slots);
	SvelteInternal.setContext('figure', true);
	let { class: className = '' } = $$props;
	let { alt = undefined } = $$props;
	let { caption = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('alt' in $$new_props) $$invalidate(0, alt = $$new_props.alt);
		if ('caption' in $$new_props) $$invalidate(1, caption = $$new_props.caption);
		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 32) {
			$$invalidate(2, classes = classnames('figure', className));
		}
	};

	return [alt, caption, classes, $$restProps, $$slots, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistFigureFigureSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$R, create_fragment$R, SvelteInternal.safe_not_equal, { class: 5, alt: 0, caption: 1 });
	}

	get class() {
		return this.$$.ctx[5];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get alt() {
		return this.$$.ctx[0];
	}

	set alt(alt) {
		this.$$set({ alt });
		SvelteInternal.flush();
	}

	get caption() {
		return this.$$.ctx[1];
	}

	set caption(caption) {
		this.$$set({ caption });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistFormFormSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$Q(ctx) {
	let form;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let form_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let form_data = {};

	for (let i = 0; i < form_levels.length; i += 1) {
		form_data = SvelteInternal.assign(form_data, form_levels[i]);
	}

	return {
		c() {
			form = SvelteInternal.element("form");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(form, form_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, form, anchor);

			if (default_slot) {
				default_slot.m(form, null);
			}

			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(form, "submit", /*submit_handler*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(form, form_data = SvelteInternal.get_spread_update(form_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(form);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$Q($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","inline","validated"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { inline = false } = $$props;
	let { validated = false } = $$props;

	function submit_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('inline' in $$new_props) $$invalidate(3, inline = $$new_props.inline);
		if ('validated' in $$new_props) $$invalidate(4, validated = $$new_props.validated);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, inline, validated*/ 28) {
			$$invalidate(0, classes = classnames(className, {
				'form-inline': inline,
				'was-validated': validated
			}));
		}
	};

	return [
		classes,
		$$restProps,
		className,
		inline,
		validated,
		$$scope,
		slots,
		submit_handler
	];
}

class NodeModulesSveltestrapSveltestrapDistFormFormSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$Q, create_fragment$Q, SvelteInternal.safe_not_equal, { class: 2, inline: 3, validated: 4 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get inline() {
		return this.$$.ctx[3];
	}

	set inline(inline) {
		this.$$set({ inline });
		SvelteInternal.flush();
	}

	get validated() {
		return this.$$.ctx[4];
	}

	set validated(validated) {
		this.$$set({ validated });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistFormCheckFormCheckSvelte.svelte generated by Svelte v4.2.8 */

const get_label_slot_changes$1 = dirty => ({});
const get_label_slot_context$1 = ctx => ({});

// (68:2) {:else}
function create_else_block$i(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[11],
		{ class: /*inputClasses*/ ctx[9] },
		{ id: /*idFor*/ ctx[8] },
		{ type: "checkbox" },
		{ disabled: /*disabled*/ ctx[3] },
		{ name: /*name*/ ctx[5] },
		{ __value: /*value*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			input.checked = /*checked*/ ctx[0];
			/*input_binding_2*/ ctx[39](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "change", /*input_change_handler_2*/ ctx[38]),
					SvelteInternal.listen(input, "blur", /*blur_handler_2*/ ctx[29]),
					SvelteInternal.listen(input, "change", /*change_handler_2*/ ctx[30]),
					SvelteInternal.listen(input, "focus", /*focus_handler_2*/ ctx[31]),
					SvelteInternal.listen(input, "input", /*input_handler_2*/ ctx[32])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 2048 && /*$$restProps*/ ctx[11],
				dirty[0] & /*inputClasses*/ 512 && { class: /*inputClasses*/ ctx[9] },
				dirty[0] & /*idFor*/ 256 && { id: /*idFor*/ ctx[8] },
				{ type: "checkbox" },
				dirty[0] & /*disabled*/ 8 && { disabled: /*disabled*/ ctx[3] },
				dirty[0] & /*name*/ 32 && { name: /*name*/ ctx[5] },
				dirty[0] & /*value*/ 128 && { __value: /*value*/ ctx[7] }
			]));

			if (dirty[0] & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_2*/ ctx[39](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (52:30) 
function create_if_block_2$6(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[11],
		{ class: /*inputClasses*/ ctx[9] },
		{ id: /*idFor*/ ctx[8] },
		{ type: "checkbox" },
		{ disabled: /*disabled*/ ctx[3] },
		{ name: /*name*/ ctx[5] },
		{ __value: /*value*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			input.checked = /*checked*/ ctx[0];
			/*input_binding_1*/ ctx[37](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "change", /*input_change_handler_1*/ ctx[36]),
					SvelteInternal.listen(input, "blur", /*blur_handler_1*/ ctx[25]),
					SvelteInternal.listen(input, "change", /*change_handler_1*/ ctx[26]),
					SvelteInternal.listen(input, "focus", /*focus_handler_1*/ ctx[27]),
					SvelteInternal.listen(input, "input", /*input_handler_1*/ ctx[28])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 2048 && /*$$restProps*/ ctx[11],
				dirty[0] & /*inputClasses*/ 512 && { class: /*inputClasses*/ ctx[9] },
				dirty[0] & /*idFor*/ 256 && { id: /*idFor*/ ctx[8] },
				{ type: "checkbox" },
				dirty[0] & /*disabled*/ 8 && { disabled: /*disabled*/ ctx[3] },
				dirty[0] & /*name*/ 32 && { name: /*name*/ ctx[5] },
				dirty[0] & /*value*/ 128 && { __value: /*value*/ ctx[7] }
			]));

			if (dirty[0] & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_1*/ ctx[37](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (36:2) {#if type === 'radio'}
function create_if_block_1$d(ctx) {
	let input;
	let binding_group;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[11],
		{ class: /*inputClasses*/ ctx[9] },
		{ id: /*idFor*/ ctx[8] },
		{ type: "radio" },
		{ disabled: /*disabled*/ ctx[3] },
		{ name: /*name*/ ctx[5] },
		{ __value: /*value*/ ctx[7] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	binding_group = SvelteInternal.init_binding_group(/*$$binding_groups*/ ctx[34][0]);

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
			binding_group.p(input);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			input.checked = input.__value === /*group*/ ctx[1];
			/*input_binding*/ ctx[35](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "change", /*input_change_handler*/ ctx[33]),
					SvelteInternal.listen(input, "blur", /*blur_handler*/ ctx[21]),
					SvelteInternal.listen(input, "change", /*change_handler*/ ctx[22]),
					SvelteInternal.listen(input, "focus", /*focus_handler*/ ctx[23]),
					SvelteInternal.listen(input, "input", /*input_handler*/ ctx[24])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 2048 && /*$$restProps*/ ctx[11],
				dirty[0] & /*inputClasses*/ 512 && { class: /*inputClasses*/ ctx[9] },
				dirty[0] & /*idFor*/ 256 && { id: /*idFor*/ ctx[8] },
				{ type: "radio" },
				dirty[0] & /*disabled*/ 8 && { disabled: /*disabled*/ ctx[3] },
				dirty[0] & /*name*/ 32 && { name: /*name*/ ctx[5] },
				dirty[0] & /*value*/ 128 && { __value: /*value*/ ctx[7] }
			]));

			if (dirty[0] & /*group*/ 2) {
				input.checked = input.__value === /*group*/ ctx[1];
			}
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding*/ ctx[35](null);
			binding_group.r();
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (85:2) {#if label}
function create_if_block$l(ctx) {
	let label_1;
	let current;
	const label_slot_template = /*#slots*/ ctx[20].label;
	const label_slot = SvelteInternal.create_slot(label_slot_template, ctx, /*$$scope*/ ctx[19], get_label_slot_context$1);
	const label_slot_or_fallback = label_slot || fallback_block$7(ctx);

	return {
		c() {
			label_1 = SvelteInternal.element("label");
			if (label_slot_or_fallback) label_slot_or_fallback.c();
			SvelteInternal.attr(label_1, "class", "form-check-label");
			SvelteInternal.attr(label_1, "for", /*idFor*/ ctx[8]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, label_1, anchor);

			if (label_slot_or_fallback) {
				label_slot_or_fallback.m(label_1, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (label_slot) {
				if (label_slot.p && (!current || dirty[0] & /*$$scope*/ 524288)) {
					SvelteInternal.update_slot_base(
						label_slot,
						label_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: SvelteInternal.get_slot_changes(label_slot_template, /*$$scope*/ ctx[19], dirty, get_label_slot_changes$1),
						get_label_slot_context$1
					);
				}
			} else {
				if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty[0] & /*label*/ 16)) {
					label_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
				}
			}

			if (!current || dirty[0] & /*idFor*/ 256) {
				SvelteInternal.attr(label_1, "for", /*idFor*/ ctx[8]);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(label_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(label_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(label_1);
			}

			if (label_slot_or_fallback) label_slot_or_fallback.d(detaching);
		}
	};
}

// (87:25) {label}
function fallback_block$7(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*label*/ ctx[4]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*label*/ 16) SvelteInternal.set_data(t, /*label*/ ctx[4]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

function create_fragment$P(ctx) {
	let div;
	let t;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[6] === 'radio') return create_if_block_1$d;
		if (/*type*/ ctx[6] === 'switch') return create_if_block_2$6;
		return create_else_block$i;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*label*/ ctx[4] && create_if_block$l(ctx);

	return {
		c() {
			div = SvelteInternal.element("div");
			if_block0.c();
			t = SvelteInternal.space();
			if (if_block1) if_block1.c();
			SvelteInternal.attr(div, "class", /*classes*/ ctx[10]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			if_block0.m(div, null);
			SvelteInternal.append(div, t);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div, t);
				}
			}

			if (/*label*/ ctx[4]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*label*/ 16) {
						SvelteInternal.transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$l(ctx);
					if_block1.c();
					SvelteInternal.transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				SvelteInternal.check_outros();
			}

			if (!current || dirty[0] & /*classes*/ 1024) {
				SvelteInternal.attr(div, "class", /*classes*/ ctx[10]);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block1);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

function instance$P($$self, $$props, $$invalidate) {
	let classes;
	let inputClasses;
	let idFor;

	const omit_props_names = [
		"class","checked","disabled","group","id","inline","inner","invalid","label","name","reverse","size","type","valid","value"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { checked = false } = $$props;
	let { disabled = false } = $$props;
	let { group = undefined } = $$props;
	let { id = undefined } = $$props;
	let { inline = false } = $$props;
	let { inner = undefined } = $$props;
	let { invalid = false } = $$props;
	let { label = '' } = $$props;
	let { name = '' } = $$props;
	let { reverse = false } = $$props;
	let { size = '' } = $$props;
	let { type = 'checkbox' } = $$props;
	let { valid = false } = $$props;
	let { value = undefined } = $$props;
	const $$binding_groups = [[]];

	function blur_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_2(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_2(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_2(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_2(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_change_handler() {
		group = this.__value;
		$$invalidate(1, group);
	}

	function input_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(2, inner);
		});
	}

	function input_change_handler_1() {
		checked = this.checked;
		$$invalidate(0, checked);
	}

	function input_binding_1($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(2, inner);
		});
	}

	function input_change_handler_2() {
		checked = this.checked;
		$$invalidate(0, checked);
	}

	function input_binding_2($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(2, inner);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(11, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(12, className = $$new_props.class);
		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ('disabled' in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
		if ('group' in $$new_props) $$invalidate(1, group = $$new_props.group);
		if ('id' in $$new_props) $$invalidate(13, id = $$new_props.id);
		if ('inline' in $$new_props) $$invalidate(14, inline = $$new_props.inline);
		if ('inner' in $$new_props) $$invalidate(2, inner = $$new_props.inner);
		if ('invalid' in $$new_props) $$invalidate(15, invalid = $$new_props.invalid);
		if ('label' in $$new_props) $$invalidate(4, label = $$new_props.label);
		if ('name' in $$new_props) $$invalidate(5, name = $$new_props.name);
		if ('reverse' in $$new_props) $$invalidate(16, reverse = $$new_props.reverse);
		if ('size' in $$new_props) $$invalidate(17, size = $$new_props.size);
		if ('type' in $$new_props) $$invalidate(6, type = $$new_props.type);
		if ('valid' in $$new_props) $$invalidate(18, valid = $$new_props.valid);
		if ('value' in $$new_props) $$invalidate(7, value = $$new_props.value);
		if ('$$scope' in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*className, reverse, type, inline, size*/ 217152) {
			$$invalidate(10, classes = classnames(className, 'form-check', {
				'form-check-reverse': reverse,
				'form-switch': type === 'switch',
				'form-check-inline': inline,
				[`form-control-${size}`]: size
			}));
		}

		if ($$self.$$.dirty[0] & /*invalid, valid*/ 294912) {
			$$invalidate(9, inputClasses = classnames('form-check-input', { 'is-invalid': invalid, 'is-valid': valid }));
		}

		if ($$self.$$.dirty[0] & /*id, label*/ 8208) {
			$$invalidate(8, idFor = id || label);
		}
	};

	return [
		checked,
		group,
		inner,
		disabled,
		label,
		name,
		type,
		value,
		idFor,
		inputClasses,
		classes,
		$$restProps,
		className,
		id,
		inline,
		invalid,
		reverse,
		size,
		valid,
		$$scope,
		slots,
		blur_handler,
		change_handler,
		focus_handler,
		input_handler,
		blur_handler_1,
		change_handler_1,
		focus_handler_1,
		input_handler_1,
		blur_handler_2,
		change_handler_2,
		focus_handler_2,
		input_handler_2,
		input_change_handler,
		$$binding_groups,
		input_binding,
		input_change_handler_1,
		input_binding_1,
		input_change_handler_2,
		input_binding_2
	];
}

class NodeModulesSveltestrapSveltestrapDistFormCheckFormCheckSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(
			this,
			options,
			instance$P,
			create_fragment$P,
			SvelteInternal.safe_not_equal,
			{
				class: 12,
				checked: 0,
				disabled: 3,
				group: 1,
				id: 13,
				inline: 14,
				inner: 2,
				invalid: 15,
				label: 4,
				name: 5,
				reverse: 16,
				size: 17,
				type: 6,
				valid: 18,
				value: 7
			},
			null,
			[-1, -1]
		);
	}

	get class() {
		return this.$$.ctx[12];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get checked() {
		return this.$$.ctx[0];
	}

	set checked(checked) {
		this.$$set({ checked });
		SvelteInternal.flush();
	}

	get disabled() {
		return this.$$.ctx[3];
	}

	set disabled(disabled) {
		this.$$set({ disabled });
		SvelteInternal.flush();
	}

	get group() {
		return this.$$.ctx[1];
	}

	set group(group) {
		this.$$set({ group });
		SvelteInternal.flush();
	}

	get id() {
		return this.$$.ctx[13];
	}

	set id(id) {
		this.$$set({ id });
		SvelteInternal.flush();
	}

	get inline() {
		return this.$$.ctx[14];
	}

	set inline(inline) {
		this.$$set({ inline });
		SvelteInternal.flush();
	}

	get inner() {
		return this.$$.ctx[2];
	}

	set inner(inner) {
		this.$$set({ inner });
		SvelteInternal.flush();
	}

	get invalid() {
		return this.$$.ctx[15];
	}

	set invalid(invalid) {
		this.$$set({ invalid });
		SvelteInternal.flush();
	}

	get label() {
		return this.$$.ctx[4];
	}

	set label(label) {
		this.$$set({ label });
		SvelteInternal.flush();
	}

	get name() {
		return this.$$.ctx[5];
	}

	set name(name) {
		this.$$set({ name });
		SvelteInternal.flush();
	}

	get reverse() {
		return this.$$.ctx[16];
	}

	set reverse(reverse) {
		this.$$set({ reverse });
		SvelteInternal.flush();
	}

	get size() {
		return this.$$.ctx[17];
	}

	set size(size) {
		this.$$set({ size });
		SvelteInternal.flush();
	}

	get type() {
		return this.$$.ctx[6];
	}

	set type(type) {
		this.$$set({ type });
		SvelteInternal.flush();
	}

	get valid() {
		return this.$$.ctx[18];
	}

	set valid(valid) {
		this.$$set({ valid });
		SvelteInternal.flush();
	}

	get value() {
		return this.$$.ctx[7];
	}

	set value(value) {
		this.$$set({ value });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistFormFeedbackFormFeedbackSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$O(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$O($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","valid","tooltip"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { valid = undefined } = $$props;
	let { tooltip = false } = $$props;
	let classes;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('valid' in $$new_props) $$invalidate(3, valid = $$new_props.valid);
		if ('tooltip' in $$new_props) $$invalidate(4, tooltip = $$new_props.tooltip);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*tooltip, className, valid*/ 28) {
			{
				const validMode = tooltip ? 'tooltip' : 'feedback';
				$$invalidate(0, classes = classnames(className, valid ? `valid-${validMode}` : `invalid-${validMode}`));
			}
		}
	};

	return [classes, $$restProps, className, valid, tooltip, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistFormFeedbackFormFeedbackSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$O, create_fragment$O, SvelteInternal.safe_not_equal, { class: 2, valid: 3, tooltip: 4 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get valid() {
		return this.$$.ctx[3];
	}

	set valid(valid) {
		this.$$set({ valid });
		SvelteInternal.flush();
	}

	get tooltip() {
		return this.$$.ctx[4];
	}

	set tooltip(tooltip) {
		this.$$set({ tooltip });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistFormGroupFormGroupSvelte.svelte generated by Svelte v4.2.8 */

const get_label_slot_changes_1 = dirty => ({});
const get_label_slot_context_1 = ctx => ({});
const get_label_slot_changes = dirty => ({});
const get_label_slot_context = ctx => ({});

// (79:0) {:else}
function create_else_block$h(ctx) {
	let div;
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	let if_block = (/*label*/ ctx[0] || /*$$slots*/ ctx[4].label) && create_if_block_2$5(ctx);
	let div_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			t = SvelteInternal.space();
			if (if_block) if_block.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			SvelteInternal.append(div, t);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			if (/*label*/ ctx[0] || /*$$slots*/ ctx[4].label) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label, $$slots*/ 17) {
						SvelteInternal.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$5(ctx);
					if_block.c();
					SvelteInternal.transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				SvelteInternal.check_outros();
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
		}
	};
}

// (68:0) {#if tag === 'fieldset'}
function create_if_block$k(ctx) {
	let fieldset;
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	let if_block = (/*label*/ ctx[0] || /*$$slots*/ ctx[4].label) && create_if_block_1$c(ctx);
	let fieldset_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
	let fieldset_data = {};

	for (let i = 0; i < fieldset_levels.length; i += 1) {
		fieldset_data = SvelteInternal.assign(fieldset_data, fieldset_levels[i]);
	}

	return {
		c() {
			fieldset = SvelteInternal.element("fieldset");
			if (default_slot) default_slot.c();
			t = SvelteInternal.space();
			if (if_block) if_block.c();
			SvelteInternal.set_attributes(fieldset, fieldset_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, fieldset, anchor);

			if (default_slot) {
				default_slot.m(fieldset, null);
			}

			SvelteInternal.append(fieldset, t);
			if (if_block) if_block.m(fieldset, null);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			if (/*label*/ ctx[0] || /*$$slots*/ ctx[4].label) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label, $$slots*/ 17) {
						SvelteInternal.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$c(ctx);
					if_block.c();
					SvelteInternal.transition_in(if_block, 1);
					if_block.m(fieldset, null);
				}
			} else if (if_block) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				SvelteInternal.check_outros();
			}

			SvelteInternal.set_attributes(fieldset, fieldset_data = SvelteInternal.get_spread_update(fieldset_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(fieldset);
			}

			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
		}
	};
}

// (82:4) {#if label || $$slots.label}
function create_if_block_2$5(ctx) {
	let label_1;
	let t0;
	let t1;
	let current;
	const label_slot_template = /*#slots*/ ctx[13].label;
	const label_slot = SvelteInternal.create_slot(label_slot_template, ctx, /*$$scope*/ ctx[12], get_label_slot_context_1);

	return {
		c() {
			label_1 = SvelteInternal.element("label");
			t0 = SvelteInternal.text(/*label*/ ctx[0]);
			t1 = SvelteInternal.space();
			if (label_slot) label_slot.c();
		},
		m(target, anchor) {
			SvelteInternal.insert(target, label_1, anchor);
			SvelteInternal.append(label_1, t0);
			SvelteInternal.append(label_1, t1);

			if (label_slot) {
				label_slot.m(label_1, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*label*/ 1) SvelteInternal.set_data(t0, /*label*/ ctx[0]);

			if (label_slot) {
				if (label_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					SvelteInternal.update_slot_base(
						label_slot,
						label_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: SvelteInternal.get_slot_changes(label_slot_template, /*$$scope*/ ctx[12], dirty, get_label_slot_changes_1),
						get_label_slot_context_1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(label_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(label_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(label_1);
			}

			if (label_slot) label_slot.d(detaching);
		}
	};
}

// (71:4) {#if label || $$slots.label}
function create_if_block_1$c(ctx) {
	let label_1;
	let t0;
	let t1;
	let current;
	const label_slot_template = /*#slots*/ ctx[13].label;
	const label_slot = SvelteInternal.create_slot(label_slot_template, ctx, /*$$scope*/ ctx[12], get_label_slot_context);

	return {
		c() {
			label_1 = SvelteInternal.element("label");
			t0 = SvelteInternal.text(/*label*/ ctx[0]);
			t1 = SvelteInternal.space();
			if (label_slot) label_slot.c();
		},
		m(target, anchor) {
			SvelteInternal.insert(target, label_1, anchor);
			SvelteInternal.append(label_1, t0);
			SvelteInternal.append(label_1, t1);

			if (label_slot) {
				label_slot.m(label_1, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*label*/ 1) SvelteInternal.set_data(t0, /*label*/ ctx[0]);

			if (label_slot) {
				if (label_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					SvelteInternal.update_slot_base(
						label_slot,
						label_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: SvelteInternal.get_slot_changes(label_slot_template, /*$$scope*/ ctx[12], dirty, get_label_slot_changes),
						get_label_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(label_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(label_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(label_1);
			}

			if (label_slot) label_slot.d(detaching);
		}
	};
}

function create_fragment$N(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$k, create_else_block$h];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[1] === 'fieldset') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$N($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","check","disabled","floating","inline","label","row","spacing","tag"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = SvelteInternal.compute_slots(slots);
	let { class: className = '' } = $$props;
	let { check = false } = $$props;
	let { disabled = false } = $$props;
	let { floating = false } = $$props;
	let { inline = false } = $$props;
	let { label = '' } = $$props;
	let { row = false } = $$props;
	let { spacing = 'mb-3' } = $$props;
	let { tag = null } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('check' in $$new_props) $$invalidate(6, check = $$new_props.check);
		if ('disabled' in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
		if ('floating' in $$new_props) $$invalidate(8, floating = $$new_props.floating);
		if ('inline' in $$new_props) $$invalidate(9, inline = $$new_props.inline);
		if ('label' in $$new_props) $$invalidate(0, label = $$new_props.label);
		if ('row' in $$new_props) $$invalidate(10, row = $$new_props.row);
		if ('spacing' in $$new_props) $$invalidate(11, spacing = $$new_props.spacing);
		if ('tag' in $$new_props) $$invalidate(1, tag = $$new_props.tag);
		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, spacing, row, check, inline, floating, disabled*/ 4064) {
			$$invalidate(2, classes = classnames(className, spacing, {
				row,
				'form-check': check,
				'form-check-inline': check && inline,
				'form-floating': floating,
				disabled: check && disabled
			}));
		}
	};

	return [
		label,
		tag,
		classes,
		$$restProps,
		$$slots,
		className,
		check,
		disabled,
		floating,
		inline,
		row,
		spacing,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistFormGroupFormGroupSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$N, create_fragment$N, SvelteInternal.safe_not_equal, {
			class: 5,
			check: 6,
			disabled: 7,
			floating: 8,
			inline: 9,
			label: 0,
			row: 10,
			spacing: 11,
			tag: 1
		});
	}

	get class() {
		return this.$$.ctx[5];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get check() {
		return this.$$.ctx[6];
	}

	set check(check) {
		this.$$set({ check });
		SvelteInternal.flush();
	}

	get disabled() {
		return this.$$.ctx[7];
	}

	set disabled(disabled) {
		this.$$set({ disabled });
		SvelteInternal.flush();
	}

	get floating() {
		return this.$$.ctx[8];
	}

	set floating(floating) {
		this.$$set({ floating });
		SvelteInternal.flush();
	}

	get inline() {
		return this.$$.ctx[9];
	}

	set inline(inline) {
		this.$$set({ inline });
		SvelteInternal.flush();
	}

	get label() {
		return this.$$.ctx[0];
	}

	set label(label) {
		this.$$set({ label });
		SvelteInternal.flush();
	}

	get row() {
		return this.$$.ctx[10];
	}

	set row(row) {
		this.$$set({ row });
		SvelteInternal.flush();
	}

	get spacing() {
		return this.$$.ctx[11];
	}

	set spacing(spacing) {
		this.$$set({ spacing });
		SvelteInternal.flush();
	}

	get tag() {
		return this.$$.ctx[1];
	}

	set tag(tag) {
		this.$$set({ tag });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistFormTextFormTextSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$M(ctx) {
	let small;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let small_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let small_data = {};

	for (let i = 0; i < small_levels.length; i += 1) {
		small_data = SvelteInternal.assign(small_data, small_levels[i]);
	}

	return {
		c() {
			small = SvelteInternal.element("small");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(small, small_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, small, anchor);

			if (default_slot) {
				default_slot.m(small, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(small, small_data = SvelteInternal.get_spread_update(small_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(small);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$M($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","inline","color"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { inline = false } = $$props;
	let { color = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('inline' in $$new_props) $$invalidate(3, inline = $$new_props.inline);
		if ('color' in $$new_props) $$invalidate(4, color = $$new_props.color);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, inline, color*/ 28) {
			$$invalidate(0, classes = classnames(className, !inline ? 'form-text' : false, color ? `text-${color}` : false));
		}
	};

	return [classes, $$restProps, className, inline, color, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistFormTextFormTextSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$M, create_fragment$M, SvelteInternal.safe_not_equal, { class: 2, inline: 3, color: 4 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get inline() {
		return this.$$.ctx[3];
	}

	set inline(inline) {
		this.$$set({ inline });
		SvelteInternal.flush();
	}

	get color() {
		return this.$$.ctx[4];
	}

	set color(color) {
		this.$$set({ color });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistIconIconSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$L(ctx) {
	let i;
	let i_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let i_data = {};

	for (let i = 0; i < i_levels.length; i += 1) {
		i_data = SvelteInternal.assign(i_data, i_levels[i]);
	}

	return {
		c() {
			i = SvelteInternal.element("i");
			SvelteInternal.set_attributes(i, i_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, i, anchor);
		},
		p(ctx, [dirty]) {
			SvelteInternal.set_attributes(i, i_data = SvelteInternal.get_spread_update(i_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				dirty & /*classes*/ 1 && { class: /*classes*/ ctx[0] }
			]));
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(i);
			}
		}
	};
}

function instance$L($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","name"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { class: className = '' } = $$props;
	let { name = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('name' in $$new_props) $$invalidate(3, name = $$new_props.name);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, name*/ 12) {
			$$invalidate(0, classes = classnames(className, `bi-${name}`));
		}
	};

	return [classes, $$restProps, className, name];
}

class NodeModulesSveltestrapSveltestrapDistIconIconSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$L, create_fragment$L, SvelteInternal.safe_not_equal, { class: 2, name: 3 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get name() {
		return this.$$.ctx[3];
	}

	set name(name) {
		this.$$set({ name });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistImageImageSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$K(ctx) {
	let img;

	let img_levels = [
		{ alt: /*alt*/ ctx[0] },
		/*$$restProps*/ ctx[3],
		{ "data-bs-theme": /*theme*/ ctx[1] },
		{ class: /*classes*/ ctx[2] }
	];

	let img_data = {};

	for (let i = 0; i < img_levels.length; i += 1) {
		img_data = SvelteInternal.assign(img_data, img_levels[i]);
	}

	return {
		c() {
			img = SvelteInternal.element("img");
			SvelteInternal.set_attributes(img, img_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, img, anchor);
		},
		p(ctx, [dirty]) {
			SvelteInternal.set_attributes(img, img_data = SvelteInternal.get_spread_update(img_levels, [
				dirty & /*alt*/ 1 && { alt: /*alt*/ ctx[0] },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				dirty & /*theme*/ 2 && { "data-bs-theme": /*theme*/ ctx[1] },
				dirty & /*classes*/ 4 && { class: /*classes*/ ctx[2] }
			]));
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(img);
			}
		}
	};
}

function instance$K($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","alt","figure","fluid","theme","thumbnail"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { class: className = '' } = $$props;
	let { alt = undefined } = $$props;
	let { figure = SvelteInternal.getContext('figure') } = $$props;
	let { fluid = false } = $$props;
	let { theme = null } = $$props;
	let { thumbnail = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('alt' in $$new_props) $$invalidate(0, alt = $$new_props.alt);
		if ('figure' in $$new_props) $$invalidate(5, figure = $$new_props.figure);
		if ('fluid' in $$new_props) $$invalidate(6, fluid = $$new_props.fluid);
		if ('theme' in $$new_props) $$invalidate(1, theme = $$new_props.theme);
		if ('thumbnail' in $$new_props) $$invalidate(7, thumbnail = $$new_props.thumbnail);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, figure, fluid, thumbnail*/ 240) {
			$$invalidate(2, classes = classnames(className, {
				'figure-img': figure,
				'img-fluid': fluid,
				'img-thumbnail': thumbnail
			}));
		}
	};

	return [alt, theme, classes, $$restProps, className, figure, fluid, thumbnail];
}

class NodeModulesSveltestrapSveltestrapDistImageImageSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$K, create_fragment$K, SvelteInternal.safe_not_equal, {
			class: 4,
			alt: 0,
			figure: 5,
			fluid: 6,
			theme: 1,
			thumbnail: 7
		});
	}

	get class() {
		return this.$$.ctx[4];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get alt() {
		return this.$$.ctx[0];
	}

	set alt(alt) {
		this.$$set({ alt });
		SvelteInternal.flush();
	}

	get figure() {
		return this.$$.ctx[5];
	}

	set figure(figure) {
		this.$$set({ figure });
		SvelteInternal.flush();
	}

	get fluid() {
		return this.$$.ctx[6];
	}

	set fluid(fluid) {
		this.$$set({ fluid });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[1];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}

	get thumbnail() {
		return this.$$.ctx[7];
	}

	set thumbnail(thumbnail) {
		this.$$set({ thumbnail });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistInlineContainerInlineContainerSvelte.svelte generated by Svelte v4.2.8 */




function create_fragment$J(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$J($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistInlineContainerInlineContainerSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$J, create_fragment$J, SvelteInternal.safe_not_equal, {});
	}
}

/* nodeModulesSveltestrapSveltestrapDistInputInputSvelte.svelte generated by Svelte v4.2.8 */


function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[212] = list[i];
	return child_ctx;
}

// (642:40) 
function create_if_block_22(ctx) {
	let select;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[211], null);

	let select_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ name: /*name*/ ctx[13] },
		{ disabled: /*disabled*/ ctx[8] },
		{ readonly: /*readonly*/ ctx[15] }
	];

	let select_data = {};

	for (let i = 0; i < select_levels.length; i += 1) {
		select_data = SvelteInternal.assign(select_data, select_levels[i]);
	}

	return {
		c() {
			select = SvelteInternal.element("select");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(select, select_data);
			if (/*value*/ ctx[6] === void 0) SvelteInternal.add_render_callback(() => /*select_change_handler*/ ctx[209].call(select));
		},
		m(target, anchor) {
			SvelteInternal.insert(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			'value' in select_data && (select_data.multiple ? SvelteInternal.select_options : SvelteInternal.select_option)(select, select_data.value);
			if (select.autofocus) select.focus();
			SvelteInternal.select_option(select, /*value*/ ctx[6], true);
			/*select_binding*/ ctx[210](select);
			current = true;

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(select, "change", /*select_change_handler*/ ctx[209]),
					SvelteInternal.listen(select, "blur", /*blur_handler_20*/ ctx[158]),
					SvelteInternal.listen(select, "change", /*change_handler_19*/ ctx[159]),
					SvelteInternal.listen(select, "focus", /*focus_handler_20*/ ctx[160]),
					SvelteInternal.listen(select, "input", /*input_handler_19*/ ctx[161])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[6] & /*$$scope*/ 33554432)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[211],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[211])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[211], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(select, select_data = SvelteInternal.get_spread_update(select_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				(!current || dirty[0] & /*theme*/ 131072) && { "data-bs-theme": /*theme*/ ctx[17] },
				(!current || dirty[0] & /*classes*/ 2097152) && { class: /*classes*/ ctx[21] },
				(!current || dirty[0] & /*name*/ 8192) && { name: /*name*/ ctx[13] },
				(!current || dirty[0] & /*disabled*/ 256) && { disabled: /*disabled*/ ctx[8] },
				(!current || dirty[0] & /*readonly*/ 32768) && { readonly: /*readonly*/ ctx[15] }
			]));

			if (dirty[0] & /*$$restProps, theme, classes, name, disabled, readonly*/ 10658048 && 'value' in select_data) (select_data.multiple ? SvelteInternal.select_options : SvelteInternal.select_option)(select, select_data.value);

			if (dirty[0] & /*value*/ 64) {
				SvelteInternal.select_option(select, /*value*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(select);
			}

			if (default_slot) default_slot.d(detaching);
			/*select_binding*/ ctx[210](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (623:29) 
function create_if_block_21(ctx) {
	let textarea;
	let mounted;
	let dispose;

	let textarea_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ disabled: /*disabled*/ ctx[8] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] }
	];

	let textarea_data = {};

	for (let i = 0; i < textarea_levels.length; i += 1) {
		textarea_data = SvelteInternal.assign(textarea_data, textarea_levels[i]);
	}

	return {
		c() {
			textarea = SvelteInternal.element("textarea");
			SvelteInternal.set_attributes(textarea, textarea_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, textarea, anchor);
			if (textarea.autofocus) textarea.focus();
			SvelteInternal.set_input_value(textarea, /*value*/ ctx[6]);
			/*textarea_binding*/ ctx[208](textarea);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(textarea, "input", /*textarea_input_handler*/ ctx[207]),
					SvelteInternal.listen(textarea, "blur", /*blur_handler_19*/ ctx[151]),
					SvelteInternal.listen(textarea, "change", /*change_handler_18*/ ctx[152]),
					SvelteInternal.listen(textarea, "focus", /*focus_handler_19*/ ctx[153]),
					SvelteInternal.listen(textarea, "input", /*input_handler_18*/ ctx[154]),
					SvelteInternal.listen(textarea, "keydown", /*keydown_handler_19*/ ctx[155]),
					SvelteInternal.listen(textarea, "keypress", /*keypress_handler_19*/ ctx[156]),
					SvelteInternal.listen(textarea, "keyup", /*keyup_handler_19*/ ctx[157])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(textarea, textarea_data = SvelteInternal.get_spread_update(textarea_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
			]));

			if (dirty[0] & /*value*/ 64) {
				SvelteInternal.set_input_value(textarea, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(textarea);
			}

			/*textarea_binding*/ ctx[208](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (224:0) {#if tag === 'input'}
function create_if_block_2$4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block_3$2,
		create_if_block_4$1,
		create_if_block_5,
		create_if_block_6,
		create_if_block_7,
		create_if_block_8,
		create_if_block_9,
		create_if_block_10,
		create_if_block_11,
		create_if_block_12,
		create_if_block_13,
		create_if_block_14,
		create_if_block_15,
		create_if_block_16,
		create_if_block_17,
		create_if_block_18,
		create_if_block_19,
		create_if_block_20,
		create_else_block_1$1
	];

	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[18] === 'text') return 0;
		if (/*type*/ ctx[18] === 'password') return 1;
		if (/*type*/ ctx[18] === 'color') return 2;
		if (/*type*/ ctx[18] === 'email') return 3;
		if (/*type*/ ctx[18] === 'file') return 4;
		if (/*type*/ ctx[18] === 'checkbox' || /*type*/ ctx[18] === 'radio' || /*type*/ ctx[18] === 'switch') return 5;
		if (/*type*/ ctx[18] === 'url') return 6;
		if (/*type*/ ctx[18] === 'number') return 7;
		if (/*type*/ ctx[18] === 'date') return 8;
		if (/*type*/ ctx[18] === 'time') return 9;
		if (/*type*/ ctx[18] === 'datetime') return 10;
		if (/*type*/ ctx[18] === 'datetime-local') return 11;
		if (/*type*/ ctx[18] === 'month') return 12;
		if (/*type*/ ctx[18] === 'color') return 13;
		if (/*type*/ ctx[18] === 'range') return 14;
		if (/*type*/ ctx[18] === 'search') return 15;
		if (/*type*/ ctx[18] === 'tel') return 16;
		if (/*type*/ ctx[18] === 'week') return 17;
		return 18;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

// (603:2) {:else}
function create_else_block_1$1(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ type: /*type*/ ctx[18] },
		{ readOnly: /*readonly*/ ctx[15] },
		{ class: /*classes*/ ctx[21] },
		{ name: /*name*/ ctx[13] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ value: /*value*/ ctx[6] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);

			if ('value' in input_data) {
				input.value = input_data.value;
			}

			if (input.autofocus) input.focus();

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "blur", /*blur_handler_18*/ ctx[146]),
					SvelteInternal.listen(input, "change", /*handleInput*/ ctx[22]),
					SvelteInternal.listen(input, "focus", /*focus_handler_18*/ ctx[147]),
					SvelteInternal.listen(input, "input", /*handleInput*/ ctx[22]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_18*/ ctx[148]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_18*/ ctx[149]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_18*/ ctx[150])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*type*/ 262144 && { type: /*type*/ ctx[18] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*value*/ 64 && input.value !== /*value*/ ctx[6] && { value: /*value*/ ctx[6] }
			]));

			if ('value' in input_data) {
				input.value = input_data.value;
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (583:28) 
function create_if_block_20(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "week" },
		{ disabled: /*disabled*/ ctx[8] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_16*/ ctx[206](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_14*/ ctx[205]),
					SvelteInternal.listen(input, "blur", /*blur_handler_17*/ ctx[139]),
					SvelteInternal.listen(input, "change", /*change_handler_17*/ ctx[140]),
					SvelteInternal.listen(input, "focus", /*focus_handler_17*/ ctx[141]),
					SvelteInternal.listen(input, "input", /*input_handler_17*/ ctx[142]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_17*/ ctx[143]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_17*/ ctx[144]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_17*/ ctx[145])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "week" },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
			]));

			if (dirty[0] & /*value*/ 64) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_16*/ ctx[206](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (562:27) 
function create_if_block_19(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "tel" },
		{ disabled: /*disabled*/ ctx[8] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] },
		{ size: /*size*/ ctx[1] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_15*/ ctx[204](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_13*/ ctx[203]),
					SvelteInternal.listen(input, "blur", /*blur_handler_16*/ ctx[132]),
					SvelteInternal.listen(input, "change", /*change_handler_16*/ ctx[133]),
					SvelteInternal.listen(input, "focus", /*focus_handler_16*/ ctx[134]),
					SvelteInternal.listen(input, "input", /*input_handler_16*/ ctx[135]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_16*/ ctx[136]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_16*/ ctx[137]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_16*/ ctx[138])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "tel" },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
				dirty[0] & /*size*/ 2 && { size: /*size*/ ctx[1] }
			]));

			if (dirty[0] & /*value*/ 64) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_15*/ ctx[204](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (541:30) 
function create_if_block_18(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "search" },
		{ disabled: /*disabled*/ ctx[8] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] },
		{ size: /*size*/ ctx[1] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_14*/ ctx[202](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_12*/ ctx[201]),
					SvelteInternal.listen(input, "blur", /*blur_handler_15*/ ctx[125]),
					SvelteInternal.listen(input, "change", /*change_handler_15*/ ctx[126]),
					SvelteInternal.listen(input, "focus", /*focus_handler_15*/ ctx[127]),
					SvelteInternal.listen(input, "input", /*input_handler_15*/ ctx[128]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_15*/ ctx[129]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_15*/ ctx[130]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_15*/ ctx[131])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "search" },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
				dirty[0] & /*size*/ 2 && { size: /*size*/ ctx[1] }
			]));

			if (dirty[0] & /*value*/ 64 && input.value !== /*value*/ ctx[6]) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_14*/ ctx[202](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (521:29) 
function create_if_block_17(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ type: "range" },
		{ readOnly: /*readonly*/ ctx[15] },
		{ class: /*classes*/ ctx[21] },
		{ name: /*name*/ ctx[13] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[14] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_13*/ ctx[200](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "change", /*input_change_input_handler*/ ctx[199]),
					SvelteInternal.listen(input, "input", /*input_change_input_handler*/ ctx[199]),
					SvelteInternal.listen(input, "blur", /*blur_handler_14*/ ctx[118]),
					SvelteInternal.listen(input, "change", /*change_handler_14*/ ctx[119]),
					SvelteInternal.listen(input, "focus", /*focus_handler_14*/ ctx[120]),
					SvelteInternal.listen(input, "input", /*input_handler_14*/ ctx[121]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_14*/ ctx[122]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_14*/ ctx[123]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_14*/ ctx[124])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				{ type: "range" },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] }
			]));

			if (dirty[0] & /*value*/ 64) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_13*/ ctx[200](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (501:29) 
function create_if_block_16(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ type: "color" },
		{ readOnly: /*readonly*/ ctx[15] },
		{ class: /*classes*/ ctx[21] },
		{ name: /*name*/ ctx[13] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[14] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_12*/ ctx[198](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_11*/ ctx[197]),
					SvelteInternal.listen(input, "blur", /*blur_handler_13*/ ctx[111]),
					SvelteInternal.listen(input, "change", /*change_handler_13*/ ctx[112]),
					SvelteInternal.listen(input, "focus", /*focus_handler_13*/ ctx[113]),
					SvelteInternal.listen(input, "input", /*input_handler_13*/ ctx[114]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_13*/ ctx[115]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_13*/ ctx[116]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_13*/ ctx[117])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				{ type: "color" },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] }
			]));

			if (dirty[0] & /*value*/ 64) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_12*/ ctx[198](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (481:29) 
function create_if_block_15(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "month" },
		{ disabled: /*disabled*/ ctx[8] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_11*/ ctx[196](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_10*/ ctx[195]),
					SvelteInternal.listen(input, "blur", /*blur_handler_12*/ ctx[104]),
					SvelteInternal.listen(input, "change", /*change_handler_12*/ ctx[105]),
					SvelteInternal.listen(input, "focus", /*focus_handler_12*/ ctx[106]),
					SvelteInternal.listen(input, "input", /*input_handler_12*/ ctx[107]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_12*/ ctx[108]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_12*/ ctx[109]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_12*/ ctx[110])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "month" },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
			]));

			if (dirty[0] & /*value*/ 64) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_11*/ ctx[196](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (461:38) 
function create_if_block_14(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "datetime-local" },
		{ disabled: /*disabled*/ ctx[8] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_10*/ ctx[194](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_9*/ ctx[193]),
					SvelteInternal.listen(input, "blur", /*blur_handler_11*/ ctx[97]),
					SvelteInternal.listen(input, "change", /*change_handler_11*/ ctx[98]),
					SvelteInternal.listen(input, "focus", /*focus_handler_11*/ ctx[99]),
					SvelteInternal.listen(input, "input", /*input_handler_11*/ ctx[100]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_11*/ ctx[101]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_11*/ ctx[102]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_11*/ ctx[103])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "datetime-local" },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
			]));

			if (dirty[0] & /*value*/ 64) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_10*/ ctx[194](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (441:32) 
function create_if_block_13(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ type: "datetime" },
		{ readOnly: /*readonly*/ ctx[15] },
		{ class: /*classes*/ ctx[21] },
		{ name: /*name*/ ctx[13] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[14] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_9*/ ctx[192](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_8*/ ctx[191]),
					SvelteInternal.listen(input, "blur", /*blur_handler_10*/ ctx[90]),
					SvelteInternal.listen(input, "change", /*change_handler_10*/ ctx[91]),
					SvelteInternal.listen(input, "focus", /*focus_handler_10*/ ctx[92]),
					SvelteInternal.listen(input, "input", /*input_handler_10*/ ctx[93]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_10*/ ctx[94]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_10*/ ctx[95]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_10*/ ctx[96])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				{ type: "datetime" },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] }
			]));

			if (dirty[0] & /*value*/ 64) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_9*/ ctx[192](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (421:28) 
function create_if_block_12(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "time" },
		{ disabled: /*disabled*/ ctx[8] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_8*/ ctx[190](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_7*/ ctx[189]),
					SvelteInternal.listen(input, "blur", /*blur_handler_9*/ ctx[83]),
					SvelteInternal.listen(input, "change", /*change_handler_9*/ ctx[84]),
					SvelteInternal.listen(input, "focus", /*focus_handler_9*/ ctx[85]),
					SvelteInternal.listen(input, "input", /*input_handler_9*/ ctx[86]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_9*/ ctx[87]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_9*/ ctx[88]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_9*/ ctx[89])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "time" },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
			]));

			if (dirty[0] & /*value*/ 64) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_8*/ ctx[190](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (401:28) 
function create_if_block_11(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "date" },
		{ disabled: /*disabled*/ ctx[8] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_7*/ ctx[188](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_6*/ ctx[187]),
					SvelteInternal.listen(input, "blur", /*blur_handler_8*/ ctx[76]),
					SvelteInternal.listen(input, "change", /*change_handler_8*/ ctx[77]),
					SvelteInternal.listen(input, "focus", /*focus_handler_8*/ ctx[78]),
					SvelteInternal.listen(input, "input", /*input_handler_8*/ ctx[79]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_8*/ ctx[80]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_8*/ ctx[81]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_8*/ ctx[82])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "date" },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
			]));

			if (dirty[0] & /*value*/ 64) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_7*/ ctx[188](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (381:30) 
function create_if_block_10(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "number" },
		{ readOnly: /*readonly*/ ctx[15] },
		{ name: /*name*/ ctx[13] },
		{ disabled: /*disabled*/ ctx[8] },
		{ placeholder: /*placeholder*/ ctx[14] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_6*/ ctx[186](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_5*/ ctx[185]),
					SvelteInternal.listen(input, "blur", /*blur_handler_7*/ ctx[69]),
					SvelteInternal.listen(input, "change", /*change_handler_7*/ ctx[70]),
					SvelteInternal.listen(input, "focus", /*focus_handler_7*/ ctx[71]),
					SvelteInternal.listen(input, "input", /*input_handler_7*/ ctx[72]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_7*/ ctx[73]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_7*/ ctx[74]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_7*/ ctx[75])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "number" },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] }
			]));

			if (dirty[0] & /*value*/ 64 && SvelteInternal.to_number(input.value) !== /*value*/ ctx[6]) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_6*/ ctx[186](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (360:27) 
function create_if_block_9(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "url" },
		{ disabled: /*disabled*/ ctx[8] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] },
		{ size: /*size*/ ctx[1] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_5*/ ctx[184](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_4*/ ctx[183]),
					SvelteInternal.listen(input, "blur", /*blur_handler_6*/ ctx[62]),
					SvelteInternal.listen(input, "change", /*change_handler_6*/ ctx[63]),
					SvelteInternal.listen(input, "focus", /*focus_handler_6*/ ctx[64]),
					SvelteInternal.listen(input, "input", /*input_handler_6*/ ctx[65]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_6*/ ctx[66]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_6*/ ctx[67]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_6*/ ctx[68])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "url" },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
				dirty[0] & /*size*/ 2 && { size: /*size*/ ctx[1] }
			]));

			if (dirty[0] & /*value*/ 64 && input.value !== /*value*/ ctx[6]) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_5*/ ctx[184](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (333:73) 
function create_if_block_8(ctx) {
	let formcheck;
	let updating_checked;
	let updating_inner;
	let updating_group;
	let updating_value;
	let current;

	const formcheck_spread_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*className*/ ctx[7] },
		{ size: /*bsSize*/ ctx[0] },
		{ type: /*type*/ ctx[18] },
		{ disabled: /*disabled*/ ctx[8] },
		{ invalid: /*invalid*/ ctx[10] },
		{ label: /*label*/ ctx[11] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ reverse: /*reverse*/ ctx[16] },
		{ readonly: /*readonly*/ ctx[15] },
		{ valid: /*valid*/ ctx[19] }
	];

	function formcheck_checked_binding(value) {
		/*formcheck_checked_binding*/ ctx[172](value);
	}

	function formcheck_inner_binding(value) {
		/*formcheck_inner_binding*/ ctx[173](value);
	}

	function formcheck_group_binding(value) {
		/*formcheck_group_binding*/ ctx[174](value);
	}

	function formcheck_value_binding(value) {
		/*formcheck_value_binding*/ ctx[175](value);
	}

	let formcheck_props = {};

	for (let i = 0; i < formcheck_spread_levels.length; i += 1) {
		formcheck_props = SvelteInternal.assign(formcheck_props, formcheck_spread_levels[i]);
	}

	if (/*checked*/ ctx[2] !== void 0) {
		formcheck_props.checked = /*checked*/ ctx[2];
	}

	if (/*inner*/ ctx[5] !== void 0) {
		formcheck_props.inner = /*inner*/ ctx[5];
	}

	if (/*group*/ ctx[4] !== void 0) {
		formcheck_props.group = /*group*/ ctx[4];
	}

	if (/*value*/ ctx[6] !== void 0) {
		formcheck_props.value = /*value*/ ctx[6];
	}

	formcheck = new NodeModulesSveltestrapSveltestrapDistFormCheckFormCheckSvelte({ props: formcheck_props });
	SvelteInternal.binding_callbacks.push(() => SvelteInternal.bind(formcheck, 'checked', formcheck_checked_binding));
	SvelteInternal.binding_callbacks.push(() => SvelteInternal.bind(formcheck, 'inner', formcheck_inner_binding));
	SvelteInternal.binding_callbacks.push(() => SvelteInternal.bind(formcheck, 'group', formcheck_group_binding));
	SvelteInternal.binding_callbacks.push(() => SvelteInternal.bind(formcheck, 'value', formcheck_value_binding));
	formcheck.$on("blur", /*blur_handler_5*/ ctx[176]);
	formcheck.$on("change", /*change_handler_5*/ ctx[177]);
	formcheck.$on("focus", /*focus_handler_5*/ ctx[178]);
	formcheck.$on("input", /*input_handler_5*/ ctx[179]);
	formcheck.$on("keydown", /*keydown_handler_5*/ ctx[180]);
	formcheck.$on("keypress", /*keypress_handler_5*/ ctx[181]);
	formcheck.$on("keyup", /*keyup_handler_5*/ ctx[182]);

	return {
		c() {
			SvelteInternal.create_component(formcheck.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(formcheck, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const formcheck_changes = (dirty[0] & /*$$restProps, theme, className, bsSize, type, disabled, invalid, label, name, placeholder, reverse, readonly, valid*/ 9432449)
			? SvelteInternal.get_spread_update(formcheck_spread_levels, [
					dirty[0] & /*$$restProps*/ 8388608 && SvelteInternal.get_spread_object(/*$$restProps*/ ctx[23]),
					dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
					dirty[0] & /*className*/ 128 && { class: /*className*/ ctx[7] },
					dirty[0] & /*bsSize*/ 1 && { size: /*bsSize*/ ctx[0] },
					dirty[0] & /*type*/ 262144 && { type: /*type*/ ctx[18] },
					dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
					dirty[0] & /*invalid*/ 1024 && { invalid: /*invalid*/ ctx[10] },
					dirty[0] & /*label*/ 2048 && { label: /*label*/ ctx[11] },
					dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
					dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
					dirty[0] & /*reverse*/ 65536 && { reverse: /*reverse*/ ctx[16] },
					dirty[0] & /*readonly*/ 32768 && { readonly: /*readonly*/ ctx[15] },
					dirty[0] & /*valid*/ 524288 && { valid: /*valid*/ ctx[19] }
				])
			: {};

			if (!updating_checked && dirty[0] & /*checked*/ 4) {
				updating_checked = true;
				formcheck_changes.checked = /*checked*/ ctx[2];
				SvelteInternal.add_flush_callback(() => updating_checked = false);
			}

			if (!updating_inner && dirty[0] & /*inner*/ 32) {
				updating_inner = true;
				formcheck_changes.inner = /*inner*/ ctx[5];
				SvelteInternal.add_flush_callback(() => updating_inner = false);
			}

			if (!updating_group && dirty[0] & /*group*/ 16) {
				updating_group = true;
				formcheck_changes.group = /*group*/ ctx[4];
				SvelteInternal.add_flush_callback(() => updating_group = false);
			}

			if (!updating_value && dirty[0] & /*value*/ 64) {
				updating_value = true;
				formcheck_changes.value = /*value*/ ctx[6];
				SvelteInternal.add_flush_callback(() => updating_value = false);
			}

			formcheck.$set(formcheck_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(formcheck.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(formcheck.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(formcheck, detaching);
		}
	};
}

// (309:28) 
function create_if_block_7(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "file" },
		{ disabled: /*disabled*/ ctx[8] },
		{ invalid: /*invalid*/ ctx[10] },
		{ multiple: /*multiple*/ ctx[12] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] },
		{ valid: /*valid*/ ctx[19] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			/*input_binding_4*/ ctx[171](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "change", /*input_change_handler*/ ctx[170]),
					SvelteInternal.listen(input, "blur", /*blur_handler_4*/ ctx[55]),
					SvelteInternal.listen(input, "change", /*change_handler_4*/ ctx[56]),
					SvelteInternal.listen(input, "focus", /*focus_handler_4*/ ctx[57]),
					SvelteInternal.listen(input, "input", /*input_handler_4*/ ctx[58]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_4*/ ctx[59]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_4*/ ctx[60]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_4*/ ctx[61])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "file" },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*invalid*/ 1024 && { invalid: /*invalid*/ ctx[10] },
				dirty[0] & /*multiple*/ 4096 && { multiple: /*multiple*/ ctx[12] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
				dirty[0] & /*valid*/ 524288 && { valid: /*valid*/ ctx[19] }
			]));
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_4*/ ctx[171](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (287:29) 
function create_if_block_6(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "email" },
		{ disabled: /*disabled*/ ctx[8] },
		{ multiple: /*multiple*/ ctx[12] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] },
		{ size: /*size*/ ctx[1] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_3*/ ctx[169](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_3*/ ctx[168]),
					SvelteInternal.listen(input, "blur", /*blur_handler_3*/ ctx[48]),
					SvelteInternal.listen(input, "change", /*change_handler_3*/ ctx[49]),
					SvelteInternal.listen(input, "focus", /*focus_handler_3*/ ctx[50]),
					SvelteInternal.listen(input, "input", /*input_handler_3*/ ctx[51]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_3*/ ctx[52]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_3*/ ctx[53]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_3*/ ctx[54])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "email" },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*multiple*/ 4096 && { multiple: /*multiple*/ ctx[12] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
				dirty[0] & /*size*/ 2 && { size: /*size*/ ctx[1] }
			]));

			if (dirty[0] & /*value*/ 64 && input.value !== /*value*/ ctx[6]) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_3*/ ctx[169](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (267:29) 
function create_if_block_5(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "color" },
		{ disabled: /*disabled*/ ctx[8] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_2*/ ctx[167](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_2*/ ctx[166]),
					SvelteInternal.listen(input, "blur", /*blur_handler_2*/ ctx[41]),
					SvelteInternal.listen(input, "change", /*change_handler_2*/ ctx[42]),
					SvelteInternal.listen(input, "focus", /*focus_handler_2*/ ctx[43]),
					SvelteInternal.listen(input, "input", /*input_handler_2*/ ctx[44]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_2*/ ctx[45]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_2*/ ctx[46]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_2*/ ctx[47])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "color" },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
			]));

			if (dirty[0] & /*value*/ 64) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_2*/ ctx[167](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (246:32) 
function create_if_block_4$1(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "password" },
		{ disabled: /*disabled*/ ctx[8] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] },
		{ size: /*size*/ ctx[1] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding_1*/ ctx[165](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler_1*/ ctx[164]),
					SvelteInternal.listen(input, "blur", /*blur_handler_1*/ ctx[34]),
					SvelteInternal.listen(input, "change", /*change_handler_1*/ ctx[35]),
					SvelteInternal.listen(input, "focus", /*focus_handler_1*/ ctx[36]),
					SvelteInternal.listen(input, "input", /*input_handler_1*/ ctx[37]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler_1*/ ctx[38]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler_1*/ ctx[39]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler_1*/ ctx[40])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "password" },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
				dirty[0] & /*size*/ 2 && { size: /*size*/ ctx[1] }
			]));

			if (dirty[0] & /*value*/ 64 && input.value !== /*value*/ ctx[6]) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding_1*/ ctx[165](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (225:2) {#if type === 'text'}
function create_if_block_3$2(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[17] },
		{ class: /*classes*/ ctx[21] },
		{ type: "text" },
		{ disabled: /*disabled*/ ctx[8] },
		{ name: /*name*/ ctx[13] },
		{ placeholder: /*placeholder*/ ctx[14] },
		{ readOnly: /*readonly*/ ctx[15] },
		{ size: /*size*/ ctx[1] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = SvelteInternal.assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = SvelteInternal.element("input");
			SvelteInternal.set_attributes(input, input_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, input, anchor);
			if (input.autofocus) input.focus();
			SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			/*input_binding*/ ctx[163](input);

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(input, "input", /*input_input_handler*/ ctx[162]),
					SvelteInternal.listen(input, "blur", /*blur_handler*/ ctx[27]),
					SvelteInternal.listen(input, "change", /*change_handler*/ ctx[28]),
					SvelteInternal.listen(input, "focus", /*focus_handler*/ ctx[29]),
					SvelteInternal.listen(input, "input", /*input_handler*/ ctx[30]),
					SvelteInternal.listen(input, "keydown", /*keydown_handler*/ ctx[31]),
					SvelteInternal.listen(input, "keypress", /*keypress_handler*/ ctx[32]),
					SvelteInternal.listen(input, "keyup", /*keyup_handler*/ ctx[33])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(input, input_data = SvelteInternal.get_spread_update(input_levels, [
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				dirty[0] & /*theme*/ 131072 && { "data-bs-theme": /*theme*/ ctx[17] },
				dirty[0] & /*classes*/ 2097152 && { class: /*classes*/ ctx[21] },
				{ type: "text" },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
				dirty[0] & /*size*/ 2 && { size: /*size*/ ctx[1] }
			]));

			if (dirty[0] & /*value*/ 64 && input.value !== /*value*/ ctx[6]) {
				SvelteInternal.set_input_value(input, /*value*/ ctx[6]);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(input);
			}

			/*input_binding*/ ctx[163](null);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (677:0) {#if feedback}
function create_if_block$j(ctx) {
	let show_if;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$b, create_else_block$g];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (dirty[0] & /*feedback*/ 512) show_if = null;
		if (show_if == null) show_if = !!Array.isArray(/*feedback*/ ctx[9]);
		if (show_if) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx, [-1, -1, -1, -1, -1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

// (682:2) {:else}
function create_else_block$g(ctx) {
	let formfeedback;
	let current;

	formfeedback = new NodeModulesSveltestrapSveltestrapDistFormFeedbackFormFeedbackSvelte({
			props: {
				valid: /*valid*/ ctx[19],
				$$slots: { default: [create_default_slot_1$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			SvelteInternal.create_component(formfeedback.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(formfeedback, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const formfeedback_changes = {};
			if (dirty[0] & /*valid*/ 524288) formfeedback_changes.valid = /*valid*/ ctx[19];

			if (dirty[0] & /*feedback*/ 512 | dirty[6] & /*$$scope*/ 33554432) {
				formfeedback_changes.$$scope = { dirty, ctx };
			}

			formfeedback.$set(formfeedback_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(formfeedback.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(formfeedback.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(formfeedback, detaching);
		}
	};
}

// (678:2) {#if Array.isArray(feedback)}
function create_if_block_1$b(ctx) {
	let each_1_anchor;
	let current;
	let each_value = SvelteInternal.ensure_array_like(/*feedback*/ ctx[9]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => SvelteInternal.transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			SvelteInternal.insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*valid, feedback*/ 524800) {
				each_value = SvelteInternal.ensure_array_like(/*feedback*/ ctx[9]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						SvelteInternal.transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						SvelteInternal.transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				SvelteInternal.group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				SvelteInternal.check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				SvelteInternal.transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				SvelteInternal.transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(each_1_anchor);
			}

			SvelteInternal.destroy_each(each_blocks, detaching);
		}
	};
}

// (683:4) <FormFeedback {valid}>
function create_default_slot_1$5(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*feedback*/ ctx[9]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*feedback*/ 512) SvelteInternal.set_data(t, /*feedback*/ ctx[9]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (680:6) <FormFeedback {valid}>
function create_default_slot$a(ctx) {
	let t_value = /*msg*/ ctx[212] + "";
	let t;

	return {
		c() {
			t = SvelteInternal.text(t_value);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*feedback*/ 512 && t_value !== (t_value = /*msg*/ ctx[212] + "")) SvelteInternal.set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (679:4) {#each feedback as msg}
function create_each_block$1(ctx) {
	let formfeedback;
	let current;

	formfeedback = new NodeModulesSveltestrapSveltestrapDistFormFeedbackFormFeedbackSvelte({
			props: {
				valid: /*valid*/ ctx[19],
				$$slots: { default: [create_default_slot$a] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			SvelteInternal.create_component(formfeedback.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(formfeedback, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const formfeedback_changes = {};
			if (dirty[0] & /*valid*/ 524288) formfeedback_changes.valid = /*valid*/ ctx[19];

			if (dirty[0] & /*feedback*/ 512 | dirty[6] & /*$$scope*/ 33554432) {
				formfeedback_changes.$$scope = { dirty, ctx };
			}

			formfeedback.$set(formfeedback_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(formfeedback.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(formfeedback.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(formfeedback, detaching);
		}
	};
}

function create_fragment$I(ctx) {
	let current_block_type_index;
	let if_block0;
	let t;
	let if_block1_anchor;
	let current;
	const if_block_creators = [create_if_block_2$4, create_if_block_21, create_if_block_22];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[20] === 'input') return 0;
		if (/*tag*/ ctx[20] === 'textarea') return 1;
		if (/*tag*/ ctx[20] === 'select' && !/*multiple*/ ctx[12]) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	let if_block1 = /*feedback*/ ctx[9] && create_if_block$j(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = SvelteInternal.space();
			if (if_block1) if_block1.c();
			if_block1_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			SvelteInternal.insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			SvelteInternal.insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block0) {
					SvelteInternal.group_outros();

					SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					SvelteInternal.check_outros();
				}

				if (~current_block_type_index) {
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					SvelteInternal.transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				} else {
					if_block0 = null;
				}
			}

			if (/*feedback*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*feedback*/ 512) {
						SvelteInternal.transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$j(ctx);
					if_block1.c();
					SvelteInternal.transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				SvelteInternal.check_outros();
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block0);
			SvelteInternal.transition_in(if_block1);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block0);
			SvelteInternal.transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
				SvelteInternal.detach(if_block1_anchor);
			}

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (if_block1) if_block1.d(detaching);
		}
	};
}

function instance$I($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","bsSize","checked","color","disabled","feedback","files","group","inner","invalid","label","multiple","name","placeholder","plaintext","readonly","reverse","size","theme","type","valid","value"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { bsSize = undefined } = $$props;
	let { checked = false } = $$props;
	let { color = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { feedback = undefined } = $$props;
	let { files = undefined } = $$props;
	let { group = undefined } = $$props;
	let { inner = undefined } = $$props;
	let { invalid = false } = $$props;
	let { label = undefined } = $$props;
	let { multiple = undefined } = $$props;
	let { name = '' } = $$props;
	let { placeholder = '' } = $$props;
	let { plaintext = false } = $$props;
	let { readonly = undefined } = $$props;
	let { reverse = false } = $$props;
	let { size = undefined } = $$props;
	let { theme = undefined } = $$props;
	let { type = 'text' } = $$props;
	let { valid = false } = $$props;
	let { value = undefined } = $$props;
	let classes;
	let tag;

	const handleInput = event => {
		$$invalidate(6, value = event.target.value);
	};

	function blur_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_2(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_2(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_2(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_2(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_2(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_2(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_2(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_3(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_3(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_3(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_3(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_3(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_3(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_3(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_4(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_4(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_4(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_4(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_4(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_4(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_4(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_6(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_6(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_6(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_6(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_6(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_6(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_6(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_7(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_7(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_7(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_7(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_7(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_7(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_7(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_8(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_8(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_8(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_8(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_8(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_8(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_8(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_9(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_9(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_9(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_9(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_9(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_9(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_9(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_10(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_10(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_10(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_10(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_10(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_10(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_10(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_11(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_11(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_11(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_11(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_11(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_11(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_11(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_12(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_12(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_12(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_12(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_12(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_12(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_12(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_13(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_13(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_13(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_13(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_13(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_13(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_13(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_14(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_14(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_14(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_14(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_14(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_14(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_14(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_15(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_15(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_15(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_15(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_15(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_15(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_15(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_16(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_16(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_16(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_16(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_16(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_16(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_16(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_17(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_17(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_17(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_17(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_17(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_17(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_17(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_18(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_18(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_18(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_18(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_18(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_19(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_18(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_19(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_18(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_19(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_19(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_19(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function blur_handler_20(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_19(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_20(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_19(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_input_handler_1() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding_1($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_input_handler_2() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding_2($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_input_handler_3() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding_3($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_change_handler() {
		files = this.files;
		value = this.value;
		$$invalidate(3, files);
		$$invalidate(6, value);
	}

	function input_binding_4($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function formcheck_checked_binding(value) {
		checked = value;
		$$invalidate(2, checked);
	}

	function formcheck_inner_binding(value) {
		inner = value;
		$$invalidate(5, inner);
	}

	function formcheck_group_binding(value) {
		group = value;
		$$invalidate(4, group);
	}

	function formcheck_value_binding(value$1) {
		value = value$1;
		$$invalidate(6, value);
	}

	function blur_handler_5(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function change_handler_5(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function focus_handler_5(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_handler_5(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keydown_handler_5(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keypress_handler_5(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function keyup_handler_5(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function input_input_handler_4() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding_5($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_input_handler_5() {
		value = SvelteInternal.to_number(this.value);
		$$invalidate(6, value);
	}

	function input_binding_6($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_input_handler_6() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding_7($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_input_handler_7() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding_8($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_input_handler_8() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding_9($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_input_handler_9() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding_10($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_input_handler_10() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding_11($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_input_handler_11() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding_12($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_change_input_handler() {
		value = SvelteInternal.to_number(this.value);
		$$invalidate(6, value);
	}

	function input_binding_13($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_input_handler_12() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding_14($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_input_handler_13() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding_15($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function input_input_handler_14() {
		value = this.value;
		$$invalidate(6, value);
	}

	function input_binding_16($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function textarea_input_handler() {
		value = this.value;
		$$invalidate(6, value);
	}

	function textarea_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	function select_change_handler() {
		value = SvelteInternal.select_value(this);
		$$invalidate(6, value);
	}

	function select_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(5, inner);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(23, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ('bsSize' in $$new_props) $$invalidate(0, bsSize = $$new_props.bsSize);
		if ('checked' in $$new_props) $$invalidate(2, checked = $$new_props.checked);
		if ('color' in $$new_props) $$invalidate(24, color = $$new_props.color);
		if ('disabled' in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
		if ('feedback' in $$new_props) $$invalidate(9, feedback = $$new_props.feedback);
		if ('files' in $$new_props) $$invalidate(3, files = $$new_props.files);
		if ('group' in $$new_props) $$invalidate(4, group = $$new_props.group);
		if ('inner' in $$new_props) $$invalidate(5, inner = $$new_props.inner);
		if ('invalid' in $$new_props) $$invalidate(10, invalid = $$new_props.invalid);
		if ('label' in $$new_props) $$invalidate(11, label = $$new_props.label);
		if ('multiple' in $$new_props) $$invalidate(12, multiple = $$new_props.multiple);
		if ('name' in $$new_props) $$invalidate(13, name = $$new_props.name);
		if ('placeholder' in $$new_props) $$invalidate(14, placeholder = $$new_props.placeholder);
		if ('plaintext' in $$new_props) $$invalidate(25, plaintext = $$new_props.plaintext);
		if ('readonly' in $$new_props) $$invalidate(15, readonly = $$new_props.readonly);
		if ('reverse' in $$new_props) $$invalidate(16, reverse = $$new_props.reverse);
		if ('size' in $$new_props) $$invalidate(1, size = $$new_props.size);
		if ('theme' in $$new_props) $$invalidate(17, theme = $$new_props.theme);
		if ('type' in $$new_props) $$invalidate(18, type = $$new_props.type);
		if ('valid' in $$new_props) $$invalidate(19, valid = $$new_props.valid);
		if ('value' in $$new_props) $$invalidate(6, value = $$new_props.value);
		if ('$$scope' in $$new_props) $$invalidate(211, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*type, color, plaintext, size, className, invalid, valid, bsSize, tag*/ 52167811) {
			{
				const isNotaNumber = new RegExp('\\D', 'g');
				let isBtn = false;
				let formControlClass = 'form-control';
				$$invalidate(20, tag = 'input');

				switch (type) {
					case 'color':
						formControlClass = `form-control form-control-color`;
						break;
					case 'range':
						formControlClass = 'form-range';
						break;
					case 'select':
						formControlClass = `form-select`;
						$$invalidate(20, tag = 'select');
						break;
					case 'textarea':
						$$invalidate(20, tag = 'textarea');
						break;
					case 'button':
					case 'reset':
					case 'submit':
						formControlClass = `btn btn-${color || 'secondary'}`;
						isBtn = true;
						break;
					case 'hidden':
					case 'image':
						formControlClass = undefined;
						break;
					default:
						formControlClass = 'form-control';
						$$invalidate(20, tag = 'input');
				}

				if (plaintext) {
					formControlClass = `${formControlClass}-plaintext`;
					$$invalidate(20, tag = 'input');
				}

				if (size && isNotaNumber.test(size)) {
					console.warn('Please use the prop "bsSize" instead of the "size" to bootstrap\'s input sizing.');
					$$invalidate(0, bsSize = size);
					$$invalidate(1, size = undefined);
				}

				$$invalidate(21, classes = classnames(className, formControlClass, {
					'is-invalid': invalid,
					'is-valid': valid,
					[`form-control-${bsSize}`]: bsSize && !isBtn && tag !== 'select',
					[`form-select-${bsSize}`]: bsSize && tag === 'select',
					[`btn-${bsSize}`]: bsSize && isBtn
				}));
			}
		}
	};

	return [
		bsSize,
		size,
		checked,
		files,
		group,
		inner,
		value,
		className,
		disabled,
		feedback,
		invalid,
		label,
		multiple,
		name,
		placeholder,
		readonly,
		reverse,
		theme,
		type,
		valid,
		tag,
		classes,
		handleInput,
		$$restProps,
		color,
		plaintext,
		slots,
		blur_handler,
		change_handler,
		focus_handler,
		input_handler,
		keydown_handler,
		keypress_handler,
		keyup_handler,
		blur_handler_1,
		change_handler_1,
		focus_handler_1,
		input_handler_1,
		keydown_handler_1,
		keypress_handler_1,
		keyup_handler_1,
		blur_handler_2,
		change_handler_2,
		focus_handler_2,
		input_handler_2,
		keydown_handler_2,
		keypress_handler_2,
		keyup_handler_2,
		blur_handler_3,
		change_handler_3,
		focus_handler_3,
		input_handler_3,
		keydown_handler_3,
		keypress_handler_3,
		keyup_handler_3,
		blur_handler_4,
		change_handler_4,
		focus_handler_4,
		input_handler_4,
		keydown_handler_4,
		keypress_handler_4,
		keyup_handler_4,
		blur_handler_6,
		change_handler_6,
		focus_handler_6,
		input_handler_6,
		keydown_handler_6,
		keypress_handler_6,
		keyup_handler_6,
		blur_handler_7,
		change_handler_7,
		focus_handler_7,
		input_handler_7,
		keydown_handler_7,
		keypress_handler_7,
		keyup_handler_7,
		blur_handler_8,
		change_handler_8,
		focus_handler_8,
		input_handler_8,
		keydown_handler_8,
		keypress_handler_8,
		keyup_handler_8,
		blur_handler_9,
		change_handler_9,
		focus_handler_9,
		input_handler_9,
		keydown_handler_9,
		keypress_handler_9,
		keyup_handler_9,
		blur_handler_10,
		change_handler_10,
		focus_handler_10,
		input_handler_10,
		keydown_handler_10,
		keypress_handler_10,
		keyup_handler_10,
		blur_handler_11,
		change_handler_11,
		focus_handler_11,
		input_handler_11,
		keydown_handler_11,
		keypress_handler_11,
		keyup_handler_11,
		blur_handler_12,
		change_handler_12,
		focus_handler_12,
		input_handler_12,
		keydown_handler_12,
		keypress_handler_12,
		keyup_handler_12,
		blur_handler_13,
		change_handler_13,
		focus_handler_13,
		input_handler_13,
		keydown_handler_13,
		keypress_handler_13,
		keyup_handler_13,
		blur_handler_14,
		change_handler_14,
		focus_handler_14,
		input_handler_14,
		keydown_handler_14,
		keypress_handler_14,
		keyup_handler_14,
		blur_handler_15,
		change_handler_15,
		focus_handler_15,
		input_handler_15,
		keydown_handler_15,
		keypress_handler_15,
		keyup_handler_15,
		blur_handler_16,
		change_handler_16,
		focus_handler_16,
		input_handler_16,
		keydown_handler_16,
		keypress_handler_16,
		keyup_handler_16,
		blur_handler_17,
		change_handler_17,
		focus_handler_17,
		input_handler_17,
		keydown_handler_17,
		keypress_handler_17,
		keyup_handler_17,
		blur_handler_18,
		focus_handler_18,
		keydown_handler_18,
		keypress_handler_18,
		keyup_handler_18,
		blur_handler_19,
		change_handler_18,
		focus_handler_19,
		input_handler_18,
		keydown_handler_19,
		keypress_handler_19,
		keyup_handler_19,
		blur_handler_20,
		change_handler_19,
		focus_handler_20,
		input_handler_19,
		input_input_handler,
		input_binding,
		input_input_handler_1,
		input_binding_1,
		input_input_handler_2,
		input_binding_2,
		input_input_handler_3,
		input_binding_3,
		input_change_handler,
		input_binding_4,
		formcheck_checked_binding,
		formcheck_inner_binding,
		formcheck_group_binding,
		formcheck_value_binding,
		blur_handler_5,
		change_handler_5,
		focus_handler_5,
		input_handler_5,
		keydown_handler_5,
		keypress_handler_5,
		keyup_handler_5,
		input_input_handler_4,
		input_binding_5,
		input_input_handler_5,
		input_binding_6,
		input_input_handler_6,
		input_binding_7,
		input_input_handler_7,
		input_binding_8,
		input_input_handler_8,
		input_binding_9,
		input_input_handler_9,
		input_binding_10,
		input_input_handler_10,
		input_binding_11,
		input_input_handler_11,
		input_binding_12,
		input_change_input_handler,
		input_binding_13,
		input_input_handler_12,
		input_binding_14,
		input_input_handler_13,
		input_binding_15,
		input_input_handler_14,
		input_binding_16,
		textarea_input_handler,
		textarea_binding,
		select_change_handler,
		select_binding,
		$$scope
	];
}

class NodeModulesSveltestrapSveltestrapDistInputInputSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(
			this,
			options,
			instance$I,
			create_fragment$I,
			SvelteInternal.safe_not_equal,
			{
				class: 7,
				bsSize: 0,
				checked: 2,
				color: 24,
				disabled: 8,
				feedback: 9,
				files: 3,
				group: 4,
				inner: 5,
				invalid: 10,
				label: 11,
				multiple: 12,
				name: 13,
				placeholder: 14,
				plaintext: 25,
				readonly: 15,
				reverse: 16,
				size: 1,
				theme: 17,
				type: 18,
				valid: 19,
				value: 6
			},
			null,
			[-1, -1, -1, -1, -1, -1, -1]
		);
	}

	get class() {
		return this.$$.ctx[7];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get bsSize() {
		return this.$$.ctx[0];
	}

	set bsSize(bsSize) {
		this.$$set({ bsSize });
		SvelteInternal.flush();
	}

	get checked() {
		return this.$$.ctx[2];
	}

	set checked(checked) {
		this.$$set({ checked });
		SvelteInternal.flush();
	}

	get color() {
		return this.$$.ctx[24];
	}

	set color(color) {
		this.$$set({ color });
		SvelteInternal.flush();
	}

	get disabled() {
		return this.$$.ctx[8];
	}

	set disabled(disabled) {
		this.$$set({ disabled });
		SvelteInternal.flush();
	}

	get feedback() {
		return this.$$.ctx[9];
	}

	set feedback(feedback) {
		this.$$set({ feedback });
		SvelteInternal.flush();
	}

	get files() {
		return this.$$.ctx[3];
	}

	set files(files) {
		this.$$set({ files });
		SvelteInternal.flush();
	}

	get group() {
		return this.$$.ctx[4];
	}

	set group(group) {
		this.$$set({ group });
		SvelteInternal.flush();
	}

	get inner() {
		return this.$$.ctx[5];
	}

	set inner(inner) {
		this.$$set({ inner });
		SvelteInternal.flush();
	}

	get invalid() {
		return this.$$.ctx[10];
	}

	set invalid(invalid) {
		this.$$set({ invalid });
		SvelteInternal.flush();
	}

	get label() {
		return this.$$.ctx[11];
	}

	set label(label) {
		this.$$set({ label });
		SvelteInternal.flush();
	}

	get multiple() {
		return this.$$.ctx[12];
	}

	set multiple(multiple) {
		this.$$set({ multiple });
		SvelteInternal.flush();
	}

	get name() {
		return this.$$.ctx[13];
	}

	set name(name) {
		this.$$set({ name });
		SvelteInternal.flush();
	}

	get placeholder() {
		return this.$$.ctx[14];
	}

	set placeholder(placeholder) {
		this.$$set({ placeholder });
		SvelteInternal.flush();
	}

	get plaintext() {
		return this.$$.ctx[25];
	}

	set plaintext(plaintext) {
		this.$$set({ plaintext });
		SvelteInternal.flush();
	}

	get readonly() {
		return this.$$.ctx[15];
	}

	set readonly(readonly) {
		this.$$set({ readonly });
		SvelteInternal.flush();
	}

	get reverse() {
		return this.$$.ctx[16];
	}

	set reverse(reverse) {
		this.$$set({ reverse });
		SvelteInternal.flush();
	}

	get size() {
		return this.$$.ctx[1];
	}

	set size(size) {
		this.$$set({ size });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[17];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}

	get type() {
		return this.$$.ctx[18];
	}

	set type(type) {
		this.$$set({ type });
		SvelteInternal.flush();
	}

	get valid() {
		return this.$$.ctx[19];
	}

	set valid(valid) {
		this.$$set({ valid });
		SvelteInternal.flush();
	}

	get value() {
		return this.$$.ctx[6];
	}

	set value(value) {
		this.$$set({ value });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistInputGroupInputGroupSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$H(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	let div_levels = [
		/*$$restProps*/ ctx[2],
		{ class: /*classes*/ ctx[1] },
		{ "data-bs-theme": /*theme*/ ctx[0] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*theme*/ 1) && { "data-bs-theme": /*theme*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$H($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","size","theme"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { size = '' } = $$props;
	let { theme = null } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('size' in $$new_props) $$invalidate(4, size = $$new_props.size);
		if ('theme' in $$new_props) $$invalidate(0, theme = $$new_props.theme);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, size*/ 24) {
			$$invalidate(1, classes = classnames(className, 'input-group', size ? `input-group-${size}` : null));
		}
	};

	return [theme, classes, $$restProps, className, size, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistInputGroupInputGroupSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$H, create_fragment$H, SvelteInternal.safe_not_equal, { class: 3, size: 4, theme: 0 });
	}

	get class() {
		return this.$$.ctx[3];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get size() {
		return this.$$.ctx[4];
	}

	set size(size) {
		this.$$set({ size });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[0];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistInputGroupTextInputGroupTextSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$G(ctx) {
	let span;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let span_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = SvelteInternal.assign(span_data, span_levels[i]);
	}

	return {
		c() {
			span = SvelteInternal.element("span");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(span, span_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(span, span_data = SvelteInternal.get_spread_update(span_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(span);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$G($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'input-group-text'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistInputGroupTextInputGroupTextSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$G, create_fragment$G, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistJumbotronJumbotronSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$F(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.attr(div, "class", /*classes*/ ctx[0]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				SvelteInternal.attr(div, "class", /*classes*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$F($$self, $$props, $$invalidate) {
	let classes;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(1, className = $$props.class);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 2) {
			$$invalidate(0, classes = classnames(className, 'p-5 mb-4 bg-light rounded-3'));
		}
	};

	return [classes, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistJumbotronJumbotronSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$F, create_fragment$F, SvelteInternal.safe_not_equal, { class: 1 });
	}

	get class() {
		return this.$$.ctx[1];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistLabelLabelSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$E(ctx) {
	let label;
	let current;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	let label_levels = [
		/*$$restProps*/ ctx[2],
		{ class: /*classes*/ ctx[1] },
		{ for: /*fore*/ ctx[0] }
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = SvelteInternal.assign(label_data, label_levels[i]);
	}

	return {
		c() {
			label = SvelteInternal.element("label");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(label, label_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, label, anchor);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(label, label_data = SvelteInternal.get_spread_update(label_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*fore*/ 1) && { for: /*fore*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(label);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$E($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","hidden","check","size","for","xs","sm","md","lg","xl","xxl","widths"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { hidden = false } = $$props;
	let { check = false } = $$props;
	let { size = '' } = $$props;
	let { for: fore = null } = $$props;
	let { xs = '' } = $$props;
	let { sm = '' } = $$props;
	let { md = '' } = $$props;
	let { lg = '' } = $$props;
	let { xl = '' } = $$props;
	let { xxl = '' } = $$props;
	const colWidths = { xs, sm, md, lg, xl, xxl };
	let { widths = Object.keys(colWidths) } = $$props;
	const colClasses = [];

	widths.forEach(colWidth => {
		let columnProp = $$props[colWidth];

		if (!columnProp && columnProp !== '') {
			return;
		}

		const isXs = colWidth === 'xs';
		let colClass;

		if (isObject(columnProp)) {
			const colSizeInterfix = isXs ? '-' : `-${colWidth}-`;
			colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);

			colClasses.push(classnames({
				[colClass]: columnProp.size || columnProp.size === '',
				[`order${colSizeInterfix}${columnProp.order}`]: columnProp.order || columnProp.order === 0,
				[`offset${colSizeInterfix}${columnProp.offset}`]: columnProp.offset || columnProp.offset === 0
			}));
		} else {
			colClass = getColumnSizeClass(isXs, colWidth, columnProp);
			colClasses.push(colClass);
		}
	});

	$$self.$$set = $$new_props => {
		$$invalidate(18, $$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('hidden' in $$new_props) $$invalidate(4, hidden = $$new_props.hidden);
		if ('check' in $$new_props) $$invalidate(5, check = $$new_props.check);
		if ('size' in $$new_props) $$invalidate(6, size = $$new_props.size);
		if ('for' in $$new_props) $$invalidate(0, fore = $$new_props.for);
		if ('xs' in $$new_props) $$invalidate(7, xs = $$new_props.xs);
		if ('sm' in $$new_props) $$invalidate(8, sm = $$new_props.sm);
		if ('md' in $$new_props) $$invalidate(9, md = $$new_props.md);
		if ('lg' in $$new_props) $$invalidate(10, lg = $$new_props.lg);
		if ('xl' in $$new_props) $$invalidate(11, xl = $$new_props.xl);
		if ('xxl' in $$new_props) $$invalidate(12, xxl = $$new_props.xxl);
		if ('widths' in $$new_props) $$invalidate(13, widths = $$new_props.widths);
		if ('$$scope' in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, hidden, check, size*/ 120) {
			$$invalidate(1, classes = classnames(className, hidden ? 'visually-hidden' : false, check ? 'form-check-label' : false, size ? `col-form-label-${size}` : false, colClasses, colClasses.length ? 'col-form-label' : 'form-label'));
		}
	};

	$$props = SvelteInternal.exclude_internal_props($$props);

	return [
		fore,
		classes,
		$$restProps,
		className,
		hidden,
		check,
		size,
		xs,
		sm,
		md,
		lg,
		xl,
		xxl,
		widths,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistLabelLabelSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$E, create_fragment$E, SvelteInternal.safe_not_equal, {
			class: 3,
			hidden: 4,
			check: 5,
			size: 6,
			for: 0,
			xs: 7,
			sm: 8,
			md: 9,
			lg: 10,
			xl: 11,
			xxl: 12,
			widths: 13
		});
	}

	get class() {
		return this.$$.ctx[3];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get hidden() {
		return this.$$.ctx[4];
	}

	set hidden(hidden) {
		this.$$set({ hidden });
		SvelteInternal.flush();
	}

	get check() {
		return this.$$.ctx[5];
	}

	set check(check) {
		this.$$set({ check });
		SvelteInternal.flush();
	}

	get size() {
		return this.$$.ctx[6];
	}

	set size(size) {
		this.$$set({ size });
		SvelteInternal.flush();
	}

	get for() {
		return this.$$.ctx[0];
	}

	set for(fore) {
		this.$$set({ for: fore });
		SvelteInternal.flush();
	}

	get xs() {
		return this.$$.ctx[7];
	}

	set xs(xs) {
		this.$$set({ xs });
		SvelteInternal.flush();
	}

	get sm() {
		return this.$$.ctx[8];
	}

	set sm(sm) {
		this.$$set({ sm });
		SvelteInternal.flush();
	}

	get md() {
		return this.$$.ctx[9];
	}

	set md(md) {
		this.$$set({ md });
		SvelteInternal.flush();
	}

	get lg() {
		return this.$$.ctx[10];
	}

	set lg(lg) {
		this.$$set({ lg });
		SvelteInternal.flush();
	}

	get xl() {
		return this.$$.ctx[11];
	}

	set xl(xl) {
		this.$$set({ xl });
		SvelteInternal.flush();
	}

	get xxl() {
		return this.$$.ctx[12];
	}

	set xxl(xxl) {
		this.$$set({ xxl });
		SvelteInternal.flush();
	}

	get widths() {
		return this.$$.ctx[13];
	}

	set widths(widths) {
		this.$$set({ widths });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistListGroupListGroupSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block$f(ctx) {
	let ul;
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	let ul_levels = [
		/*$$restProps*/ ctx[3],
		{ class: /*classes*/ ctx[2] },
		{ "data-bs-theme": /*theme*/ ctx[1] }
	];

	let ul_data = {};

	for (let i = 0; i < ul_levels.length; i += 1) {
		ul_data = SvelteInternal.assign(ul_data, ul_levels[i]);
	}

	return {
		c() {
			ul = SvelteInternal.element("ul");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(ul, ul_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(ul, ul_data = SvelteInternal.get_spread_update(ul_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				(!current || dirty & /*theme*/ 2) && { "data-bs-theme": /*theme*/ ctx[1] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(ul);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (44:0) {#if numbered}
function create_if_block$i(ctx) {
	let ol;
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	let ol_levels = [
		/*$$restProps*/ ctx[3],
		{ class: /*classes*/ ctx[2] },
		{ "data-bs-theme": /*theme*/ ctx[1] }
	];

	let ol_data = {};

	for (let i = 0; i < ol_levels.length; i += 1) {
		ol_data = SvelteInternal.assign(ol_data, ol_levels[i]);
	}

	return {
		c() {
			ol = SvelteInternal.element("ol");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(ol, ol_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, ol, anchor);

			if (default_slot) {
				default_slot.m(ol, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(ol, ol_data = SvelteInternal.get_spread_update(ol_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				(!current || dirty & /*theme*/ 2) && { "data-bs-theme": /*theme*/ ctx[1] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(ol);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$D(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$i, create_else_block$f];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*numbered*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$D($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","flush","horizontal","numbered","theme"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { flush = false } = $$props;
	let { horizontal = false } = $$props;
	let { numbered = false } = $$props;
	let { theme = null } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('flush' in $$new_props) $$invalidate(5, flush = $$new_props.flush);
		if ('horizontal' in $$new_props) $$invalidate(6, horizontal = $$new_props.horizontal);
		if ('numbered' in $$new_props) $$invalidate(0, numbered = $$new_props.numbered);
		if ('theme' in $$new_props) $$invalidate(1, theme = $$new_props.theme);
		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, flush, horizontal, numbered*/ 113) {
			$$invalidate(2, classes = classnames(className, 'list-group', {
				'list-group-flush': flush,
				'list-group-horizontal': horizontal,
				'list-group-numbered': numbered
			}));
		}
	};

	return [
		numbered,
		theme,
		classes,
		$$restProps,
		className,
		flush,
		horizontal,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistListGroupListGroupSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$D, create_fragment$D, SvelteInternal.safe_not_equal, {
			class: 4,
			flush: 5,
			horizontal: 6,
			numbered: 0,
			theme: 1
		});
	}

	get class() {
		return this.$$.ctx[4];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get flush() {
		return this.$$.ctx[5];
	}

	set flush(flush) {
		this.$$set({ flush });
		SvelteInternal.flush();
	}

	get horizontal() {
		return this.$$.ctx[6];
	}

	set horizontal(horizontal) {
		this.$$set({ horizontal });
		SvelteInternal.flush();
	}

	get numbered() {
		return this.$$.ctx[0];
	}

	set numbered(numbered) {
		this.$$set({ numbered });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[1];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistListGroupItemListGroupItemSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block$e(ctx) {
	let li;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	let li_levels = [
		/*$$restProps*/ ctx[5],
		{ class: /*classes*/ ctx[4] },
		{ disabled: /*disabled*/ ctx[1] },
		{ active: /*active*/ ctx[0] }
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = SvelteInternal.assign(li_data, li_levels[i]);
	}

	return {
		c() {
			li = SvelteInternal.element("li");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(li, li_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, li, anchor);

			if (default_slot) {
				default_slot.m(li, null);
			}

			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(li, "click", /*click_handler_2*/ ctx[13]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(li, li_data = SvelteInternal.get_spread_update(li_levels, [
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				(!current || dirty & /*disabled*/ 2) && { disabled: /*disabled*/ ctx[1] },
				(!current || dirty & /*active*/ 1) && { active: /*active*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(li);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (25:27) 
function create_if_block_1$a(ctx) {
	let button;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	let button_levels = [
		/*$$restProps*/ ctx[5],
		{ class: /*classes*/ ctx[4] },
		{ type: "button" },
		{ disabled: /*disabled*/ ctx[1] },
		{ active: /*active*/ ctx[0] }
	];

	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = SvelteInternal.assign(button_data, button_levels[i]);
	}

	return {
		c() {
			button = SvelteInternal.element("button");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(button, button_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			if (button.autofocus) button.focus();
			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(button, "click", /*click_handler_1*/ ctx[12]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(button, button_data = SvelteInternal.get_spread_update(button_levels, [
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				{ type: "button" },
				(!current || dirty & /*disabled*/ 2) && { disabled: /*disabled*/ ctx[1] },
				(!current || dirty & /*active*/ 1) && { active: /*active*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(button);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (21:0) {#if href}
function create_if_block$h(ctx) {
	let a;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	let a_levels = [
		/*$$restProps*/ ctx[5],
		{ class: /*classes*/ ctx[4] },
		{ href: /*href*/ ctx[2] },
		{ disabled: /*disabled*/ ctx[1] },
		{ active: /*active*/ ctx[0] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = SvelteInternal.assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = SvelteInternal.element("a");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(a, a_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(a, "click", /*click_handler*/ ctx[11]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(a, a_data = SvelteInternal.get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				(!current || dirty & /*href*/ 4) && { href: /*href*/ ctx[2] },
				(!current || dirty & /*disabled*/ 2) && { disabled: /*disabled*/ ctx[1] },
				(!current || dirty & /*active*/ 1) && { active: /*active*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(a);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$C(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$h, create_if_block_1$a, create_else_block$e];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[2]) return 0;
		if (/*tag*/ ctx[3] === 'button') return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$C($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","active","disabled","color","action","href","tag"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { active = false } = $$props;
	let { disabled = false } = $$props;
	let { color = '' } = $$props;
	let { action = false } = $$props;
	let { href = null } = $$props;
	let { tag = null } = $$props;

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function click_handler_1(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	function click_handler_2(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(5, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('active' in $$new_props) $$invalidate(0, active = $$new_props.active);
		if ('disabled' in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
		if ('color' in $$new_props) $$invalidate(7, color = $$new_props.color);
		if ('action' in $$new_props) $$invalidate(8, action = $$new_props.action);
		if ('href' in $$new_props) $$invalidate(2, href = $$new_props.href);
		if ('tag' in $$new_props) $$invalidate(3, tag = $$new_props.tag);
		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, active, disabled, action, tag, color*/ 459) {
			$$invalidate(4, classes = classnames(className, 'list-group-item', {
				active,
				disabled,
				'list-group-item-action': action || tag === 'button',
				[`list-group-item-${color}`]: color
			}));
		}
	};

	return [
		active,
		disabled,
		href,
		tag,
		classes,
		$$restProps,
		className,
		color,
		action,
		$$scope,
		slots,
		click_handler,
		click_handler_1,
		click_handler_2
	];
}

class NodeModulesSveltestrapSveltestrapDistListGroupItemListGroupItemSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$C, create_fragment$C, SvelteInternal.safe_not_equal, {
			class: 6,
			active: 0,
			disabled: 1,
			color: 7,
			action: 8,
			href: 2,
			tag: 3
		});
	}

	get class() {
		return this.$$.ctx[6];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get active() {
		return this.$$.ctx[0];
	}

	set active(active) {
		this.$$set({ active });
		SvelteInternal.flush();
	}

	get disabled() {
		return this.$$.ctx[1];
	}

	set disabled(disabled) {
		this.$$set({ disabled });
		SvelteInternal.flush();
	}

	get color() {
		return this.$$.ctx[7];
	}

	set color(color) {
		this.$$set({ color });
		SvelteInternal.flush();
	}

	get action() {
		return this.$$.ctx[8];
	}

	set action(action) {
		this.$$set({ action });
		SvelteInternal.flush();
	}

	get href() {
		return this.$$.ctx[2];
	}

	set href(href) {
		this.$$set({ href });
		SvelteInternal.flush();
	}

	get tag() {
		return this.$$.ctx[3];
	}

	set tag(tag) {
		this.$$set({ tag });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistModalBackdropModalBackdropSvelte.svelte generated by Svelte v4.2.8 */


function create_if_block$g(ctx) {
	let div;
	let div_intro;
	let div_outro;
	let current;
	let mounted;
	let dispose;

	let div_levels = [
		{ role: "presentation" },
		/*$$restProps*/ ctx[4],
		{ class: /*classes*/ ctx[3] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			SvelteInternal.set_attributes(div, div_data);
			SvelteInternal.toggle_class(div, "fade", /*fade*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(div, "click", /*click_handler*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				{ role: "presentation" },
				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
			]));

			SvelteInternal.toggle_class(div, "fade", /*fade*/ ctx[1]);
		},
		i(local) {
			if (current) return;

			if (local) {
				SvelteInternal.add_render_callback(() => {
					if (!current) return;
					if (div_outro) div_outro.end(1);
					div_intro = SvelteInternal.create_in_transition(div, backdropIn, {});
					div_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			if (div_intro) div_intro.invalidate();

			if (local) {
				div_outro = SvelteInternal.create_out_transition(div, backdropOut, {});
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (detaching && div_outro) div_outro.end();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$B(ctx) {
	let if_block_anchor;
	let if_block = /*isOpen*/ ctx[0] && /*loaded*/ ctx[2] && create_if_block$g(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0] && /*loaded*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen, loaded*/ 5) {
						SvelteInternal.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$g(ctx);
					if_block.c();
					SvelteInternal.transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				SvelteInternal.check_outros();
			}
		},
		i(local) {
			SvelteInternal.transition_in(if_block);
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function instance$B($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","isOpen","fade"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { class: className = '' } = $$props;
	let { isOpen = false } = $$props;
	let { fade = true } = $$props;
	let loaded = false;

	SvelteInternal.onMount(() => {
		$$invalidate(2, loaded = true);
	});

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ('fade' in $$new_props) $$invalidate(1, fade = $$new_props.fade);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 32) {
			$$invalidate(3, classes = classnames(className, 'modal-backdrop'));
		}
	};

	return [isOpen, fade, loaded, classes, $$restProps, className, click_handler];
}

class NodeModulesSveltestrapSveltestrapDistModalBackdropModalBackdropSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$B, create_fragment$B, SvelteInternal.safe_not_equal, { class: 5, isOpen: 0, fade: 1 });
	}

	get class() {
		return this.$$.ctx[5];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get isOpen() {
		return this.$$.ctx[0];
	}

	set isOpen(isOpen) {
		this.$$set({ isOpen });
		SvelteInternal.flush();
	}

	get fade() {
		return this.$$.ctx[1];
	}

	set fade(fade) {
		this.$$set({ fade });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistModalBodyModalBodySvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$A(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$A($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'modal-body'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistModalBodyModalBodySvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$A, create_fragment$A, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistModalHeaderModalHeaderSvelte.svelte generated by Svelte v4.2.8 */

const get_close_slot_changes$2 = dirty => ({});
const get_close_slot_context$2 = ctx => ({});

// (38:4) {:else}
function create_else_block$d(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (36:4) {#if children}
function create_if_block_1$9(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*children*/ ctx[3]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 8) SvelteInternal.set_data(t, /*children*/ ctx[3]);
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (43:4) {#if typeof toggle === 'function'}
function create_if_block$f(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = SvelteInternal.element("button");
			SvelteInternal.attr(button, "type", "button");
			SvelteInternal.attr(button, "class", "btn-close");
			SvelteInternal.attr(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, button, anchor);

			if (!mounted) {
				dispose = SvelteInternal.listen(button, "click", function () {
					if (SvelteInternal.is_function(/*toggle*/ ctx[0])) /*toggle*/ ctx[0].apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*closeAriaLabel*/ 2) {
				SvelteInternal.attr(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (42:21)      
function fallback_block$6(ctx) {
	let if_block_anchor;
	let if_block = typeof /*toggle*/ ctx[0] === 'function' && create_if_block$f(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (typeof /*toggle*/ ctx[0] === 'function') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$f(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function create_fragment$z(ctx) {
	let div;
	let h5;
	let current_block_type_index;
	let if_block;
	let t;
	let current;
	const if_block_creators = [create_if_block_1$9, create_else_block$d];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[3]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const close_slot_template = /*#slots*/ ctx[8].close;
	const close_slot = SvelteInternal.create_slot(close_slot_template, ctx, /*$$scope*/ ctx[7], get_close_slot_context$2);
	const close_slot_or_fallback = close_slot || fallback_block$6(ctx);
	let div_levels = [/*$$restProps*/ ctx[5], { class: /*classes*/ ctx[4] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			h5 = SvelteInternal.element("h5");
			if_block.c();
			t = SvelteInternal.space();
			if (close_slot_or_fallback) close_slot_or_fallback.c();
			SvelteInternal.attr(h5, "class", "modal-title");
			SvelteInternal.attr(h5, "id", /*id*/ ctx[2]);
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			SvelteInternal.append(div, h5);
			if_blocks[current_block_type_index].m(h5, null);
			SvelteInternal.append(div, t);

			if (close_slot_or_fallback) {
				close_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(h5, null);
			}

			if (!current || dirty & /*id*/ 4) {
				SvelteInternal.attr(h5, "id", /*id*/ ctx[2]);
			}

			if (close_slot) {
				if (close_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					SvelteInternal.update_slot_base(
						close_slot,
						close_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: SvelteInternal.get_slot_changes(close_slot_template, /*$$scope*/ ctx[7], dirty, get_close_slot_changes$2),
						get_close_slot_context$2
					);
				}
			} else {
				if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & /*closeAriaLabel, toggle*/ 3)) {
					close_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			SvelteInternal.transition_in(close_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			SvelteInternal.transition_out(close_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if_blocks[current_block_type_index].d();
			if (close_slot_or_fallback) close_slot_or_fallback.d(detaching);
		}
	};
}

function instance$z($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","toggle","closeAriaLabel","id","children"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { toggle = undefined } = $$props;
	let { closeAriaLabel = 'Close' } = $$props;
	let { id = undefined } = $$props;
	let { children = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(5, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('toggle' in $$new_props) $$invalidate(0, toggle = $$new_props.toggle);
		if ('closeAriaLabel' in $$new_props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
		if ('id' in $$new_props) $$invalidate(2, id = $$new_props.id);
		if ('children' in $$new_props) $$invalidate(3, children = $$new_props.children);
		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 64) {
			$$invalidate(4, classes = classnames(className, 'modal-header'));
		}
	};

	return [
		toggle,
		closeAriaLabel,
		id,
		children,
		classes,
		$$restProps,
		className,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistModalHeaderModalHeaderSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$z, create_fragment$z, SvelteInternal.safe_not_equal, {
			class: 6,
			toggle: 0,
			closeAriaLabel: 1,
			id: 2,
			children: 3
		});
	}

	get class() {
		return this.$$.ctx[6];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get toggle() {
		return this.$$.ctx[0];
	}

	set toggle(toggle) {
		this.$$set({ toggle });
		SvelteInternal.flush();
	}

	get closeAriaLabel() {
		return this.$$.ctx[1];
	}

	set closeAriaLabel(closeAriaLabel) {
		this.$$set({ closeAriaLabel });
		SvelteInternal.flush();
	}

	get id() {
		return this.$$.ctx[2];
	}

	set id(id) {
		this.$$set({ id });
		SvelteInternal.flush();
	}

	get children() {
		return this.$$.ctx[3];
	}

	set children(children) {
		this.$$set({ children });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistPortalPortalSvelte.svelte generated by Svelte v4.2.8 */





function create_fragment$y(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);
	let div_levels = [/*$$restProps*/ ctx[1]];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[4](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[4](null);
		}
	};
}

function instance$y($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let ref;
	let portal;

	SvelteInternal.onMount(() => {
		portal = document.createElement('div');
		document.body.appendChild(portal);
		portal.appendChild(ref);
	});

	SvelteInternal.onDestroy(() => {
		if (portal) {
			document.body.removeChild(portal);
		}
	});

	function div_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('$$scope' in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
	};

	return [ref, $$restProps, $$scope, slots, div_binding];
}

class NodeModulesSveltestrapSveltestrapDistPortalPortalSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$y, create_fragment$y, SvelteInternal.safe_not_equal, {});
	}
}

function add_css$2(target) {
	SvelteInternal.append_styles(target, "svelte-d87gpn", ".modal-open{overflow:hidden;padding-right:0}");
}

const get_external_slot_changes = dirty => ({});
const get_external_slot_context = ctx => ({});

// (323:0) {#if _isMounted}
function create_if_block_1$8(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*outer*/ ctx[15];

	function switch_props(ctx, dirty) {
		return {
			props: {
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			}
		};
	}

	if (switch_value) {
		switch_instance = SvelteInternal.construct_svelte_component(switch_value, switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) SvelteInternal.create_component(switch_instance.$$.fragment);
			switch_instance_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (switch_instance) SvelteInternal.mount_component(switch_instance, target, anchor);
			SvelteInternal.insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*outer*/ 32768 && switch_value !== (switch_value = /*outer*/ ctx[15])) {
				if (switch_instance) {
					SvelteInternal.group_outros();
					const old_component = switch_instance;

					SvelteInternal.transition_out(old_component.$$.fragment, 1, 0, () => {
						SvelteInternal.destroy_component(old_component, 1);
					});

					SvelteInternal.check_outros();
				}

				if (switch_value) {
					switch_instance = SvelteInternal.construct_svelte_component(switch_value, switch_props(ctx));
					SvelteInternal.create_component(switch_instance.$$.fragment);
					SvelteInternal.transition_in(switch_instance.$$.fragment, 1);
					SvelteInternal.mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				const switch_instance_changes = {};

				if (dirty[0] & /*wrapClassName, $$restProps, theme, modalStyle, labelledBy, modalClassName, fade, staticModal, classes, _dialog, contentClassName, body, toggle, header, isOpen*/ 8478703 | dirty[1] & /*$$scope*/ 64) {
					switch_instance_changes.$$scope = { dirty, ctx };
				}

				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) SvelteInternal.transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) SvelteInternal.transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(switch_instance_anchor);
			}

			if (switch_instance) SvelteInternal.destroy_component(switch_instance, detaching);
		}
	};
}

// (327:6) {#if isOpen}
function create_if_block_2$3(ctx) {
	let div2;
	let t0;
	let div1;
	let div0;
	let t1;
	let current_block_type_index;
	let if_block1;
	let div0_class_value;
	let div2_class_value;
	let div2_intro;
	let div2_outro;
	let current;
	let mounted;
	let dispose;
	const external_slot_template = /*#slots*/ ctx[34].external;
	const external_slot = SvelteInternal.create_slot(external_slot_template, ctx, /*$$scope*/ ctx[37], get_external_slot_context);
	let if_block0 = /*header*/ ctx[2] && create_if_block_4(ctx);
	const if_block_creators = [create_if_block_3$1, create_else_block$c];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*body*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div2 = SvelteInternal.element("div");
			if (external_slot) external_slot.c();
			t0 = SvelteInternal.space();
			div1 = SvelteInternal.element("div");
			div0 = SvelteInternal.element("div");
			if (if_block0) if_block0.c();
			t1 = SvelteInternal.space();
			if_block1.c();
			SvelteInternal.attr(div0, "class", div0_class_value = classnames('modal-content', /*contentClassName*/ ctx[5]));
			SvelteInternal.attr(div1, "class", /*classes*/ ctx[16]);
			SvelteInternal.attr(div1, "role", "document");
			SvelteInternal.attr(div2, "style", /*modalStyle*/ ctx[9]);
			SvelteInternal.attr(div2, "aria-labelledby", /*labelledBy*/ ctx[7]);

			SvelteInternal.attr(div2, "class", div2_class_value = classnames('modal', /*modalClassName*/ ctx[8], {
				fade: /*fade*/ ctx[6],
				'position-static': /*staticModal*/ ctx[0]
			}));

			SvelteInternal.attr(div2, "role", "dialog");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div2, anchor);

			if (external_slot) {
				external_slot.m(div2, null);
			}

			SvelteInternal.append(div2, t0);
			SvelteInternal.append(div2, div1);
			SvelteInternal.append(div1, div0);
			if (if_block0) if_block0.m(div0, null);
			SvelteInternal.append(div0, t1);
			if_blocks[current_block_type_index].m(div0, null);
			/*div1_binding*/ ctx[35](div1);
			current = true;

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(div2, "introstart", /*introstart_handler*/ ctx[36]),
					SvelteInternal.listen(div2, "introend", /*onModalOpened*/ ctx[19]),
					SvelteInternal.listen(div2, "outrostart", /*onModalClosing*/ ctx[20]),
					SvelteInternal.listen(div2, "outroend", /*onModalClosed*/ ctx[21]),
					SvelteInternal.listen(div2, "click", /*handleBackdropClick*/ ctx[18]),
					SvelteInternal.listen(div2, "mousedown", /*handleBackdropMouseDown*/ ctx[22])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (external_slot) {
				if (external_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					SvelteInternal.update_slot_base(
						external_slot,
						external_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: SvelteInternal.get_slot_changes(external_slot_template, /*$$scope*/ ctx[37], dirty, get_external_slot_changes),
						get_external_slot_context
					);
				}
			}

			if (/*header*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*header*/ 4) {
						SvelteInternal.transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					SvelteInternal.transition_in(if_block0, 1);
					if_block0.m(div0, t1);
				}
			} else if (if_block0) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				SvelteInternal.check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block1, 1);
				if_block1.m(div0, null);
			}

			if (!current || dirty[0] & /*contentClassName*/ 32 && div0_class_value !== (div0_class_value = classnames('modal-content', /*contentClassName*/ ctx[5]))) {
				SvelteInternal.attr(div0, "class", div0_class_value);
			}

			if (!current || dirty[0] & /*classes*/ 65536) {
				SvelteInternal.attr(div1, "class", /*classes*/ ctx[16]);
			}

			if (!current || dirty[0] & /*modalStyle*/ 512) {
				SvelteInternal.attr(div2, "style", /*modalStyle*/ ctx[9]);
			}

			if (!current || dirty[0] & /*labelledBy*/ 128) {
				SvelteInternal.attr(div2, "aria-labelledby", /*labelledBy*/ ctx[7]);
			}

			if (!current || dirty[0] & /*modalClassName, fade, staticModal*/ 321 && div2_class_value !== (div2_class_value = classnames('modal', /*modalClassName*/ ctx[8], {
				fade: /*fade*/ ctx[6],
				'position-static': /*staticModal*/ ctx[0]
			}))) {
				SvelteInternal.attr(div2, "class", div2_class_value);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(external_slot, local);
			SvelteInternal.transition_in(if_block0);
			SvelteInternal.transition_in(if_block1);

			SvelteInternal.add_render_callback(() => {
				if (!current) return;
				if (div2_outro) div2_outro.end(1);
				div2_intro = SvelteInternal.create_in_transition(div2, modalIn, {});
				div2_intro.start();
			});

			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(external_slot, local);
			SvelteInternal.transition_out(if_block0);
			SvelteInternal.transition_out(if_block1);
			if (div2_intro) div2_intro.invalidate();
			div2_outro = SvelteInternal.create_out_transition(div2, modalOut, {});
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div2);
			}

			if (external_slot) external_slot.d(detaching);
			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			/*div1_binding*/ ctx[35](null);
			if (detaching && div2_outro) div2_outro.end();
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (349:14) {#if header}
function create_if_block_4(ctx) {
	let modalheader;
	let current;

	modalheader = new NodeModulesSveltestrapSveltestrapDistModalHeaderModalHeaderSvelte({
			props: {
				toggle: /*toggle*/ ctx[11],
				id: /*labelledBy*/ ctx[7],
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			SvelteInternal.create_component(modalheader.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(modalheader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const modalheader_changes = {};
			if (dirty[0] & /*toggle*/ 2048) modalheader_changes.toggle = /*toggle*/ ctx[11];
			if (dirty[0] & /*labelledBy*/ 128) modalheader_changes.id = /*labelledBy*/ ctx[7];

			if (dirty[0] & /*header*/ 4 | dirty[1] & /*$$scope*/ 64) {
				modalheader_changes.$$scope = { dirty, ctx };
			}

			modalheader.$set(modalheader_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(modalheader.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(modalheader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(modalheader, detaching);
		}
	};
}

// (350:16) <ModalHeader {toggle} id={labelledBy}>
function create_default_slot_3$1(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*header*/ ctx[2]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*header*/ 4) SvelteInternal.set_data(t, /*header*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (358:14) {:else}
function create_else_block$c(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[34].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[37], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[37], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (354:14) {#if body}
function create_if_block_3$1(ctx) {
	let modalbody;
	let current;

	modalbody = new NodeModulesSveltestrapSveltestrapDistModalBodyModalBodySvelte({
			props: {
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			SvelteInternal.create_component(modalbody.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(modalbody, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const modalbody_changes = {};

			if (dirty[1] & /*$$scope*/ 64) {
				modalbody_changes.$$scope = { dirty, ctx };
			}

			modalbody.$set(modalbody_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(modalbody.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(modalbody.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(modalbody, detaching);
		}
	};
}

// (355:16) <ModalBody>
function create_default_slot_2$2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[34].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[37], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[37], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (324:2) <svelte:component this={outer}>
function create_default_slot_1$4(ctx) {
	let div;
	let current;
	let if_block = /*isOpen*/ ctx[3] && create_if_block_2$3(ctx);

	let div_levels = [
		{ class: /*wrapClassName*/ ctx[12] },
		{ tabindex: "-1" },
		/*$$restProps*/ ctx[23],
		{ "data-bs-theme": /*theme*/ ctx[10] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (if_block) if_block.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*isOpen*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*isOpen*/ 8) {
						SvelteInternal.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$3(ctx);
					if_block.c();
					SvelteInternal.transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				SvelteInternal.check_outros();
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				(!current || dirty[0] & /*wrapClassName*/ 4096) && { class: /*wrapClassName*/ ctx[12] },
				{ tabindex: "-1" },
				dirty[0] & /*$$restProps*/ 8388608 && /*$$restProps*/ ctx[23],
				(!current || dirty[0] & /*theme*/ 1024) && { "data-bs-theme": /*theme*/ ctx[10] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (if_block) if_block.d();
		}
	};
}

// (369:0) {#if backdrop && !staticModal}
function create_if_block$e(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*outer*/ ctx[15];

	function switch_props(ctx, dirty) {
		return {
			props: {
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			}
		};
	}

	if (switch_value) {
		switch_instance = SvelteInternal.construct_svelte_component(switch_value, switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) SvelteInternal.create_component(switch_instance.$$.fragment);
			switch_instance_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (switch_instance) SvelteInternal.mount_component(switch_instance, target, anchor);
			SvelteInternal.insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*outer*/ 32768 && switch_value !== (switch_value = /*outer*/ ctx[15])) {
				if (switch_instance) {
					SvelteInternal.group_outros();
					const old_component = switch_instance;

					SvelteInternal.transition_out(old_component.$$.fragment, 1, 0, () => {
						SvelteInternal.destroy_component(old_component, 1);
					});

					SvelteInternal.check_outros();
				}

				if (switch_value) {
					switch_instance = SvelteInternal.construct_svelte_component(switch_value, switch_props(ctx));
					SvelteInternal.create_component(switch_instance.$$.fragment);
					SvelteInternal.transition_in(switch_instance.$$.fragment, 1);
					SvelteInternal.mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				const switch_instance_changes = {};

				if (dirty[0] & /*fade, isOpen*/ 72 | dirty[1] & /*$$scope*/ 64) {
					switch_instance_changes.$$scope = { dirty, ctx };
				}

				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) SvelteInternal.transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) SvelteInternal.transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(switch_instance_anchor);
			}

			if (switch_instance) SvelteInternal.destroy_component(switch_instance, detaching);
		}
	};
}

// (370:2) <svelte:component this={outer}>
function create_default_slot$9(ctx) {
	let modalbackdrop;
	let current;

	modalbackdrop = new NodeModulesSveltestrapSveltestrapDistModalBackdropModalBackdropSvelte({
			props: {
				fade: /*fade*/ ctx[6],
				isOpen: /*isOpen*/ ctx[3]
			}
		});

	return {
		c() {
			SvelteInternal.create_component(modalbackdrop.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(modalbackdrop, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const modalbackdrop_changes = {};
			if (dirty[0] & /*fade*/ 64) modalbackdrop_changes.fade = /*fade*/ ctx[6];
			if (dirty[0] & /*isOpen*/ 8) modalbackdrop_changes.isOpen = /*isOpen*/ ctx[3];
			modalbackdrop.$set(modalbackdrop_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(modalbackdrop.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(modalbackdrop.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(modalbackdrop, detaching);
		}
	};
}

function create_fragment$x(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*_isMounted*/ ctx[13] && create_if_block_1$8(ctx);
	let if_block1 = /*backdrop*/ ctx[4] && !/*staticModal*/ ctx[0] && create_if_block$e(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = SvelteInternal.space();
			if (if_block1) if_block1.c();
			if_block1_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			SvelteInternal.insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			SvelteInternal.insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*_isMounted*/ ctx[13]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*_isMounted*/ 8192) {
						SvelteInternal.transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$8(ctx);
					if_block0.c();
					SvelteInternal.transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				SvelteInternal.check_outros();
			}

			if (/*backdrop*/ ctx[4] && !/*staticModal*/ ctx[0]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*backdrop, staticModal*/ 17) {
						SvelteInternal.transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$e(ctx);
					if_block1.c();
					SvelteInternal.transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				SvelteInternal.check_outros();
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block0);
			SvelteInternal.transition_in(if_block1);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block0);
			SvelteInternal.transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
				SvelteInternal.detach(if_block1_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d(detaching);
		}
	};
}

let openCount = 0;
const dialogBaseClass = 'modal-dialog';

function instance$x($$self, $$props, $$invalidate) {
	let classes;
	let outer;

	const omit_props_names = [
		"class","static","autoFocus","body","centered","container","fullscreen","header","isOpen","keyboard","backdrop","contentClassName","fade","labelledBy","modalClassName","modalStyle","returnFocusAfterClose","scrollable","size","theme","toggle","unmountOnClose","wrapClassName"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = SvelteInternal.createEventDispatcher();
	let { class: className = '' } = $$props;
	let { static: staticModal = false } = $$props;
	let { autoFocus = true } = $$props;
	let { body = false } = $$props;
	let { centered = false } = $$props;
	let { container = undefined } = $$props;
	let { fullscreen = false } = $$props;
	let { header = undefined } = $$props;
	let { isOpen = false } = $$props;
	let { keyboard = true } = $$props;
	let { backdrop = true } = $$props;
	let { contentClassName = '' } = $$props;
	let { fade = true } = $$props;
	let { labelledBy = header ? `modal-${uuid()}` : undefined } = $$props;
	let { modalClassName = '' } = $$props;
	let { modalStyle = null } = $$props;
	let { returnFocusAfterClose = true } = $$props;
	let { scrollable = false } = $$props;
	let { size = '' } = $$props;
	let { theme = null } = $$props;
	let { toggle = undefined } = $$props;
	let { unmountOnClose = true } = $$props;
	let { wrapClassName = '' } = $$props;
	let hasOpened = false;
	let _isMounted = false;
	let _triggeringElement;
	let _originalBodyPadding;
	let _lastIsOpen = isOpen;
	let _lastHasOpened = hasOpened;
	let _dialog;
	let _mouseDownElement;
	let _removeEscListener;

	SvelteInternal.onMount(() => {
		if (isOpen) {
			init();
			hasOpened = true;
		}

		if (hasOpened && autoFocus) {
			setFocus();
		}
	});

	SvelteInternal.onDestroy(() => {
		destroy();

		if (hasOpened) {
			close();
		}
	});

	SvelteInternal.afterUpdate(() => {
		if (isOpen && !_lastIsOpen) {
			init();
			hasOpened = true;
		}

		if (autoFocus && hasOpened && !_lastHasOpened) {
			setFocus();
		}

		_lastIsOpen = isOpen;
		_lastHasOpened = hasOpened;
	});

	function setFocus() {
		if (_dialog && _dialog.parentNode && typeof _dialog.parentNode.focus === 'function') {
			_dialog.parentNode.focus();
		}
	}

	function init() {
		try {
			_triggeringElement = document.activeElement;
		} catch(err) {
			_triggeringElement = null;
		}

		if (!staticModal) {
			_originalBodyPadding = getOriginalBodyPadding();
			conditionallyUpdateScrollbar();

			if (openCount === 0) {
				document.body.className = classnames(document.body.className, 'modal-open');
			}

			++openCount;
		}

		$$invalidate(13, _isMounted = true);
	}

	function manageFocusAfterClose() {
		if (_triggeringElement) {
			if (typeof _triggeringElement.focus === 'function' && returnFocusAfterClose) {
				_triggeringElement.focus();
			}

			_triggeringElement = null;
		}
	}

	function destroy() {
		manageFocusAfterClose();
	}

	function close() {
		if (openCount <= 1) {
			document.body.classList.remove('modal-open');
		}

		manageFocusAfterClose();
		openCount = Math.max(0, openCount - 1);
		setScrollbarWidth(_originalBodyPadding);
	}

	function handleBackdropClick(e) {
		if (e.target === _mouseDownElement) {
			if (!isOpen || !backdrop) {
				return;
			}

			const backdropElem = _dialog ? _dialog.parentNode : null;

			if (backdrop === true && backdropElem && e.target === backdropElem && toggle) {
				e.stopPropagation();
				toggle(e);
			}
		}
	}

	function onModalOpened() {
		dispatch('open');

		_removeEscListener = browserEvent(document, 'keydown', event => {
			if (event.key && event.key === 'Escape' && keyboard) {
				if (toggle && backdrop === true) {
					if (_removeEscListener) _removeEscListener();
					toggle(event);
				}
			}
		});
	}

	function onModalClosing() {
		dispatch('closing');

		if (_removeEscListener) {
			_removeEscListener();
		}
	}

	function onModalClosed() {
		dispatch('close');

		if (unmountOnClose) {
			destroy();
		}

		close();

		if (_isMounted) {
			hasOpened = false;
		}

		$$invalidate(13, _isMounted = false);
	}

	function handleBackdropMouseDown(e) {
		_mouseDownElement = e.target;
	}

	function div1_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			_dialog = $$value;
			$$invalidate(14, _dialog);
		});
	}

	const introstart_handler = () => dispatch('opening');

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(23, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(24, className = $$new_props.class);
		if ('static' in $$new_props) $$invalidate(0, staticModal = $$new_props.static);
		if ('autoFocus' in $$new_props) $$invalidate(25, autoFocus = $$new_props.autoFocus);
		if ('body' in $$new_props) $$invalidate(1, body = $$new_props.body);
		if ('centered' in $$new_props) $$invalidate(26, centered = $$new_props.centered);
		if ('container' in $$new_props) $$invalidate(27, container = $$new_props.container);
		if ('fullscreen' in $$new_props) $$invalidate(28, fullscreen = $$new_props.fullscreen);
		if ('header' in $$new_props) $$invalidate(2, header = $$new_props.header);
		if ('isOpen' in $$new_props) $$invalidate(3, isOpen = $$new_props.isOpen);
		if ('keyboard' in $$new_props) $$invalidate(29, keyboard = $$new_props.keyboard);
		if ('backdrop' in $$new_props) $$invalidate(4, backdrop = $$new_props.backdrop);
		if ('contentClassName' in $$new_props) $$invalidate(5, contentClassName = $$new_props.contentClassName);
		if ('fade' in $$new_props) $$invalidate(6, fade = $$new_props.fade);
		if ('labelledBy' in $$new_props) $$invalidate(7, labelledBy = $$new_props.labelledBy);
		if ('modalClassName' in $$new_props) $$invalidate(8, modalClassName = $$new_props.modalClassName);
		if ('modalStyle' in $$new_props) $$invalidate(9, modalStyle = $$new_props.modalStyle);
		if ('returnFocusAfterClose' in $$new_props) $$invalidate(30, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
		if ('scrollable' in $$new_props) $$invalidate(31, scrollable = $$new_props.scrollable);
		if ('size' in $$new_props) $$invalidate(32, size = $$new_props.size);
		if ('theme' in $$new_props) $$invalidate(10, theme = $$new_props.theme);
		if ('toggle' in $$new_props) $$invalidate(11, toggle = $$new_props.toggle);
		if ('unmountOnClose' in $$new_props) $$invalidate(33, unmountOnClose = $$new_props.unmountOnClose);
		if ('wrapClassName' in $$new_props) $$invalidate(12, wrapClassName = $$new_props.wrapClassName);
		if ('$$scope' in $$new_props) $$invalidate(37, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*className, fullscreen, centered*/ 352321536 | $$self.$$.dirty[1] & /*size, scrollable*/ 3) {
			$$invalidate(16, classes = classnames(dialogBaseClass, className, {
				[`modal-${size}`]: size,
				'modal-fullscreen': fullscreen === true,
				[`modal-fullscreen-${fullscreen}-down`]: fullscreen && typeof fullscreen === 'string',
				[`${dialogBaseClass}-centered`]: centered,
				[`${dialogBaseClass}-scrollable`]: scrollable
			}));
		}

		if ($$self.$$.dirty[0] & /*container, staticModal*/ 134217729) {
			$$invalidate(15, outer = container === 'inline' || staticModal
			? NodeModulesSveltestrapSveltestrapDistInlineContainerInlineContainerSvelte
			: NodeModulesSveltestrapSveltestrapDistPortalPortalSvelte);
		}
	};

	return [
		staticModal,
		body,
		header,
		isOpen,
		backdrop,
		contentClassName,
		fade,
		labelledBy,
		modalClassName,
		modalStyle,
		theme,
		toggle,
		wrapClassName,
		_isMounted,
		_dialog,
		outer,
		classes,
		dispatch,
		handleBackdropClick,
		onModalOpened,
		onModalClosing,
		onModalClosed,
		handleBackdropMouseDown,
		$$restProps,
		className,
		autoFocus,
		centered,
		container,
		fullscreen,
		keyboard,
		returnFocusAfterClose,
		scrollable,
		size,
		unmountOnClose,
		slots,
		div1_binding,
		introstart_handler,
		$$scope
	];
}

class NodeModulesSveltestrapSveltestrapDistModalModalSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(
			this,
			options,
			instance$x,
			create_fragment$x,
			SvelteInternal.safe_not_equal,
			{
				class: 24,
				static: 0,
				autoFocus: 25,
				body: 1,
				centered: 26,
				container: 27,
				fullscreen: 28,
				header: 2,
				isOpen: 3,
				keyboard: 29,
				backdrop: 4,
				contentClassName: 5,
				fade: 6,
				labelledBy: 7,
				modalClassName: 8,
				modalStyle: 9,
				returnFocusAfterClose: 30,
				scrollable: 31,
				size: 32,
				theme: 10,
				toggle: 11,
				unmountOnClose: 33,
				wrapClassName: 12
			},
			add_css$2,
			[-1, -1]
		);
	}

	get class() {
		return this.$$.ctx[24];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get static() {
		return this.$$.ctx[0];
	}

	set static(staticModal) {
		this.$$set({ static: staticModal });
		SvelteInternal.flush();
	}

	get autoFocus() {
		return this.$$.ctx[25];
	}

	set autoFocus(autoFocus) {
		this.$$set({ autoFocus });
		SvelteInternal.flush();
	}

	get body() {
		return this.$$.ctx[1];
	}

	set body(body) {
		this.$$set({ body });
		SvelteInternal.flush();
	}

	get centered() {
		return this.$$.ctx[26];
	}

	set centered(centered) {
		this.$$set({ centered });
		SvelteInternal.flush();
	}

	get container() {
		return this.$$.ctx[27];
	}

	set container(container) {
		this.$$set({ container });
		SvelteInternal.flush();
	}

	get fullscreen() {
		return this.$$.ctx[28];
	}

	set fullscreen(fullscreen) {
		this.$$set({ fullscreen });
		SvelteInternal.flush();
	}

	get header() {
		return this.$$.ctx[2];
	}

	set header(header) {
		this.$$set({ header });
		SvelteInternal.flush();
	}

	get isOpen() {
		return this.$$.ctx[3];
	}

	set isOpen(isOpen) {
		this.$$set({ isOpen });
		SvelteInternal.flush();
	}

	get keyboard() {
		return this.$$.ctx[29];
	}

	set keyboard(keyboard) {
		this.$$set({ keyboard });
		SvelteInternal.flush();
	}

	get backdrop() {
		return this.$$.ctx[4];
	}

	set backdrop(backdrop) {
		this.$$set({ backdrop });
		SvelteInternal.flush();
	}

	get contentClassName() {
		return this.$$.ctx[5];
	}

	set contentClassName(contentClassName) {
		this.$$set({ contentClassName });
		SvelteInternal.flush();
	}

	get fade() {
		return this.$$.ctx[6];
	}

	set fade(fade) {
		this.$$set({ fade });
		SvelteInternal.flush();
	}

	get labelledBy() {
		return this.$$.ctx[7];
	}

	set labelledBy(labelledBy) {
		this.$$set({ labelledBy });
		SvelteInternal.flush();
	}

	get modalClassName() {
		return this.$$.ctx[8];
	}

	set modalClassName(modalClassName) {
		this.$$set({ modalClassName });
		SvelteInternal.flush();
	}

	get modalStyle() {
		return this.$$.ctx[9];
	}

	set modalStyle(modalStyle) {
		this.$$set({ modalStyle });
		SvelteInternal.flush();
	}

	get returnFocusAfterClose() {
		return this.$$.ctx[30];
	}

	set returnFocusAfterClose(returnFocusAfterClose) {
		this.$$set({ returnFocusAfterClose });
		SvelteInternal.flush();
	}

	get scrollable() {
		return this.$$.ctx[31];
	}

	set scrollable(scrollable) {
		this.$$set({ scrollable });
		SvelteInternal.flush();
	}

	get size() {
		return this.$$.ctx[32];
	}

	set size(size) {
		this.$$set({ size });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[10];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}

	get toggle() {
		return this.$$.ctx[11];
	}

	set toggle(toggle) {
		this.$$set({ toggle });
		SvelteInternal.flush();
	}

	get unmountOnClose() {
		return this.$$.ctx[33];
	}

	set unmountOnClose(unmountOnClose) {
		this.$$set({ unmountOnClose });
		SvelteInternal.flush();
	}

	get wrapClassName() {
		return this.$$.ctx[12];
	}

	set wrapClassName(wrapClassName) {
		this.$$set({ wrapClassName });
		SvelteInternal.flush();
	}
}
(() => {
if (typeof document !== "undefined") {
const styleSheet = document.createElement("style");
styleSheet.innerText = decodeURI(`.modal-open%7Boverflow:hidden;padding-right:0%7D`);
document.head.appendChild(styleSheet);
}
                        })();

/* nodeModulesSveltestrapSveltestrapDistModalFooterModalFooterSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$w(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$w($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'modal-footer'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistModalFooterModalFooterSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$w, create_fragment$w, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistNavNavSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$v(ctx) {
	let ul;
	let current;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	let ul_levels = [
		/*$$restProps*/ ctx[2],
		{ class: /*classes*/ ctx[1] },
		{ "data-bs-theme": /*theme*/ ctx[0] }
	];

	let ul_data = {};

	for (let i = 0; i < ul_levels.length; i += 1) {
		ul_data = SvelteInternal.assign(ul_data, ul_levels[i]);
	}

	return {
		c() {
			ul = SvelteInternal.element("ul");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(ul, ul_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(ul, ul_data = SvelteInternal.get_spread_update(ul_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*theme*/ 1) && { "data-bs-theme": /*theme*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(ul);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function getVerticalClass(vertical) {
	if (!vertical) {
		return false;
	}

	if (vertical === true || vertical === 'xs') {
		return 'flex-column';
	}

	return `flex-${vertical}-column`;
}

function instance$v($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"class","tabs","pills","vertical","horizontal","justified","fill","navbar","card","theme","underline"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { tabs = false } = $$props;
	let { pills = false } = $$props;
	let { vertical = '' } = $$props;
	let { horizontal = '' } = $$props;
	let { justified = false } = $$props;
	let { fill = false } = $$props;
	let { navbar = false } = $$props;
	let { card = false } = $$props;
	let { theme = null } = $$props;
	let { underline = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('tabs' in $$new_props) $$invalidate(4, tabs = $$new_props.tabs);
		if ('pills' in $$new_props) $$invalidate(5, pills = $$new_props.pills);
		if ('vertical' in $$new_props) $$invalidate(6, vertical = $$new_props.vertical);
		if ('horizontal' in $$new_props) $$invalidate(7, horizontal = $$new_props.horizontal);
		if ('justified' in $$new_props) $$invalidate(8, justified = $$new_props.justified);
		if ('fill' in $$new_props) $$invalidate(9, fill = $$new_props.fill);
		if ('navbar' in $$new_props) $$invalidate(10, navbar = $$new_props.navbar);
		if ('card' in $$new_props) $$invalidate(11, card = $$new_props.card);
		if ('theme' in $$new_props) $$invalidate(0, theme = $$new_props.theme);
		if ('underline' in $$new_props) $$invalidate(12, underline = $$new_props.underline);
		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, navbar, horizontal, vertical, tabs, card, pills, justified, fill, underline*/ 8184) {
			/**
 * Computed class names for the <ul> element based on the component's props.
 * @type {string}
 */
			$$invalidate(1, classes = classnames(className, navbar ? 'navbar-nav' : 'nav', horizontal ? `justify-content-${horizontal}` : false, getVerticalClass(vertical), {
				'nav-tabs': tabs,
				'card-header-tabs': card && tabs,
				'nav-pills': pills,
				'card-header-pills': card && pills,
				'nav-justified': justified,
				'nav-fill': fill,
				'nav-underline': underline
			}));
		}
	};

	return [
		theme,
		classes,
		$$restProps,
		className,
		tabs,
		pills,
		vertical,
		horizontal,
		justified,
		fill,
		navbar,
		card,
		underline,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistNavNavSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$v, create_fragment$v, SvelteInternal.safe_not_equal, {
			class: 3,
			tabs: 4,
			pills: 5,
			vertical: 6,
			horizontal: 7,
			justified: 8,
			fill: 9,
			navbar: 10,
			card: 11,
			theme: 0,
			underline: 12
		});
	}

	get class() {
		return this.$$.ctx[3];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get tabs() {
		return this.$$.ctx[4];
	}

	set tabs(tabs) {
		this.$$set({ tabs });
		SvelteInternal.flush();
	}

	get pills() {
		return this.$$.ctx[5];
	}

	set pills(pills) {
		this.$$set({ pills });
		SvelteInternal.flush();
	}

	get vertical() {
		return this.$$.ctx[6];
	}

	set vertical(vertical) {
		this.$$set({ vertical });
		SvelteInternal.flush();
	}

	get horizontal() {
		return this.$$.ctx[7];
	}

	set horizontal(horizontal) {
		this.$$set({ horizontal });
		SvelteInternal.flush();
	}

	get justified() {
		return this.$$.ctx[8];
	}

	set justified(justified) {
		this.$$set({ justified });
		SvelteInternal.flush();
	}

	get fill() {
		return this.$$.ctx[9];
	}

	set fill(fill) {
		this.$$set({ fill });
		SvelteInternal.flush();
	}

	get navbar() {
		return this.$$.ctx[10];
	}

	set navbar(navbar) {
		this.$$set({ navbar });
		SvelteInternal.flush();
	}

	get card() {
		return this.$$.ctx[11];
	}

	set card(card) {
		this.$$set({ card });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[0];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}

	get underline() {
		return this.$$.ctx[12];
	}

	set underline(underline) {
		this.$$set({ underline });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistNavbarNavbarSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block$b(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (101:2) {#if container}
function create_if_block$d(ctx) {
	let container_1;
	let current;
	const container_1_spread_levels = [/*containerProps*/ ctx[3]];

	let container_1_props = {
		$$slots: { default: [create_default_slot$8] },
		$$scope: { ctx }
	};

	for (let i = 0; i < container_1_spread_levels.length; i += 1) {
		container_1_props = SvelteInternal.assign(container_1_props, container_1_spread_levels[i]);
	}

	container_1 = new NodeModulesSveltestrapSveltestrapDistContainerContainerSvelte({ props: container_1_props });

	return {
		c() {
			SvelteInternal.create_component(container_1.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(container_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const container_1_changes = (dirty & /*containerProps*/ 8)
			? SvelteInternal.get_spread_update(container_1_spread_levels, [SvelteInternal.get_spread_object(/*containerProps*/ ctx[3])])
			: {};

			if (dirty & /*$$scope*/ 8192) {
				container_1_changes.$$scope = { dirty, ctx };
			}

			container_1.$set(container_1_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(container_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(container_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(container_1, detaching);
		}
	};
}

// (102:4) <Container {...containerProps}>
function create_default_slot$8(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$u(ctx) {
	let nav;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$d, create_else_block$b];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*container*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let nav_levels = [
		/*$$restProps*/ ctx[4],
		{ class: /*classes*/ ctx[2] },
		{ "data-bs-theme": /*theme*/ ctx[0] }
	];

	let nav_data = {};

	for (let i = 0; i < nav_levels.length; i += 1) {
		nav_data = SvelteInternal.assign(nav_data, nav_levels[i]);
	}

	return {
		c() {
			nav = SvelteInternal.element("nav");
			if_block.c();
			SvelteInternal.set_attributes(nav, nav_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, nav, anchor);
			if_blocks[current_block_type_index].m(nav, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(nav, null);
			}

			SvelteInternal.set_attributes(nav, nav_data = SvelteInternal.get_spread_update(nav_levels, [
				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				(!current || dirty & /*theme*/ 1) && { "data-bs-theme": /*theme*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(nav);
			}

			if_blocks[current_block_type_index].d();
		}
	};
}

function getExpandClass(expand) {
	if (expand === false) {
		return false;
	}

	if (expand === true || expand === 'xs') {
		return 'navbar-expand';
	}

	return `navbar-expand-${expand}`;
}

function instance$u($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","container","color","dark","expand","fixed","light","sticky","theme"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	SvelteInternal.setContext('navbar', { inNavbar: true });
	let { class: className = '' } = $$props;
	let { container = 'fluid' } = $$props;
	let { color = '' } = $$props;
	let { dark = false } = $$props;
	let { expand = '' } = $$props;
	let { fixed = '' } = $$props;
	let { light = false } = $$props;
	let { sticky = '' } = $$props;
	let { theme = null } = $$props;

	let containerProps = {
		sm: container === 'sm',
		md: container === 'md',
		lg: container === 'lg',
		xl: container === 'xl',
		xxl: container === 'xxl',
		fluid: container === 'fluid'
	};

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('container' in $$new_props) $$invalidate(1, container = $$new_props.container);
		if ('color' in $$new_props) $$invalidate(6, color = $$new_props.color);
		if ('dark' in $$new_props) $$invalidate(7, dark = $$new_props.dark);
		if ('expand' in $$new_props) $$invalidate(8, expand = $$new_props.expand);
		if ('fixed' in $$new_props) $$invalidate(9, fixed = $$new_props.fixed);
		if ('light' in $$new_props) $$invalidate(10, light = $$new_props.light);
		if ('sticky' in $$new_props) $$invalidate(11, sticky = $$new_props.sticky);
		if ('theme' in $$new_props) $$invalidate(0, theme = $$new_props.theme);
		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*dark, light, theme*/ 1153) {
			$$invalidate(0, theme = dark ? 'dark' : light ? 'light' : theme);
		}

		if ($$self.$$.dirty & /*className, expand, color, fixed, sticky*/ 2912) {
			$$invalidate(2, classes = classnames(className, 'navbar', getExpandClass(expand), {
				[`bg-${color}`]: color,
				[`fixed-${fixed}`]: fixed,
				[`sticky-${sticky}`]: sticky
			}));
		}
	};

	return [
		theme,
		container,
		classes,
		containerProps,
		$$restProps,
		className,
		color,
		dark,
		expand,
		fixed,
		light,
		sticky,
		slots,
		$$scope
	];
}

class NodeModulesSveltestrapSveltestrapDistNavbarNavbarSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$u, create_fragment$u, SvelteInternal.safe_not_equal, {
			class: 5,
			container: 1,
			color: 6,
			dark: 7,
			expand: 8,
			fixed: 9,
			light: 10,
			sticky: 11,
			theme: 0
		});
	}

	get class() {
		return this.$$.ctx[5];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get container() {
		return this.$$.ctx[1];
	}

	set container(container) {
		this.$$set({ container });
		SvelteInternal.flush();
	}

	get color() {
		return this.$$.ctx[6];
	}

	set color(color) {
		this.$$set({ color });
		SvelteInternal.flush();
	}

	get dark() {
		return this.$$.ctx[7];
	}

	set dark(dark) {
		this.$$set({ dark });
		SvelteInternal.flush();
	}

	get expand() {
		return this.$$.ctx[8];
	}

	set expand(expand) {
		this.$$set({ expand });
		SvelteInternal.flush();
	}

	get fixed() {
		return this.$$.ctx[9];
	}

	set fixed(fixed) {
		this.$$set({ fixed });
		SvelteInternal.flush();
	}

	get light() {
		return this.$$.ctx[10];
	}

	set light(light) {
		this.$$set({ light });
		SvelteInternal.flush();
	}

	get sticky() {
		return this.$$.ctx[11];
	}

	set sticky(sticky) {
		this.$$set({ sticky });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[0];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistNavItemNavItemSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$t(ctx) {
	let li;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let li_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = SvelteInternal.assign(li_data, li_levels[i]);
	}

	return {
		c() {
			li = SvelteInternal.element("li");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(li, li_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, li, anchor);

			if (default_slot) {
				default_slot.m(li, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(li, li_data = SvelteInternal.get_spread_update(li_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(li);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$t($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","active"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { active = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('active' in $$new_props) $$invalidate(3, active = $$new_props.active);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, active*/ 12) {
			$$invalidate(0, classes = classnames(className, 'nav-item', active ? 'active' : false));
		}
	};

	return [classes, $$restProps, className, active, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistNavItemNavItemSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$t, create_fragment$t, SvelteInternal.safe_not_equal, { class: 2, active: 3 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get active() {
		return this.$$.ctx[3];
	}

	set active(active) {
		this.$$set({ active });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistNavLinkNavLinkSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$s(ctx) {
	let a;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	let a_levels = [
		/*$$restProps*/ ctx[3],
		{ href: /*href*/ ctx[0] },
		{ class: /*classes*/ ctx[1] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = SvelteInternal.assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = SvelteInternal.element("a");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(a, a_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(a, "click", /*click_handler*/ ctx[9]),
					SvelteInternal.listen(a, "click", /*handleClick*/ ctx[2])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(a, a_data = SvelteInternal.get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(a);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

function instance$s($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","disabled","active","href"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { disabled = false } = $$props;
	let { active = false } = $$props;
	let { href = '#' } = $$props;

	function handleClick(e) {
		if (disabled) {
			e.preventDefault();
			e.stopImmediatePropagation();
			return;
		}

		if (href === '#') {
			e.preventDefault();
		}
	}

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('disabled' in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
		if ('active' in $$new_props) $$invalidate(6, active = $$new_props.active);
		if ('href' in $$new_props) $$invalidate(0, href = $$new_props.href);
		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, disabled, active*/ 112) {
			$$invalidate(1, classes = classnames(className, 'nav-link', { disabled, active }));
		}
	};

	return [
		href,
		classes,
		handleClick,
		$$restProps,
		className,
		disabled,
		active,
		$$scope,
		slots,
		click_handler
	];
}

class NodeModulesSveltestrapSveltestrapDistNavLinkNavLinkSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$s, create_fragment$s, SvelteInternal.safe_not_equal, {
			class: 4,
			disabled: 5,
			active: 6,
			href: 0
		});
	}

	get class() {
		return this.$$.ctx[4];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get disabled() {
		return this.$$.ctx[5];
	}

	set disabled(disabled) {
		this.$$set({ disabled });
		SvelteInternal.flush();
	}

	get active() {
		return this.$$.ctx[6];
	}

	set active(active) {
		this.$$set({ active });
		SvelteInternal.flush();
	}

	get href() {
		return this.$$.ctx[0];
	}

	set href(href) {
		this.$$set({ href });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistNavbarBrandNavbarBrandSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$r(ctx) {
	let a;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let a_levels = [
		/*$$restProps*/ ctx[2],
		{ class: /*classes*/ ctx[1] },
		{ href: /*href*/ ctx[0] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = SvelteInternal.assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = SvelteInternal.element("a");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(a, a_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(a, "click", /*click_handler*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(a, a_data = SvelteInternal.get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(a);
			}

			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$r($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","href"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { href = '/' } = $$props;

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('href' in $$new_props) $$invalidate(0, href = $$new_props.href);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 8) {
			$$invalidate(1, classes = classnames(className, 'navbar-brand'));
		}
	};

	return [href, classes, $$restProps, className, $$scope, slots, click_handler];
}

class NodeModulesSveltestrapSveltestrapDistNavbarBrandNavbarBrandSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$r, create_fragment$r, SvelteInternal.safe_not_equal, { class: 3, href: 0 });
	}

	get class() {
		return this.$$.ctx[3];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get href() {
		return this.$$.ctx[0];
	}

	set href(href) {
		this.$$set({ href });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistNavbarTogglerNavbarTogglerSvelte.svelte generated by Svelte v4.2.8 */


function fallback_block$5(ctx) {
	let span;

	return {
		c() {
			span = SvelteInternal.element("span");
			SvelteInternal.attr(span, "class", "navbar-toggler-icon");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, span, anchor);
		},
		p: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(span);
			}
		}
	};
}

function create_fragment$q(ctx) {
	let button;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	const default_slot_or_fallback = default_slot || fallback_block$5();
	let button_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = SvelteInternal.assign(button_data, button_levels[i]);
	}

	return {
		c() {
			button = SvelteInternal.element("button");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			SvelteInternal.set_attributes(button, button_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, button, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(button, null);
			}

			if (button.autofocus) button.focus();
			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(button, "click", /*click_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(button, button_data = SvelteInternal.get_spread_update(button_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(button);
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$q($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'navbar-toggler'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots, click_handler];
}

class NodeModulesSveltestrapSveltestrapDistNavbarTogglerNavbarTogglerSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$q, create_fragment$q, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistOffcanvasBackdropOffcanvasBackdropSvelte.svelte generated by Svelte v4.2.8 */


function create_if_block$c(ctx) {
	let div;
	let div_intro;
	let div_outro;
	let current;
	let mounted;
	let dispose;

	let div_levels = [
		{ role: "presentation" },
		/*$$restProps*/ ctx[3],
		{ class: /*classes*/ ctx[2] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			SvelteInternal.set_attributes(div, div_data);
			SvelteInternal.toggle_class(div, "fade", /*fade*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(div, "click", /*click_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				{ role: "presentation" },
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
			]));

			SvelteInternal.toggle_class(div, "fade", /*fade*/ ctx[1]);
		},
		i(local) {
			if (current) return;

			if (local) {
				SvelteInternal.add_render_callback(() => {
					if (!current) return;
					if (div_outro) div_outro.end(1);
					div_intro = SvelteInternal.create_in_transition(div, backdropIn, {});
					div_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			if (div_intro) div_intro.invalidate();

			if (local) {
				div_outro = SvelteInternal.create_out_transition(div, backdropOut, {});
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (detaching && div_outro) div_outro.end();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$p(ctx) {
	let if_block_anchor;
	let if_block = /*isOpen*/ ctx[0] && create_if_block$c(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						SvelteInternal.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$c(ctx);
					if_block.c();
					SvelteInternal.transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				SvelteInternal.check_outros();
			}
		},
		i(local) {
			SvelteInternal.transition_in(if_block);
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function instance$p($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","isOpen","fade"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { class: className = '' } = $$props;
	let { isOpen = false } = $$props;
	let { fade = true } = $$props;

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ('fade' in $$new_props) $$invalidate(1, fade = $$new_props.fade);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 16) {
			$$invalidate(2, classes = classnames(className, 'offcanvas-backdrop'));
		}
	};

	return [isOpen, fade, classes, $$restProps, className, click_handler];
}

class NodeModulesSveltestrapSveltestrapDistOffcanvasBackdropOffcanvasBackdropSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$p, create_fragment$p, SvelteInternal.safe_not_equal, { class: 4, isOpen: 0, fade: 1 });
	}

	get class() {
		return this.$$.ctx[4];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get isOpen() {
		return this.$$.ctx[0];
	}

	set isOpen(isOpen) {
		this.$$set({ isOpen });
		SvelteInternal.flush();
	}

	get fade() {
		return this.$$.ctx[1];
	}

	set fade(fade) {
		this.$$set({ fade });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistOffcanvasBodyOffcanvasBodySvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$o(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$o($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'offcanvas-body'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistOffcanvasBodyOffcanvasBodySvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$o, create_fragment$o, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistOffcanvasHeaderOffcanvasHeaderSvelte.svelte generated by Svelte v4.2.8 */

const get_close_slot_changes$1 = dirty => ({});
const get_close_slot_context$1 = ctx => ({});

// (17:4) {:else}
function create_else_block$a(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (15:4) {#if children}
function create_if_block_1$7(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*children*/ ctx[0]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 1) SvelteInternal.set_data(t, /*children*/ ctx[0]);
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (22:4) {#if typeof toggle === 'function'}
function create_if_block$b(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = SvelteInternal.element("button");
			SvelteInternal.attr(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
			SvelteInternal.attr(button, "class", "btn-close");
			SvelteInternal.attr(button, "type", "button");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, button, anchor);

			if (!mounted) {
				dispose = SvelteInternal.listen(button, "click", function () {
					if (SvelteInternal.is_function(/*toggle*/ ctx[2])) /*toggle*/ ctx[2].apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*closeAriaLabel*/ 2) {
				SvelteInternal.attr(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(button);
			}

			mounted = false;
			dispose();
		}
	};
}

// (21:21)      
function fallback_block$4(ctx) {
	let if_block_anchor;
	let if_block = typeof /*toggle*/ ctx[2] === 'function' && create_if_block$b(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (typeof /*toggle*/ ctx[2] === 'function') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$b(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function create_fragment$n(ctx) {
	let div;
	let h5;
	let current_block_type_index;
	let if_block;
	let t;
	let current;
	const if_block_creators = [create_if_block_1$7, create_else_block$a];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const close_slot_template = /*#slots*/ ctx[7].close;
	const close_slot = SvelteInternal.create_slot(close_slot_template, ctx, /*$$scope*/ ctx[6], get_close_slot_context$1);
	const close_slot_or_fallback = close_slot || fallback_block$4(ctx);
	let div_levels = [/*$$restProps*/ ctx[4], { class: /*classes*/ ctx[3] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			h5 = SvelteInternal.element("h5");
			if_block.c();
			t = SvelteInternal.space();
			if (close_slot_or_fallback) close_slot_or_fallback.c();
			SvelteInternal.attr(h5, "class", "offcanvas-title");
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			SvelteInternal.append(div, h5);
			if_blocks[current_block_type_index].m(h5, null);
			SvelteInternal.append(div, t);

			if (close_slot_or_fallback) {
				close_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(h5, null);
			}

			if (close_slot) {
				if (close_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					SvelteInternal.update_slot_base(
						close_slot,
						close_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: SvelteInternal.get_slot_changes(close_slot_template, /*$$scope*/ ctx[6], dirty, get_close_slot_changes$1),
						get_close_slot_context$1
					);
				}
			} else {
				if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & /*closeAriaLabel, toggle*/ 6)) {
					close_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			SvelteInternal.transition_in(close_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			SvelteInternal.transition_out(close_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if_blocks[current_block_type_index].d();
			if (close_slot_or_fallback) close_slot_or_fallback.d(detaching);
		}
	};
}

function instance$n($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","children","closeAriaLabel","toggle"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { children = undefined } = $$props;
	let { closeAriaLabel = 'Close' } = $$props;
	let { toggle = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('children' in $$new_props) $$invalidate(0, children = $$new_props.children);
		if ('closeAriaLabel' in $$new_props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
		if ('toggle' in $$new_props) $$invalidate(2, toggle = $$new_props.toggle);
		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 32) {
			$$invalidate(3, classes = classnames(className, 'offcanvas-header'));
		}
	};

	return [
		children,
		closeAriaLabel,
		toggle,
		classes,
		$$restProps,
		className,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistOffcanvasHeaderOffcanvasHeaderSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$n, create_fragment$n, SvelteInternal.safe_not_equal, {
			class: 5,
			children: 0,
			closeAriaLabel: 1,
			toggle: 2
		});
	}

	get class() {
		return this.$$.ctx[5];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get children() {
		return this.$$.ctx[0];
	}

	set children(children) {
		this.$$set({ children });
		SvelteInternal.flush();
	}

	get closeAriaLabel() {
		return this.$$.ctx[1];
	}

	set closeAriaLabel(closeAriaLabel) {
		this.$$set({ closeAriaLabel });
		SvelteInternal.flush();
	}

	get toggle() {
		return this.$$.ctx[2];
	}

	set toggle(toggle) {
		this.$$set({ toggle });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistOffcanvasOffcanvasSvelte.svelte generated by Svelte v4.2.8 */


const { document: document_1$1 } = SvelteInternal.globals;

function add_css$1(target) {
	SvelteInternal.append_styles(target, "svelte-xe7n9u", ".overflow-noscroll{overflow:hidden;padding-right:0px}");
}

const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

// (204:4) {#if toggle || header || $$slots.header}
function create_if_block_2$2(ctx) {
	let offcanvasheader;
	let current;

	offcanvasheader = new NodeModulesSveltestrapSveltestrapDistOffcanvasHeaderOffcanvasHeaderSvelte({
			props: {
				toggle: /*toggle*/ ctx[7],
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			SvelteInternal.create_component(offcanvasheader.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(offcanvasheader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const offcanvasheader_changes = {};
			if (dirty & /*toggle*/ 128) offcanvasheader_changes.toggle = /*toggle*/ ctx[7];

			if (dirty & /*$$scope, header*/ 536870928) {
				offcanvasheader_changes.$$scope = { dirty, ctx };
			}

			offcanvasheader.$set(offcanvasheader_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(offcanvasheader.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(offcanvasheader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(offcanvasheader, detaching);
		}
	};
}

// (206:8) {#if header}
function create_if_block_3(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*header*/ ctx[4]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*header*/ 16) SvelteInternal.set_data(t, /*header*/ ctx[4]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (205:6) <OffcanvasHeader {toggle}>
function create_default_slot_2$1(ctx) {
	let t;
	let current;
	let if_block = /*header*/ ctx[4] && create_if_block_3(ctx);
	const header_slot_template = /*#slots*/ ctx[27].header;
	const header_slot = SvelteInternal.create_slot(header_slot_template, ctx, /*$$scope*/ ctx[29], get_header_slot_context);

	return {
		c() {
			if (if_block) if_block.c();
			t = SvelteInternal.space();
			if (header_slot) header_slot.c();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			SvelteInternal.insert(target, t, anchor);

			if (header_slot) {
				header_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*header*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 536870912)) {
					SvelteInternal.update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[29],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[29])
						: SvelteInternal.get_slot_changes(header_slot_template, /*$$scope*/ ctx[29], dirty, get_header_slot_changes),
						get_header_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}

			if (if_block) if_block.d(detaching);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (216:4) {:else}
function create_else_block$9(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[27].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[29], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 536870912)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[29],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[29])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[29], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (212:4) {#if body}
function create_if_block_1$6(ctx) {
	let offcanvasbody;
	let current;

	offcanvasbody = new NodeModulesSveltestrapSveltestrapDistOffcanvasBodyOffcanvasBodySvelte({
			props: {
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			SvelteInternal.create_component(offcanvasbody.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(offcanvasbody, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const offcanvasbody_changes = {};

			if (dirty & /*$$scope*/ 536870912) {
				offcanvasbody_changes.$$scope = { dirty, ctx };
			}

			offcanvasbody.$set(offcanvasbody_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(offcanvasbody.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(offcanvasbody.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(offcanvasbody, detaching);
		}
	};
}

// (213:6) <OffcanvasBody>
function create_default_slot_1$3(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[27].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[29], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 536870912)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[29],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[29])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[29], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (220:2) {#if backdrop}
function create_if_block$a(ctx) {
	let offcanvasbackdrop;
	let current;

	offcanvasbackdrop = new NodeModulesSveltestrapSveltestrapDistOffcanvasBackdropOffcanvasBackdropSvelte({
			props: {
				fade: /*fade*/ ctx[3],
				isOpen: /*isOpen*/ ctx[0]
			}
		});

	offcanvasbackdrop.$on("click", function () {
		if (SvelteInternal.is_function(/*toggle*/ ctx[7] || undefined)) (/*toggle*/ ctx[7] || undefined).apply(this, arguments);
	});

	return {
		c() {
			SvelteInternal.create_component(offcanvasbackdrop.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(offcanvasbackdrop, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const offcanvasbackdrop_changes = {};
			if (dirty & /*fade*/ 8) offcanvasbackdrop_changes.fade = /*fade*/ ctx[3];
			if (dirty & /*isOpen*/ 1) offcanvasbackdrop_changes.isOpen = /*isOpen*/ ctx[0];
			offcanvasbackdrop.$set(offcanvasbackdrop_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(offcanvasbackdrop.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(offcanvasbackdrop.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(offcanvasbackdrop, detaching);
		}
	};
}

// (192:0) <svelte:component this={outer}>
function create_default_slot$7(ctx) {
	let div;
	let t0;
	let current_block_type_index;
	let if_block1;
	let div_aria_hidden_value;
	let div_aria_modal_value;
	let div_role_value;
	let div_style_value;
	let t1;
	let if_block2_anchor;
	let current;
	let if_block0 = (/*toggle*/ ctx[7] || /*header*/ ctx[4] || /*$$slots*/ ctx[14].header) && create_if_block_2$2(ctx);
	const if_block_creators = [create_if_block_1$6, create_else_block$9];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*body*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let div_levels = [
		/*$$restProps*/ ctx[13],
		{
			"aria-hidden": div_aria_hidden_value = !/*isOpen*/ ctx[0] ? true : undefined
		},
		{
			"aria-modal": div_aria_modal_value = /*isOpen*/ ctx[0] ? true : undefined
		},
		{ class: /*classes*/ ctx[11] },
		{
			role: div_role_value = /*isOpen*/ ctx[0] ? 'dialog' : undefined
		},
		{ "data-bs-theme": /*theme*/ ctx[6] },
		{
			style: div_style_value = `visibility: ${/*isOpen*/ ctx[0] || /*isTransitioning*/ ctx[8]
			? 'visible'
			: 'hidden'};${/*style*/ ctx[5]}`
		},
		{ tabindex: "-1" }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	let if_block2 = /*backdrop*/ ctx[1] && create_if_block$a(ctx);

	return {
		c() {
			div = SvelteInternal.element("div");
			if (if_block0) if_block0.c();
			t0 = SvelteInternal.space();
			if_block1.c();
			t1 = SvelteInternal.space();
			if (if_block2) if_block2.c();
			if_block2_anchor = SvelteInternal.empty();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			SvelteInternal.append(div, t0);
			if_blocks[current_block_type_index].m(div, null);
			/*div_binding*/ ctx[28](div);
			SvelteInternal.insert(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			SvelteInternal.insert(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*toggle*/ ctx[7] || /*header*/ ctx[4] || /*$$slots*/ ctx[14].header) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*toggle, header, $$slots*/ 16528) {
						SvelteInternal.transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$2(ctx);
					if_block0.c();
					SvelteInternal.transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				SvelteInternal.check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block1, 1);
				if_block1.m(div, null);
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 8192 && /*$$restProps*/ ctx[13],
				(!current || dirty & /*isOpen*/ 1 && div_aria_hidden_value !== (div_aria_hidden_value = !/*isOpen*/ ctx[0] ? true : undefined)) && { "aria-hidden": div_aria_hidden_value },
				(!current || dirty & /*isOpen*/ 1 && div_aria_modal_value !== (div_aria_modal_value = /*isOpen*/ ctx[0] ? true : undefined)) && { "aria-modal": div_aria_modal_value },
				(!current || dirty & /*classes*/ 2048) && { class: /*classes*/ ctx[11] },
				(!current || dirty & /*isOpen*/ 1 && div_role_value !== (div_role_value = /*isOpen*/ ctx[0] ? 'dialog' : undefined)) && { role: div_role_value },
				(!current || dirty & /*theme*/ 64) && { "data-bs-theme": /*theme*/ ctx[6] },
				(!current || dirty & /*isOpen, isTransitioning, style*/ 289 && div_style_value !== (div_style_value = `visibility: ${/*isOpen*/ ctx[0] || /*isTransitioning*/ ctx[8]
				? 'visible'
				: 'hidden'};${/*style*/ ctx[5]}`)) && { style: div_style_value },
				{ tabindex: "-1" }
			]));

			if (/*backdrop*/ ctx[1]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*backdrop*/ 2) {
						SvelteInternal.transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$a(ctx);
					if_block2.c();
					SvelteInternal.transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				SvelteInternal.check_outros();
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block0);
			SvelteInternal.transition_in(if_block1);
			SvelteInternal.transition_in(if_block2);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block0);
			SvelteInternal.transition_out(if_block1);
			SvelteInternal.transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
				SvelteInternal.detach(t1);
				SvelteInternal.detach(if_block2_anchor);
			}

			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			/*div_binding*/ ctx[28](null);
			if (if_block2) if_block2.d(detaching);
		}
	};
}

function create_fragment$m(ctx) {
	let t;
	let switch_instance;
	let switch_instance_anchor;
	let current;
	let mounted;
	let dispose;
	var switch_value = /*outer*/ ctx[10];

	function switch_props(ctx, dirty) {
		return {
			props: {
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			}
		};
	}

	if (switch_value) {
		switch_instance = SvelteInternal.construct_svelte_component(switch_value, switch_props(ctx));
	}

	return {
		c() {
			t = SvelteInternal.space();
			if (switch_instance) SvelteInternal.create_component(switch_instance.$$.fragment);
			switch_instance_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
			if (switch_instance) SvelteInternal.mount_component(switch_instance, target, anchor);
			SvelteInternal.insert(target, switch_instance_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(document_1$1.body, "mousedown", function () {
					if (SvelteInternal.is_function(/*handleMouseDown*/ ctx[12])) /*handleMouseDown*/ ctx[12].apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (dirty & /*outer*/ 1024 && switch_value !== (switch_value = /*outer*/ ctx[10])) {
				if (switch_instance) {
					SvelteInternal.group_outros();
					const old_component = switch_instance;

					SvelteInternal.transition_out(old_component.$$.fragment, 1, 0, () => {
						SvelteInternal.destroy_component(old_component, 1);
					});

					SvelteInternal.check_outros();
				}

				if (switch_value) {
					switch_instance = SvelteInternal.construct_svelte_component(switch_value, switch_props(ctx));
					SvelteInternal.create_component(switch_instance.$$.fragment);
					SvelteInternal.transition_in(switch_instance.$$.fragment, 1);
					SvelteInternal.mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				const switch_instance_changes = {};

				if (dirty & /*$$scope, fade, isOpen, toggle, backdrop, $$restProps, classes, theme, isTransitioning, style, element, body, header, $$slots*/ 536898559) {
					switch_instance_changes.$$scope = { dirty, ctx };
				}

				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) SvelteInternal.transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) SvelteInternal.transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
				SvelteInternal.detach(switch_instance_anchor);
			}

			if (switch_instance) SvelteInternal.destroy_component(switch_instance, detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$m($$self, $$props, $$invalidate) {
	let handleMouseDown;
	let classes;
	let outer;

	const omit_props_names = [
		"class","backdrop","body","container","fade","header","isOpen","keyboard","placement","scroll","sm","md","lg","xl","xxl","style","theme","toggle"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = SvelteInternal.compute_slots(slots);
	const dispatch = SvelteInternal.createEventDispatcher();
	let { class: className = '' } = $$props;
	let { backdrop = true } = $$props;
	let { body = true } = $$props;
	let { container = 'body' } = $$props;
	let { fade = true } = $$props;
	let { header = '' } = $$props;
	let { isOpen = false } = $$props;
	let { keyboard = true } = $$props;
	let { placement = 'start' } = $$props;
	let { scroll = false } = $$props;
	let { sm = false } = $$props;
	let { md = false } = $$props;
	let { lg = false } = $$props;
	let { xl = false } = $$props;
	let { xxl = false } = $$props;
	let { style = '' } = $$props;
	let { theme = null } = $$props;
	let { toggle = undefined } = $$props;

	/**
 * TODO: Support these like Modals:
 * - autoFocus
 * - unmountOnClose
 * - focus trap
 */
	let bodyElement;

	let isTransitioning = false;
	let element;
	let removeEscListener;
	SvelteInternal.onMount(() => $$invalidate(25, bodyElement = document.body));

	function div_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(9, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(13, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(15, className = $$new_props.class);
		if ('backdrop' in $$new_props) $$invalidate(1, backdrop = $$new_props.backdrop);
		if ('body' in $$new_props) $$invalidate(2, body = $$new_props.body);
		if ('container' in $$new_props) $$invalidate(16, container = $$new_props.container);
		if ('fade' in $$new_props) $$invalidate(3, fade = $$new_props.fade);
		if ('header' in $$new_props) $$invalidate(4, header = $$new_props.header);
		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ('keyboard' in $$new_props) $$invalidate(17, keyboard = $$new_props.keyboard);
		if ('placement' in $$new_props) $$invalidate(18, placement = $$new_props.placement);
		if ('scroll' in $$new_props) $$invalidate(19, scroll = $$new_props.scroll);
		if ('sm' in $$new_props) $$invalidate(20, sm = $$new_props.sm);
		if ('md' in $$new_props) $$invalidate(21, md = $$new_props.md);
		if ('lg' in $$new_props) $$invalidate(22, lg = $$new_props.lg);
		if ('xl' in $$new_props) $$invalidate(23, xl = $$new_props.xl);
		if ('xxl' in $$new_props) $$invalidate(24, xxl = $$new_props.xxl);
		if ('style' in $$new_props) $$invalidate(5, style = $$new_props.style);
		if ('theme' in $$new_props) $$invalidate(6, theme = $$new_props.theme);
		if ('toggle' in $$new_props) $$invalidate(7, toggle = $$new_props.toggle);
		if ('$$scope' in $$new_props) $$invalidate(29, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*element, isOpen*/ 513) {
			if (element) {
				($$invalidate(0, isOpen), $$invalidate(9, element));
				$$invalidate(8, isTransitioning = true);
				dispatch(isOpen ? 'opening' : 'closing');

				setTimeout(
					() => {
						$$invalidate(8, isTransitioning = false);
						dispatch(isOpen ? 'open' : 'close');
					},
					getTransitionDuration(element)
				);
			}
		}

		if ($$self.$$.dirty & /*bodyElement, scroll, isOpen, isTransitioning*/ 34078977) {
			if (bodyElement && !scroll) {
				bodyElement.classList.toggle('overflow-noscroll', isOpen || isTransitioning);
			}
		}

		if ($$self.$$.dirty & /*isOpen, toggle, keyboard*/ 131201) {
			if (isOpen && toggle && typeof window !== 'undefined') {
				$$invalidate(26, removeEscListener = browserEvent(document, 'keydown', event => {
					if (event.key && event.key === 'Escape' && keyboard) {
						toggle();
					}
				}));
			}
		}

		if ($$self.$$.dirty & /*isOpen, removeEscListener*/ 67108865) {
			if (!isOpen && removeEscListener) {
				removeEscListener();
			}
		}

		if ($$self.$$.dirty & /*backdrop, toggle, bodyElement, isOpen*/ 33554563) {
			$$invalidate(12, handleMouseDown = backdrop && toggle && bodyElement && isOpen
			? e => {
					if (e.target === bodyElement) {
						toggle();
					}
				}
			: undefined);
		}

		if ($$self.$$.dirty & /*sm, md, lg, xl, xxl, isOpen, placement, className*/ 32800769) {
			$$invalidate(11, classes = classnames(
				{
					offcanvas: !sm && !md && !lg && !xl && !xxl,
					'offcanvas-sm': sm,
					'offcanvas-md': md,
					'offcanvas-lg': lg,
					'offcanvas-xl': xl,
					'offcanvas-xxl': xxl,
					show: isOpen
				},
				`offcanvas-${placement}`,
				className
			));
		}

		if ($$self.$$.dirty & /*container*/ 65536) {
			$$invalidate(10, outer = container === 'inline' ? NodeModulesSveltestrapSveltestrapDistInlineContainerInlineContainerSvelte : NodeModulesSveltestrapSveltestrapDistPortalPortalSvelte);
		}
	};

	return [
		isOpen,
		backdrop,
		body,
		fade,
		header,
		style,
		theme,
		toggle,
		isTransitioning,
		element,
		outer,
		classes,
		handleMouseDown,
		$$restProps,
		$$slots,
		className,
		container,
		keyboard,
		placement,
		scroll,
		sm,
		md,
		lg,
		xl,
		xxl,
		bodyElement,
		removeEscListener,
		slots,
		div_binding,
		$$scope
	];
}

class NodeModulesSveltestrapSveltestrapDistOffcanvasOffcanvasSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(
			this,
			options,
			instance$m,
			create_fragment$m,
			SvelteInternal.safe_not_equal,
			{
				class: 15,
				backdrop: 1,
				body: 2,
				container: 16,
				fade: 3,
				header: 4,
				isOpen: 0,
				keyboard: 17,
				placement: 18,
				scroll: 19,
				sm: 20,
				md: 21,
				lg: 22,
				xl: 23,
				xxl: 24,
				style: 5,
				theme: 6,
				toggle: 7
			},
			add_css$1
		);
	}

	get class() {
		return this.$$.ctx[15];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get backdrop() {
		return this.$$.ctx[1];
	}

	set backdrop(backdrop) {
		this.$$set({ backdrop });
		SvelteInternal.flush();
	}

	get body() {
		return this.$$.ctx[2];
	}

	set body(body) {
		this.$$set({ body });
		SvelteInternal.flush();
	}

	get container() {
		return this.$$.ctx[16];
	}

	set container(container) {
		this.$$set({ container });
		SvelteInternal.flush();
	}

	get fade() {
		return this.$$.ctx[3];
	}

	set fade(fade) {
		this.$$set({ fade });
		SvelteInternal.flush();
	}

	get header() {
		return this.$$.ctx[4];
	}

	set header(header) {
		this.$$set({ header });
		SvelteInternal.flush();
	}

	get isOpen() {
		return this.$$.ctx[0];
	}

	set isOpen(isOpen) {
		this.$$set({ isOpen });
		SvelteInternal.flush();
	}

	get keyboard() {
		return this.$$.ctx[17];
	}

	set keyboard(keyboard) {
		this.$$set({ keyboard });
		SvelteInternal.flush();
	}

	get placement() {
		return this.$$.ctx[18];
	}

	set placement(placement) {
		this.$$set({ placement });
		SvelteInternal.flush();
	}

	get scroll() {
		return this.$$.ctx[19];
	}

	set scroll(scroll) {
		this.$$set({ scroll });
		SvelteInternal.flush();
	}

	get sm() {
		return this.$$.ctx[20];
	}

	set sm(sm) {
		this.$$set({ sm });
		SvelteInternal.flush();
	}

	get md() {
		return this.$$.ctx[21];
	}

	set md(md) {
		this.$$set({ md });
		SvelteInternal.flush();
	}

	get lg() {
		return this.$$.ctx[22];
	}

	set lg(lg) {
		this.$$set({ lg });
		SvelteInternal.flush();
	}

	get xl() {
		return this.$$.ctx[23];
	}

	set xl(xl) {
		this.$$set({ xl });
		SvelteInternal.flush();
	}

	get xxl() {
		return this.$$.ctx[24];
	}

	set xxl(xxl) {
		this.$$set({ xxl });
		SvelteInternal.flush();
	}

	get style() {
		return this.$$.ctx[5];
	}

	set style(style) {
		this.$$set({ style });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[6];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}

	get toggle() {
		return this.$$.ctx[7];
	}

	set toggle(toggle) {
		this.$$set({ toggle });
		SvelteInternal.flush();
	}
}
(() => {
if (typeof document !== "undefined") {
const styleSheet = document.createElement("style");
styleSheet.innerText = decodeURI(`.overflow-noscroll%7Boverflow:hidden;padding-right:0px%7D`);
document.head.appendChild(styleSheet);
}
                        })();

/* nodeModulesSveltestrapSveltestrapDistPaginationPaginationSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$l(ctx) {
	let nav;
	let ul;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	let nav_levels = [
		/*$$restProps*/ ctx[4],
		{ class: /*classes*/ ctx[3] },
		{ "aria-label": /*ariaLabel*/ ctx[0] },
		{ "data-bs-theme": /*theme*/ ctx[1] }
	];

	let nav_data = {};

	for (let i = 0; i < nav_levels.length; i += 1) {
		nav_data = SvelteInternal.assign(nav_data, nav_levels[i]);
	}

	return {
		c() {
			nav = SvelteInternal.element("nav");
			ul = SvelteInternal.element("ul");
			if (default_slot) default_slot.c();
			SvelteInternal.attr(ul, "class", /*listClasses*/ ctx[2]);
			SvelteInternal.set_attributes(nav, nav_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, nav, anchor);
			SvelteInternal.append(nav, ul);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*listClasses*/ 4) {
				SvelteInternal.attr(ul, "class", /*listClasses*/ ctx[2]);
			}

			SvelteInternal.set_attributes(nav, nav_data = SvelteInternal.get_spread_update(nav_levels, [
				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				(!current || dirty & /*ariaLabel*/ 1) && { "aria-label": /*ariaLabel*/ ctx[0] },
				(!current || dirty & /*theme*/ 2) && { "data-bs-theme": /*theme*/ ctx[1] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(nav);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$l($$self, $$props, $$invalidate) {
	let classes;
	let listClasses;
	const omit_props_names = ["ariaLabel","class","listClassName","size","theme"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { ariaLabel = 'pagination' } = $$props;
	let { class: className = '' } = $$props;
	let { listClassName = '' } = $$props;
	let { size = '' } = $$props;
	let { theme = null } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(4, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('ariaLabel' in $$new_props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('listClassName' in $$new_props) $$invalidate(6, listClassName = $$new_props.listClassName);
		if ('size' in $$new_props) $$invalidate(7, size = $$new_props.size);
		if ('theme' in $$new_props) $$invalidate(1, theme = $$new_props.theme);
		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 32) {
			$$invalidate(3, classes = classnames(className));
		}

		if ($$self.$$.dirty & /*listClassName, size*/ 192) {
			$$invalidate(2, listClasses = classnames(listClassName, 'pagination', { [`pagination-${size}`]: !!size }));
		}
	};

	return [
		ariaLabel,
		theme,
		listClasses,
		classes,
		$$restProps,
		className,
		listClassName,
		size,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistPaginationPaginationSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$l, create_fragment$l, SvelteInternal.safe_not_equal, {
			ariaLabel: 0,
			class: 5,
			listClassName: 6,
			size: 7,
			theme: 1
		});
	}

	get ariaLabel() {
		return this.$$.ctx[0];
	}

	set ariaLabel(ariaLabel) {
		this.$$set({ ariaLabel });
		SvelteInternal.flush();
	}

	get class() {
		return this.$$.ctx[5];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get listClassName() {
		return this.$$.ctx[6];
	}

	set listClassName(listClassName) {
		this.$$set({ listClassName });
		SvelteInternal.flush();
	}

	get size() {
		return this.$$.ctx[7];
	}

	set size(size) {
		this.$$set({ size });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[1];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistPaginationItemPaginationItemSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$k(ctx) {
	let li;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let li_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = SvelteInternal.assign(li_data, li_levels[i]);
	}

	return {
		c() {
			li = SvelteInternal.element("li");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(li, li_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, li, anchor);

			if (default_slot) {
				default_slot.m(li, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(li, li_data = SvelteInternal.get_spread_update(li_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(li);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$k($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","active","disabled"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { active = false } = $$props;
	let { disabled = false } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('active' in $$new_props) $$invalidate(3, active = $$new_props.active);
		if ('disabled' in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, active, disabled*/ 28) {
			$$invalidate(0, classes = classnames(className, 'page-item', { active, disabled }));
		}
	};

	return [classes, $$restProps, className, active, disabled, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistPaginationItemPaginationItemSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$k, create_fragment$k, SvelteInternal.safe_not_equal, { class: 2, active: 3, disabled: 4 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get active() {
		return this.$$.ctx[3];
	}

	set active(active) {
		this.$$set({ active });
		SvelteInternal.flush();
	}

	get disabled() {
		return this.$$.ctx[4];
	}

	set disabled(disabled) {
		this.$$set({ disabled });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistPaginationLinkPaginationLinkSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block$8(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (42:2) {#if previous || next || first || last}
function create_if_block$9(ctx) {
	let span0;
	let t0;
	let span1;
	let t1;
	let current;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	const default_slot_or_fallback = default_slot || fallback_block$3(ctx);

	return {
		c() {
			span0 = SvelteInternal.element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t0 = SvelteInternal.space();
			span1 = SvelteInternal.element("span");
			t1 = SvelteInternal.text(/*realLabel*/ ctx[6]);
			SvelteInternal.attr(span0, "aria-hidden", "true");
			SvelteInternal.attr(span1, "class", "visually-hidden");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, span0, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span0, null);
			}

			SvelteInternal.insert(target, t0, anchor);
			SvelteInternal.insert(target, span1, anchor);
			SvelteInternal.append(span1, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*defaultCaret*/ 32)) {
					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (!current || dirty & /*realLabel*/ 64) SvelteInternal.set_data(t1, /*realLabel*/ ctx[6]);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(span0);
				SvelteInternal.detach(t0);
				SvelteInternal.detach(span1);
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

// (44:12) {defaultCaret}
function fallback_block$3(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*defaultCaret*/ ctx[5]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*defaultCaret*/ 32) SvelteInternal.set_data(t, /*defaultCaret*/ ctx[5]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

function create_fragment$j(ctx) {
	let a;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block$9, create_else_block$8];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*previous*/ ctx[1] || /*next*/ ctx[0] || /*first*/ ctx[2] || /*last*/ ctx[3]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let a_levels = [
		/*$$restProps*/ ctx[8],
		{ class: /*classes*/ ctx[7] },
		{ href: /*href*/ ctx[4] }
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = SvelteInternal.assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = SvelteInternal.element("a");
			if_block.c();
			SvelteInternal.set_attributes(a, a_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, a, anchor);
			if_blocks[current_block_type_index].m(a, null);
			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(a, "click", /*click_handler*/ ctx[14]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(a, null);
			}

			SvelteInternal.set_attributes(a, a_data = SvelteInternal.get_spread_update(a_levels, [
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
				(!current || dirty & /*href*/ 16) && { href: /*href*/ ctx[4] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(a);
			}

			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};
}

function instance$j($$self, $$props, $$invalidate) {
	let classes;
	let realLabel;
	const omit_props_names = ["class","next","previous","first","last","ariaLabel","href"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { next = false } = $$props;
	let { previous = false } = $$props;
	let { first = false } = $$props;
	let { last = false } = $$props;
	let { ariaLabel = '' } = $$props;
	let { href = '' } = $$props;
	let defaultAriaLabel;
	let defaultCaret;

	function click_handler(event) {
		SvelteInternal.bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ('next' in $$new_props) $$invalidate(0, next = $$new_props.next);
		if ('previous' in $$new_props) $$invalidate(1, previous = $$new_props.previous);
		if ('first' in $$new_props) $$invalidate(2, first = $$new_props.first);
		if ('last' in $$new_props) $$invalidate(3, last = $$new_props.last);
		if ('ariaLabel' in $$new_props) $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
		if ('href' in $$new_props) $$invalidate(4, href = $$new_props.href);
		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 512) {
			$$invalidate(7, classes = classnames(className, 'page-link'));
		}

		if ($$self.$$.dirty & /*previous, next, first, last*/ 15) {
			if (previous) {
				$$invalidate(11, defaultAriaLabel = 'Previous');
			} else if (next) {
				$$invalidate(11, defaultAriaLabel = 'Next');
			} else if (first) {
				$$invalidate(11, defaultAriaLabel = 'First');
			} else if (last) {
				$$invalidate(11, defaultAriaLabel = 'Last');
			}
		}

		if ($$self.$$.dirty & /*ariaLabel, defaultAriaLabel*/ 3072) {
			$$invalidate(6, realLabel = ariaLabel || defaultAriaLabel);
		}

		if ($$self.$$.dirty & /*previous, next, first, last*/ 15) {
			if (previous) {
				$$invalidate(5, defaultCaret = '\u2039');
			} else if (next) {
				$$invalidate(5, defaultCaret = '\u203A');
			} else if (first) {
				$$invalidate(5, defaultCaret = '\u00ab');
			} else if (last) {
				$$invalidate(5, defaultCaret = '\u00bb');
			}
		}
	};

	return [
		next,
		previous,
		first,
		last,
		href,
		defaultCaret,
		realLabel,
		classes,
		$$restProps,
		className,
		ariaLabel,
		defaultAriaLabel,
		$$scope,
		slots,
		click_handler
	];
}

class NodeModulesSveltestrapSveltestrapDistPaginationLinkPaginationLinkSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$j, create_fragment$j, SvelteInternal.safe_not_equal, {
			class: 9,
			next: 0,
			previous: 1,
			first: 2,
			last: 3,
			ariaLabel: 10,
			href: 4
		});
	}

	get class() {
		return this.$$.ctx[9];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get next() {
		return this.$$.ctx[0];
	}

	set next(next) {
		this.$$set({ next });
		SvelteInternal.flush();
	}

	get previous() {
		return this.$$.ctx[1];
	}

	set previous(previous) {
		this.$$set({ previous });
		SvelteInternal.flush();
	}

	get first() {
		return this.$$.ctx[2];
	}

	set first(first) {
		this.$$set({ first });
		SvelteInternal.flush();
	}

	get last() {
		return this.$$.ctx[3];
	}

	set last(last) {
		this.$$set({ last });
		SvelteInternal.flush();
	}

	get ariaLabel() {
		return this.$$.ctx[10];
	}

	set ariaLabel(ariaLabel) {
		this.$$set({ ariaLabel });
		SvelteInternal.flush();
	}

	get href() {
		return this.$$.ctx[4];
	}

	set href(href) {
		this.$$set({ href });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistPopoverPopoverSvelte.svelte generated by Svelte v4.2.8 */

const get_title_slot_changes = dirty => ({});
const get_title_slot_context = ctx => ({});

// (198:0) {#if isOpen}
function create_if_block$8(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*outer*/ ctx[6];

	function switch_props(ctx, dirty) {
		return {
			props: {
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			}
		};
	}

	if (switch_value) {
		switch_instance = SvelteInternal.construct_svelte_component(switch_value, switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) SvelteInternal.create_component(switch_instance.$$.fragment);
			switch_instance_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (switch_instance) SvelteInternal.mount_component(switch_instance, target, anchor);
			SvelteInternal.insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*outer*/ 64 && switch_value !== (switch_value = /*outer*/ ctx[6])) {
				if (switch_instance) {
					SvelteInternal.group_outros();
					const old_component = switch_instance;

					SvelteInternal.transition_out(old_component.$$.fragment, 1, 0, () => {
						SvelteInternal.destroy_component(old_component, 1);
					});

					SvelteInternal.check_outros();
				}

				if (switch_value) {
					switch_instance = SvelteInternal.construct_svelte_component(switch_value, switch_props(ctx));
					SvelteInternal.create_component(switch_instance.$$.fragment);
					SvelteInternal.transition_in(switch_instance.$$.fragment, 1);
					SvelteInternal.mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				const switch_instance_changes = {};

				if (dirty & /*$$scope, $$restProps, classes, theme, popperPlacement, popoverEl, children, title*/ 8389310) {
					switch_instance_changes.$$scope = { dirty, ctx };
				}

				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) SvelteInternal.transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) SvelteInternal.transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(switch_instance_anchor);
			}

			if (switch_instance) SvelteInternal.destroy_component(switch_instance, detaching);
		}
	};
}

// (210:27) {title}
function fallback_block$2(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*title*/ ctx[3]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 8) SvelteInternal.set_data(t, /*title*/ ctx[3]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (215:8) {:else}
function create_else_block$7(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[23],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[23])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[23], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (213:8) {#if children}
function create_if_block_1$5(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*children*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 2) SvelteInternal.set_data(t, /*children*/ ctx[1]);
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (199:2) <svelte:component this={outer}>
function create_default_slot$6(ctx) {
	let div2;
	let div0;
	let t0;
	let h3;
	let t1;
	let div1;
	let current_block_type_index;
	let if_block;
	let current;
	const title_slot_template = /*#slots*/ ctx[21].title;
	const title_slot = SvelteInternal.create_slot(title_slot_template, ctx, /*$$scope*/ ctx[23], get_title_slot_context);
	const title_slot_or_fallback = title_slot || fallback_block$2(ctx);
	const if_block_creators = [create_if_block_1$5, create_else_block$7];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let div2_levels = [
		/*$$restProps*/ ctx[9],
		{ class: /*classes*/ ctx[7] },
		{ role: "tooltip" },
		{ "data-bs-theme": /*theme*/ ctx[2] },
		{
			"x-placement": /*popperPlacement*/ ctx[5]
		}
	];

	let div_data_2 = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div_data_2 = SvelteInternal.assign(div_data_2, div2_levels[i]);
	}

	return {
		c() {
			div2 = SvelteInternal.element("div");
			div0 = SvelteInternal.element("div");
			t0 = SvelteInternal.space();
			h3 = SvelteInternal.element("h3");
			if (title_slot_or_fallback) title_slot_or_fallback.c();
			t1 = SvelteInternal.space();
			div1 = SvelteInternal.element("div");
			if_block.c();
			SvelteInternal.attr(div0, "class", "popover-arrow");
			SvelteInternal.attr(div0, "data-popper-arrow", "");
			SvelteInternal.attr(h3, "class", "popover-header");
			SvelteInternal.attr(div1, "class", "popover-body");
			SvelteInternal.set_attributes(div2, div_data_2);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div2, anchor);
			SvelteInternal.append(div2, div0);
			SvelteInternal.append(div2, t0);
			SvelteInternal.append(div2, h3);

			if (title_slot_or_fallback) {
				title_slot_or_fallback.m(h3, null);
			}

			SvelteInternal.append(div2, t1);
			SvelteInternal.append(div2, div1);
			if_blocks[current_block_type_index].m(div1, null);
			/*div2_binding*/ ctx[22](div2);
			current = true;
		},
		p(ctx, dirty) {
			if (title_slot) {
				if (title_slot.p && (!current || dirty & /*$$scope*/ 8388608)) {
					SvelteInternal.update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[23],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[23])
						: SvelteInternal.get_slot_changes(title_slot_template, /*$$scope*/ ctx[23], dirty, get_title_slot_changes),
						get_title_slot_context
					);
				}
			} else {
				if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & /*title*/ 8)) {
					title_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(div1, null);
			}

			SvelteInternal.set_attributes(div2, div_data_2 = SvelteInternal.get_spread_update(div2_levels, [
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
				{ role: "tooltip" },
				(!current || dirty & /*theme*/ 4) && { "data-bs-theme": /*theme*/ ctx[2] },
				(!current || dirty & /*popperPlacement*/ 32) && {
					"x-placement": /*popperPlacement*/ ctx[5]
				}
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(title_slot_or_fallback, local);
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(title_slot_or_fallback, local);
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div2);
			}

			if (title_slot_or_fallback) title_slot_or_fallback.d(detaching);
			if_blocks[current_block_type_index].d();
			/*div2_binding*/ ctx[22](null);
		}
	};
}

function create_fragment$i(ctx) {
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;
	let if_block = /*isOpen*/ ctx[0] && create_if_block$8(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = SvelteInternal.listen(window, "mousedown", /*handleOutsideClick*/ ctx[8]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						SvelteInternal.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$8(ctx);
					if_block.c();
					SvelteInternal.transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				SvelteInternal.check_outros();
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	let classes;
	let outer;

	const omit_props_names = [
		"class","animation","children","container","dismissible","hideOnOutsideClick","isOpen","placement","target","theme","title","trigger"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { animation = true } = $$props;
	let { children = '' } = $$props;
	let { container = undefined } = $$props;
	let { dismissible = false } = $$props;
	let { hideOnOutsideClick = false } = $$props;
	let { isOpen = false } = $$props;
	let { placement = 'top' } = $$props;
	let { target = '' } = $$props;
	let { theme = null } = $$props;
	let { title = '' } = $$props;
	let { trigger = 'click' } = $$props;
	let targetEl;
	let popoverEl;
	let popperInstance;
	let bsPlacement;
	let popperPlacement = placement;

	const checkPopperPlacement = {
		name: 'checkPopperPlacement',
		enabled: true,
		phase: 'main',
		fn({ state }) {
			$$invalidate(5, popperPlacement = state.placement);
		}
	};

	const open = () => $$invalidate(0, isOpen = true);
	const close = () => $$invalidate(0, isOpen = false);
	const toggle = () => $$invalidate(0, isOpen = !isOpen);

	SvelteInternal.onMount(() => {
		$$invalidate(18, targetEl = document.querySelector(`#${target}`));

		switch (trigger) {
			case 'hover':
				targetEl.addEventListener('mouseover', open);
				targetEl.addEventListener('mouseleave', close);
				break;
			case 'focus':
				targetEl.addEventListener('focus', open);
				targetEl.addEventListener('blur', close);
				break;
			default:
				targetEl.addEventListener('click', toggle);
				if (dismissible) {
					targetEl.addEventListener('blur', close);
				}
				break;
		}

		return () => {
			switch (trigger) {
				case 'hover':
					targetEl.removeEventListener('mouseover', open);
					targetEl.removeEventListener('mouseleave', close);
					break;
				case 'focus':
					targetEl.removeEventListener('focus', open);
					targetEl.removeEventListener('blur', close);
					break;
				default:
					targetEl.removeEventListener('click', toggle);
					if (dismissible) {
						targetEl.removeEventListener('blur', close);
					}
					break;
			}
		};
	});

	const handleOutsideClick = event => {
		if (isOpen && hideOnOutsideClick && !popoverEl.contains(event.target)) {
			$$invalidate(0, isOpen = false);
		}
	};

	function div2_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			popoverEl = $$value;
			$$invalidate(4, popoverEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(10, className = $$new_props.class);
		if ('animation' in $$new_props) $$invalidate(11, animation = $$new_props.animation);
		if ('children' in $$new_props) $$invalidate(1, children = $$new_props.children);
		if ('container' in $$new_props) $$invalidate(12, container = $$new_props.container);
		if ('dismissible' in $$new_props) $$invalidate(13, dismissible = $$new_props.dismissible);
		if ('hideOnOutsideClick' in $$new_props) $$invalidate(14, hideOnOutsideClick = $$new_props.hideOnOutsideClick);
		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ('placement' in $$new_props) $$invalidate(15, placement = $$new_props.placement);
		if ('target' in $$new_props) $$invalidate(16, target = $$new_props.target);
		if ('theme' in $$new_props) $$invalidate(2, theme = $$new_props.theme);
		if ('title' in $$new_props) $$invalidate(3, title = $$new_props.title);
		if ('trigger' in $$new_props) $$invalidate(17, trigger = $$new_props.trigger);
		if ('$$scope' in $$new_props) $$invalidate(23, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*isOpen, popoverEl, targetEl, placement, popperInstance*/ 819217) {
			{
				if (isOpen && popoverEl) {
					$$invalidate(19, popperInstance = createPopper(targetEl, popoverEl, {
						placement,
						modifiers: [
							checkPopperPlacement,
							{
								name: 'offset',
								options: {
									offset: () => {
										return [0, 8];
									}
								}
							}
						]
					}));
				} else if (popperInstance) {
					popperInstance.destroy();
					$$invalidate(19, popperInstance = undefined);
				}
			}
		}

		if ($$self.$$.dirty & /*target*/ 65536) {
			if (!target) {
				throw new Error('Need target!');
			}
		}

		if ($$self.$$.dirty & /*popperPlacement*/ 32) {
			{
				if (popperPlacement === 'left') {
					$$invalidate(20, bsPlacement = 'start');
				} else if (popperPlacement === 'right') {
					$$invalidate(20, bsPlacement = 'end');
				} else {
					$$invalidate(20, bsPlacement = popperPlacement);
				}
			}
		}

		if ($$self.$$.dirty & /*className, animation, bsPlacement, isOpen*/ 1051649) {
			$$invalidate(7, classes = classnames(className, 'popover', animation ? 'fade' : false, `bs-popover-${bsPlacement}`, isOpen ? 'show' : false));
		}

		if ($$self.$$.dirty & /*container*/ 4096) {
			$$invalidate(6, outer = container === 'inline' ? NodeModulesSveltestrapSveltestrapDistInlineContainerInlineContainerSvelte : NodeModulesSveltestrapSveltestrapDistPortalPortalSvelte);
		}
	};

	return [
		isOpen,
		children,
		theme,
		title,
		popoverEl,
		popperPlacement,
		outer,
		classes,
		handleOutsideClick,
		$$restProps,
		className,
		animation,
		container,
		dismissible,
		hideOnOutsideClick,
		placement,
		target,
		trigger,
		targetEl,
		popperInstance,
		bsPlacement,
		slots,
		div2_binding,
		$$scope
	];
}

class NodeModulesSveltestrapSveltestrapDistPopoverPopoverSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$i, create_fragment$i, SvelteInternal.safe_not_equal, {
			class: 10,
			animation: 11,
			children: 1,
			container: 12,
			dismissible: 13,
			hideOnOutsideClick: 14,
			isOpen: 0,
			placement: 15,
			target: 16,
			theme: 2,
			title: 3,
			trigger: 17
		});
	}

	get class() {
		return this.$$.ctx[10];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get animation() {
		return this.$$.ctx[11];
	}

	set animation(animation) {
		this.$$set({ animation });
		SvelteInternal.flush();
	}

	get children() {
		return this.$$.ctx[1];
	}

	set children(children) {
		this.$$set({ children });
		SvelteInternal.flush();
	}

	get container() {
		return this.$$.ctx[12];
	}

	set container(container) {
		this.$$set({ container });
		SvelteInternal.flush();
	}

	get dismissible() {
		return this.$$.ctx[13];
	}

	set dismissible(dismissible) {
		this.$$set({ dismissible });
		SvelteInternal.flush();
	}

	get hideOnOutsideClick() {
		return this.$$.ctx[14];
	}

	set hideOnOutsideClick(hideOnOutsideClick) {
		this.$$set({ hideOnOutsideClick });
		SvelteInternal.flush();
	}

	get isOpen() {
		return this.$$.ctx[0];
	}

	set isOpen(isOpen) {
		this.$$set({ isOpen });
		SvelteInternal.flush();
	}

	get placement() {
		return this.$$.ctx[15];
	}

	set placement(placement) {
		this.$$set({ placement });
		SvelteInternal.flush();
	}

	get target() {
		return this.$$.ctx[16];
	}

	set target(target) {
		this.$$set({ target });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[2];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}

	get title() {
		return this.$$.ctx[3];
	}

	set title(title) {
		this.$$set({ title });
		SvelteInternal.flush();
	}

	get trigger() {
		return this.$$.ctx[17];
	}

	set trigger(trigger) {
		this.$$set({ trigger });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistProgressProgressSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block_1(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_2$1, create_else_block_2];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*multi*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let div_levels = [
		/*$$restProps*/ ctx[8],
		{ "data-bs-theme": /*theme*/ ctx[3] },
		{ class: /*classes*/ ctx[7] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if_block.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(div, null);
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				(!current || dirty & /*theme*/ 8) && { "data-bs-theme": /*theme*/ ctx[3] },
				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if_blocks[current_block_type_index].d();
		}
	};
}

// (78:0) {#if bar}
function create_if_block$7(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$4, create_else_block$6];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*multi*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

// (99:4) {:else}
function create_else_block_2(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.attr(div, "class", /*progressBarClasses*/ ctx[6]);
			SvelteInternal.set_style(div, "width", /*percent*/ ctx[5] + "%");
			SvelteInternal.attr(div, "data-bs-theme", /*theme*/ ctx[3]);
			SvelteInternal.attr(div, "role", "progressbar");
			SvelteInternal.attr(div, "aria-valuenow", /*value*/ ctx[4]);
			SvelteInternal.attr(div, "aria-valuemin", "0");
			SvelteInternal.attr(div, "aria-valuemax", /*max*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*progressBarClasses*/ 64) {
				SvelteInternal.attr(div, "class", /*progressBarClasses*/ ctx[6]);
			}

			if (!current || dirty & /*percent*/ 32) {
				SvelteInternal.set_style(div, "width", /*percent*/ ctx[5] + "%");
			}

			if (!current || dirty & /*theme*/ 8) {
				SvelteInternal.attr(div, "data-bs-theme", /*theme*/ ctx[3]);
			}

			if (!current || dirty & /*value*/ 16) {
				SvelteInternal.attr(div, "aria-valuenow", /*value*/ ctx[4]);
			}

			if (!current || dirty & /*max*/ 2) {
				SvelteInternal.attr(div, "aria-valuemax", /*max*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (97:4) {#if multi}
function create_if_block_2$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (81:2) {:else}
function create_else_block$6(ctx) {
	let div;
	let div_style_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	let div_levels = [
		/*$$restProps*/ ctx[8],
		{ class: /*progressBarClasses*/ ctx[6] },
		{
			style: div_style_value = "width: " + /*percent*/ ctx[5] + "%"
		},
		{ "data-bs-theme": /*theme*/ ctx[3] },
		{ role: "progressbar" },
		{ "aria-valuenow": /*value*/ ctx[4] },
		{ "aria-valuemin": "0" },
		{ "aria-valuemax": /*max*/ ctx[1] }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				(!current || dirty & /*progressBarClasses*/ 64) && { class: /*progressBarClasses*/ ctx[6] },
				(!current || dirty & /*percent*/ 32 && div_style_value !== (div_style_value = "width: " + /*percent*/ ctx[5] + "%")) && { style: div_style_value },
				(!current || dirty & /*theme*/ 8) && { "data-bs-theme": /*theme*/ ctx[3] },
				{ role: "progressbar" },
				(!current || dirty & /*value*/ 16) && { "aria-valuenow": /*value*/ ctx[4] },
				{ "aria-valuemin": "0" },
				(!current || dirty & /*max*/ 2) && { "aria-valuemax": /*max*/ ctx[1] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (79:2) {#if multi}
function create_if_block_1$4(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$h(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$7, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*bar*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	let classes;
	let progressBarClasses;
	let percent;

	const omit_props_names = [
		"animated","bar","barClassName","class","color","max","multi","striped","theme","value"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { animated = false } = $$props;
	let { bar = false } = $$props;
	let { barClassName = '' } = $$props;
	let { class: className = '' } = $$props;
	let { color = '' } = $$props;
	let { max = 100 } = $$props;
	let { multi = false } = $$props;
	let { striped = false } = $$props;
	let { theme = null } = $$props;
	let { value = 0 } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('animated' in $$new_props) $$invalidate(9, animated = $$new_props.animated);
		if ('bar' in $$new_props) $$invalidate(0, bar = $$new_props.bar);
		if ('barClassName' in $$new_props) $$invalidate(10, barClassName = $$new_props.barClassName);
		if ('class' in $$new_props) $$invalidate(11, className = $$new_props.class);
		if ('color' in $$new_props) $$invalidate(12, color = $$new_props.color);
		if ('max' in $$new_props) $$invalidate(1, max = $$new_props.max);
		if ('multi' in $$new_props) $$invalidate(2, multi = $$new_props.multi);
		if ('striped' in $$new_props) $$invalidate(13, striped = $$new_props.striped);
		if ('theme' in $$new_props) $$invalidate(3, theme = $$new_props.theme);
		if ('value' in $$new_props) $$invalidate(4, value = $$new_props.value);
		if ('$$scope' in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 2048) {
			$$invalidate(7, classes = classnames(className, 'progress'));
		}

		if ($$self.$$.dirty & /*bar, className, barClassName, animated, color, striped*/ 15873) {
			$$invalidate(6, progressBarClasses = classnames('progress-bar', bar ? className || barClassName : barClassName, animated ? 'progress-bar-animated' : null, color ? `text-bg-${color}` : null, striped || animated ? 'progress-bar-striped' : null));
		}

		if ($$self.$$.dirty & /*value, max*/ 18) {
			$$invalidate(5, percent = parseInt(value, 10) / parseInt(max, 10) * 100);
		}
	};

	return [
		bar,
		max,
		multi,
		theme,
		value,
		percent,
		progressBarClasses,
		classes,
		$$restProps,
		animated,
		barClassName,
		className,
		color,
		striped,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistProgressProgressSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$h, create_fragment$h, SvelteInternal.safe_not_equal, {
			animated: 9,
			bar: 0,
			barClassName: 10,
			class: 11,
			color: 12,
			max: 1,
			multi: 2,
			striped: 13,
			theme: 3,
			value: 4
		});
	}

	get animated() {
		return this.$$.ctx[9];
	}

	set animated(animated) {
		this.$$set({ animated });
		SvelteInternal.flush();
	}

	get bar() {
		return this.$$.ctx[0];
	}

	set bar(bar) {
		this.$$set({ bar });
		SvelteInternal.flush();
	}

	get barClassName() {
		return this.$$.ctx[10];
	}

	set barClassName(barClassName) {
		this.$$set({ barClassName });
		SvelteInternal.flush();
	}

	get class() {
		return this.$$.ctx[11];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get color() {
		return this.$$.ctx[12];
	}

	set color(color) {
		this.$$set({ color });
		SvelteInternal.flush();
	}

	get max() {
		return this.$$.ctx[1];
	}

	set max(max) {
		this.$$set({ max });
		SvelteInternal.flush();
	}

	get multi() {
		return this.$$.ctx[2];
	}

	set multi(multi) {
		this.$$set({ multi });
		SvelteInternal.flush();
	}

	get striped() {
		return this.$$.ctx[13];
	}

	set striped(striped) {
		this.$$set({ striped });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[3];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}

	get value() {
		return this.$$.ctx[4];
	}

	set value(value) {
		this.$$set({ value });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistRowRowSvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$g(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	let div_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[9](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[9](null);
		}
	};
}

function getCols(cols) {
	const colsValue = parseInt(cols);

	if (!isNaN(colsValue)) {
		if (colsValue > 0) {
			return [`row-cols-${colsValue}`];
		}
	} else if (typeof cols === 'object') {
		return ['xs', 'sm', 'md', 'lg', 'xl'].map(colWidth => {
			const isXs = colWidth === 'xs';
			const colSizeInterfix = isXs ? '-' : `-${colWidth}-`;
			const value = cols[colWidth];

			if (typeof value === 'number' && value > 0) {
				return `row-cols${colSizeInterfix}${value}`;
			}

			return null;
		}).filter(value => !!value);
	}

	return [];
}

function instance$g($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","noGutters","form","cols","inner"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { noGutters = false } = $$props;
	let { form = false } = $$props;
	let { cols = 0 } = $$props;
	let { inner = undefined } = $$props;

	function div_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inner = $$value;
			$$invalidate(0, inner);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('noGutters' in $$new_props) $$invalidate(4, noGutters = $$new_props.noGutters);
		if ('form' in $$new_props) $$invalidate(5, form = $$new_props.form);
		if ('cols' in $$new_props) $$invalidate(6, cols = $$new_props.cols);
		if ('inner' in $$new_props) $$invalidate(0, inner = $$new_props.inner);
		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, noGutters, form, cols*/ 120) {
			$$invalidate(1, classes = classnames(className, noGutters ? 'gx-0' : null, form ? 'form-row' : 'row', ...getCols(cols)));
		}
	};

	return [
		inner,
		classes,
		$$restProps,
		className,
		noGutters,
		form,
		cols,
		$$scope,
		slots,
		div_binding
	];
}

class NodeModulesSveltestrapSveltestrapDistRowRowSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$g, create_fragment$g, SvelteInternal.safe_not_equal, {
			class: 3,
			noGutters: 4,
			form: 5,
			cols: 6,
			inner: 0
		});
	}

	get class() {
		return this.$$.ctx[3];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get noGutters() {
		return this.$$.ctx[4];
	}

	set noGutters(noGutters) {
		this.$$set({ noGutters });
		SvelteInternal.flush();
	}

	get form() {
		return this.$$.ctx[5];
	}

	set form(form) {
		this.$$set({ form });
		SvelteInternal.flush();
	}

	get cols() {
		return this.$$.ctx[6];
	}

	set cols(cols) {
		this.$$set({ cols });
		SvelteInternal.flush();
	}

	get inner() {
		return this.$$.ctx[0];
	}

	set inner(inner) {
		this.$$set({ inner });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistSpinnerSpinnerSvelte.svelte generated by Svelte v4.2.8 */


function fallback_block$1(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text("Loading...");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

function create_fragment$f(ctx) {
	let div;
	let span;
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	const default_slot_or_fallback = default_slot || fallback_block$1();
	let div_levels = [/*$$restProps*/ ctx[1], { role: "status" }, { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			span = SvelteInternal.element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			SvelteInternal.attr(span, "class", "visually-hidden");
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			SvelteInternal.append(div, span);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				{ role: "status" },
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","type","size","color"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { type = 'border' } = $$props;
	let { size = '' } = $$props;
	let { color = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('type' in $$new_props) $$invalidate(3, type = $$new_props.type);
		if ('size' in $$new_props) $$invalidate(4, size = $$new_props.size);
		if ('color' in $$new_props) $$invalidate(5, color = $$new_props.color);
		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, size, type, color*/ 60) {
			$$invalidate(0, classes = classnames(className, size ? `spinner-${type}-${size}` : false, `spinner-${type}`, color ? `text-${color}` : false));
		}
	};

	return [classes, $$restProps, className, type, size, color, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistSpinnerSpinnerSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$f, create_fragment$f, SvelteInternal.safe_not_equal, { class: 2, type: 3, size: 4, color: 5 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get type() {
		return this.$$.ctx[3];
	}

	set type(type) {
		this.$$set({ type });
		SvelteInternal.flush();
	}

	get size() {
		return this.$$.ctx[4];
	}

	set size(size) {
		this.$$set({ size });
		SvelteInternal.flush();
	}

	get color() {
		return this.$$.ctx[5];
	}

	set color(color) {
		this.$$set({ color });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistStylesStylesSvelte.svelte generated by Svelte v4.2.8 */


const { document: document_1 } = SvelteInternal.globals;


function create_if_block$6(ctx) {
	let link;

	return {
		c() {
			link = SvelteInternal.element("link");
			SvelteInternal.attr(link, "rel", "stylesheet");
			SvelteInternal.attr(link, "href", "https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.2/font/bootstrap-icons.min.css");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, link, anchor);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(link);
			}
		}
	};
}

function create_fragment$e(ctx) {
	let link;
	let if_block_anchor;
	let if_block = /*icons*/ ctx[0] && create_if_block$6();

	return {
		c() {
			link = SvelteInternal.element("link");
			if (if_block) if_block.c();
			if_block_anchor = SvelteInternal.empty();
			SvelteInternal.attr(link, "rel", "stylesheet");
			SvelteInternal.attr(link, "href", "https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css");
		},
		m(target, anchor) {
			SvelteInternal.append(document_1.head, link);
			if (if_block) if_block.m(document_1.head, null);
			SvelteInternal.append(document_1.head, if_block_anchor);
		},
		p(ctx, [dirty]) {
			if (/*icons*/ ctx[0]) {
				if (if_block) ; else {
					if_block = create_if_block$6();
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			SvelteInternal.detach(link);
			if (if_block) if_block.d(detaching);
			SvelteInternal.detach(if_block_anchor);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	let { icons = true } = $$props;
	let { theme = undefined } = $$props;

	$$self.$$set = $$props => {
		if ('icons' in $$props) $$invalidate(0, icons = $$props.icons);
		if ('theme' in $$props) $$invalidate(1, theme = $$props.theme);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*theme*/ 2) {
			if (typeof document !== 'undefined' && theme !== undefined) {
				if (theme === 'auto' && window.matchMedia('(prefers-color-scheme: dark)').matches) {
					document.documentElement.setAttribute('data-bs-theme', 'dark');
				} else {
					document.documentElement.setAttribute('data-bs-theme', theme);
				}
			}
		}
	};

	return [icons, theme];
}

class NodeModulesSveltestrapSveltestrapDistStylesStylesSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$e, create_fragment$e, SvelteInternal.safe_not_equal, { icons: 0, theme: 1 });
	}

	get icons() {
		return this.$$.ctx[0];
	}

	set icons(icons) {
		this.$$set({ icons });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[1];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistColgroupColgroupSvelte.svelte generated by Svelte v4.2.8 */





function create_fragment$d(ctx) {
	let colgroup;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			colgroup = SvelteInternal.element("colgroup");
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			SvelteInternal.insert(target, colgroup, anchor);

			if (default_slot) {
				default_slot.m(colgroup, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(colgroup);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	SvelteInternal.setContext('colgroup', true);

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistColgroupColgroupSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$d, create_fragment$d, SvelteInternal.safe_not_equal, {});
	}
}

/* nodeModulesSveltestrapSveltestrapDistResponsiveContainerResponsiveContainerSvelte.svelte generated by Svelte v4.2.8 */


function create_else_block$5(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (14:0) {#if responsive}
function create_if_block$5(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.attr(div, "class", /*responsiveClassName*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*responsiveClassName*/ 2) {
				SvelteInternal.attr(div, "class", /*responsiveClassName*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$c(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$5, create_else_block$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*responsive*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	let responsiveClassName;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { responsive = false } = $$props;

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(2, className = $$props.class);
		if ('responsive' in $$props) $$invalidate(0, responsive = $$props.responsive);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, responsive*/ 5) {
			$$invalidate(1, responsiveClassName = classnames(className, {
				'table-responsive': responsive === true,
				[`table-responsive-${responsive}`]: typeof responsive === 'string'
			}));
		}
	};

	return [responsive, responsiveClassName, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistResponsiveContainerResponsiveContainerSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$c, create_fragment$c, SvelteInternal.safe_not_equal, { class: 2, responsive: 0 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get responsive() {
		return this.$$.ctx[0];
	}

	set responsive(responsive) {
		this.$$set({ responsive });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistTableFooterTableFooterSvelte.svelte generated by Svelte v4.2.8 */





function create_fragment$b(ctx) {
	let tfoot;
	let tr;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);
	let tfoot_levels = [/*$$restProps*/ ctx[0]];
	let tfoot_data = {};

	for (let i = 0; i < tfoot_levels.length; i += 1) {
		tfoot_data = SvelteInternal.assign(tfoot_data, tfoot_levels[i]);
	}

	return {
		c() {
			tfoot = SvelteInternal.element("tfoot");
			tr = SvelteInternal.element("tr");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(tfoot, tfoot_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, tfoot, anchor);
			SvelteInternal.append(tfoot, tr);

			if (default_slot) {
				default_slot.m(tr, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(tfoot, tfoot_data = SvelteInternal.get_spread_update(tfoot_levels, [dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0]]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(tfoot);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	SvelteInternal.setContext('footer', true);

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(0, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('$$scope' in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
	};

	return [$$restProps, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistTableFooterTableFooterSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$b, create_fragment$b, SvelteInternal.safe_not_equal, {});
	}
}

/* nodeModulesSveltestrapSveltestrapDistTableHeaderTableHeaderSvelte.svelte generated by Svelte v4.2.8 */





function create_fragment$a(ctx) {
	let thead;
	let tr;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);
	let thead_levels = [/*$$restProps*/ ctx[0]];
	let thead_data = {};

	for (let i = 0; i < thead_levels.length; i += 1) {
		thead_data = SvelteInternal.assign(thead_data, thead_levels[i]);
	}

	return {
		c() {
			thead = SvelteInternal.element("thead");
			tr = SvelteInternal.element("tr");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(thead, thead_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, thead, anchor);
			SvelteInternal.append(thead, tr);

			if (default_slot) {
				default_slot.m(tr, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(thead, thead_data = SvelteInternal.get_spread_update(thead_levels, [dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0]]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(thead);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	SvelteInternal.setContext('header', true);

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(0, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('$$scope' in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
	};

	return [$$restProps, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistTableHeaderTableHeaderSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$a, create_fragment$a, SvelteInternal.safe_not_equal, {});
	}
}

/* nodeModulesSveltestrapSveltestrapDistTableTableSvelte.svelte generated by Svelte v4.2.8 */


function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

const get_default_slot_changes$1 = dirty => ({ row: dirty & /*rows*/ 2 });
const get_default_slot_context$1 = ctx => ({ row: /*row*/ ctx[12] });

// (88:4) {:else}
function create_else_block$4(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (71:4) {#if rows}
function create_if_block$4(ctx) {
	let colgroup;
	let t0;
	let tableheader;
	let t1;
	let tbody;
	let t2;
	let tablefooter;
	let current;

	colgroup = new NodeModulesSveltestrapSveltestrapDistColgroupColgroupSvelte({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	tableheader = new NodeModulesSveltestrapSveltestrapDistTableHeaderTableHeaderSvelte({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	let each_value = SvelteInternal.ensure_array_like(/*rows*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => SvelteInternal.transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	tablefooter = new NodeModulesSveltestrapSveltestrapDistTableFooterTableFooterSvelte({
			props: {
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			SvelteInternal.create_component(colgroup.$$.fragment);
			t0 = SvelteInternal.space();
			SvelteInternal.create_component(tableheader.$$.fragment);
			t1 = SvelteInternal.space();
			tbody = SvelteInternal.element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = SvelteInternal.space();
			SvelteInternal.create_component(tablefooter.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(colgroup, target, anchor);
			SvelteInternal.insert(target, t0, anchor);
			SvelteInternal.mount_component(tableheader, target, anchor);
			SvelteInternal.insert(target, t1, anchor);
			SvelteInternal.insert(target, tbody, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(tbody, null);
				}
			}

			SvelteInternal.insert(target, t2, anchor);
			SvelteInternal.mount_component(tablefooter, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const colgroup_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				colgroup_changes.$$scope = { dirty, ctx };
			}

			colgroup.$set(colgroup_changes);
			const tableheader_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				tableheader_changes.$$scope = { dirty, ctx };
			}

			tableheader.$set(tableheader_changes);

			if (dirty & /*$$scope, rows*/ 2050) {
				each_value = SvelteInternal.ensure_array_like(/*rows*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						SvelteInternal.transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						SvelteInternal.transition_in(each_blocks[i], 1);
						each_blocks[i].m(tbody, null);
					}
				}

				SvelteInternal.group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				SvelteInternal.check_outros();
			}

			const tablefooter_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				tablefooter_changes.$$scope = { dirty, ctx };
			}

			tablefooter.$set(tablefooter_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(colgroup.$$.fragment, local);
			SvelteInternal.transition_in(tableheader.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				SvelteInternal.transition_in(each_blocks[i]);
			}

			SvelteInternal.transition_in(tablefooter.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(colgroup.$$.fragment, local);
			SvelteInternal.transition_out(tableheader.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				SvelteInternal.transition_out(each_blocks[i]);
			}

			SvelteInternal.transition_out(tablefooter.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t0);
				SvelteInternal.detach(t1);
				SvelteInternal.detach(tbody);
				SvelteInternal.detach(t2);
			}

			SvelteInternal.destroy_component(colgroup, detaching);
			SvelteInternal.destroy_component(tableheader, detaching);
			SvelteInternal.destroy_each(each_blocks, detaching);
			SvelteInternal.destroy_component(tablefooter, detaching);
		}
	};
}

// (72:6) <Colgroup>
function create_default_slot_3(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (75:6) <TableHeader>
function create_default_slot_2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (79:8) {#each rows as row}
function create_each_block(ctx) {
	let tr;
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], get_default_slot_context$1);

	return {
		c() {
			tr = SvelteInternal.element("tr");
			if (default_slot) default_slot.c();
			t = SvelteInternal.space();
		},
		m(target, anchor) {
			SvelteInternal.insert(target, tr, anchor);

			if (default_slot) {
				default_slot.m(tr, null);
			}

			SvelteInternal.append(tr, t);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, rows*/ 2050)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, get_default_slot_changes$1),
						get_default_slot_context$1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(tr);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (85:6) <TableFooter>
function create_default_slot_1$2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (69:0) <ResponsiveContainer {responsive}>
function create_default_slot$5(ctx) {
	let table;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$4, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*rows*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let table_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
	let table_data = {};

	for (let i = 0; i < table_levels.length; i += 1) {
		table_data = SvelteInternal.assign(table_data, table_levels[i]);
	}

	return {
		c() {
			table = SvelteInternal.element("table");
			if_block.c();
			SvelteInternal.set_attributes(table, table_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, table, anchor);
			if_blocks[current_block_type_index].m(table, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(table, null);
			}

			SvelteInternal.set_attributes(table, table_data = SvelteInternal.get_spread_update(table_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(table);
			}

			if_blocks[current_block_type_index].d();
		}
	};
}

function create_fragment$9(ctx) {
	let responsivecontainer;
	let current;

	responsivecontainer = new NodeModulesSveltestrapSveltestrapDistResponsiveContainerResponsiveContainerSvelte({
			props: {
				responsive: /*responsive*/ ctx[0],
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			SvelteInternal.create_component(responsivecontainer.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(responsivecontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const responsivecontainer_changes = {};
			if (dirty & /*responsive*/ 1) responsivecontainer_changes.responsive = /*responsive*/ ctx[0];

			if (dirty & /*$$scope, $$restProps, classes, rows*/ 2062) {
				responsivecontainer_changes.$$scope = { dirty, ctx };
			}

			responsivecontainer.$set(responsivecontainer_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(responsivecontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(responsivecontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(responsivecontainer, detaching);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","size","bordered","borderless","striped","hover","responsive","rows"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { size = '' } = $$props;
	let { bordered = false } = $$props;
	let { borderless = false } = $$props;
	let { striped = false } = $$props;
	let { hover = false } = $$props;
	let { responsive = false } = $$props;
	let { rows = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('size' in $$new_props) $$invalidate(5, size = $$new_props.size);
		if ('bordered' in $$new_props) $$invalidate(6, bordered = $$new_props.bordered);
		if ('borderless' in $$new_props) $$invalidate(7, borderless = $$new_props.borderless);
		if ('striped' in $$new_props) $$invalidate(8, striped = $$new_props.striped);
		if ('hover' in $$new_props) $$invalidate(9, hover = $$new_props.hover);
		if ('responsive' in $$new_props) $$invalidate(0, responsive = $$new_props.responsive);
		if ('rows' in $$new_props) $$invalidate(1, rows = $$new_props.rows);
		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, size, bordered, borderless, striped, hover*/ 1008) {
			$$invalidate(2, classes = classnames(className, 'table', size ? 'table-' + size : false, bordered ? 'table-bordered' : false, borderless ? 'table-borderless' : false, striped ? 'table-striped' : false, hover ? 'table-hover' : false));
		}
	};

	return [
		responsive,
		rows,
		classes,
		$$restProps,
		className,
		size,
		bordered,
		borderless,
		striped,
		hover,
		slots,
		$$scope
	];
}

class NodeModulesSveltestrapSveltestrapDistTableTableSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$9, create_fragment$9, SvelteInternal.safe_not_equal, {
			class: 4,
			size: 5,
			bordered: 6,
			borderless: 7,
			striped: 8,
			hover: 9,
			responsive: 0,
			rows: 1
		});
	}

	get class() {
		return this.$$.ctx[4];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get size() {
		return this.$$.ctx[5];
	}

	set size(size) {
		this.$$set({ size });
		SvelteInternal.flush();
	}

	get bordered() {
		return this.$$.ctx[6];
	}

	set bordered(bordered) {
		this.$$set({ bordered });
		SvelteInternal.flush();
	}

	get borderless() {
		return this.$$.ctx[7];
	}

	set borderless(borderless) {
		this.$$set({ borderless });
		SvelteInternal.flush();
	}

	get striped() {
		return this.$$.ctx[8];
	}

	set striped(striped) {
		this.$$set({ striped });
		SvelteInternal.flush();
	}

	get hover() {
		return this.$$.ctx[9];
	}

	set hover(hover) {
		this.$$set({ hover });
		SvelteInternal.flush();
	}

	get responsive() {
		return this.$$.ctx[0];
	}

	set responsive(responsive) {
		this.$$set({ responsive });
		SvelteInternal.flush();
	}

	get rows() {
		return this.$$.ctx[1];
	}

	set rows(rows) {
		this.$$set({ rows });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistTabHeaderTabHeaderSvelte.svelte generated by Svelte v4.2.8 */


function create_default_slot$4(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$8(ctx) {
	let nav;
	let current;
	const nav_spread_levels = [/*$$restProps*/ ctx[0]];

	let nav_props = {
		$$slots: { default: [create_default_slot$4] },
		$$scope: { ctx }
	};

	for (let i = 0; i < nav_spread_levels.length; i += 1) {
		nav_props = SvelteInternal.assign(nav_props, nav_spread_levels[i]);
	}

	nav = new NodeModulesSveltestrapSveltestrapDistNavNavSvelte({ props: nav_props });

	return {
		c() {
			SvelteInternal.create_component(nav.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(nav, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const nav_changes = (dirty & /*$$restProps*/ 1)
			? SvelteInternal.get_spread_update(nav_spread_levels, [SvelteInternal.get_spread_object(/*$$restProps*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 4) {
				nav_changes.$$scope = { dirty, ctx };
			}

			nav.$set(nav_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(nav.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(nav.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(nav, detaching);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	SvelteInternal.setContext('tabs', true);

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(0, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('$$scope' in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
	};

	return [$$restProps, slots, $$scope];
}

class NodeModulesSveltestrapSveltestrapDistTabHeaderTabHeaderSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$8, create_fragment$8, SvelteInternal.safe_not_equal, {});
	}
}

/* nodeModulesSveltestrapSveltestrapDistTabContentTabContentSvelte.svelte generated by Svelte v4.2.8 */


function create_default_slot$3(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$7(ctx) {
	let div;
	let tabheader;
	let t;
	let current;

	tabheader = new NodeModulesSveltestrapSveltestrapDistTabHeaderTabHeaderSvelte({
			props: {
				class: classnames({ 'me-3': /*vertical*/ ctx[1] }),
				pills: /*pills*/ ctx[0],
				tabs: !/*pills*/ ctx[0],
				vertical: /*vertical*/ ctx[1],
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let div_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			SvelteInternal.create_component(tabheader.$$.fragment);
			t = SvelteInternal.space();
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			SvelteInternal.mount_component(tabheader, div, null);
			SvelteInternal.append(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			const tabheader_changes = {};
			if (dirty & /*vertical*/ 2) tabheader_changes.class = classnames({ 'me-3': /*vertical*/ ctx[1] });
			if (dirty & /*pills*/ 1) tabheader_changes.pills = /*pills*/ ctx[0];
			if (dirty & /*pills*/ 1) tabheader_changes.tabs = !/*pills*/ ctx[0];
			if (dirty & /*vertical*/ 2) tabheader_changes.vertical = /*vertical*/ ctx[1];

			if (dirty & /*$$scope*/ 64) {
				tabheader_changes.$$scope = { dirty, ctx };
			}

			tabheader.$set(tabheader_changes);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(tabheader.$$.fragment, local);
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(tabheader.$$.fragment, local);
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			SvelteInternal.destroy_component(tabheader);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","pills","vertical"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = SvelteInternal.createEventDispatcher();
	let { class: className = '' } = $$props;
	let { pills = false } = $$props;
	let { vertical = false } = $$props;
	const activeTabId = SvelteStore.writable();

	SvelteInternal.setContext('tabContent', {
		activeTabId,
		setActiveTab: tabId => {
			activeTabId.set(tabId);
			dispatch('tab', tabId);
		}
	});

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('pills' in $$new_props) $$invalidate(0, pills = $$new_props.pills);
		if ('vertical' in $$new_props) $$invalidate(1, vertical = $$new_props.vertical);
		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, vertical*/ 18) {
			$$invalidate(2, classes = classnames('tab-content', className, { 'd-flex align-items-start': vertical }));
		}
	};

	return [pills, vertical, classes, $$restProps, className, slots, $$scope];
}

class NodeModulesSveltestrapSveltestrapDistTabContentTabContentSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$7, create_fragment$7, SvelteInternal.safe_not_equal, { class: 4, pills: 0, vertical: 1 });
	}

	get class() {
		return this.$$.ctx[4];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get pills() {
		return this.$$.ctx[0];
	}

	set pills(pills) {
		this.$$set({ pills });
		SvelteInternal.flush();
	}

	get vertical() {
		return this.$$.ctx[1];
	}

	set vertical(vertical) {
		this.$$set({ vertical });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistTabPaneTabPaneSvelte.svelte generated by Svelte v4.2.8 */

const get_tab_slot_changes = dirty => ({});
const get_tab_slot_context = ctx => ({});

// (36:0) {:else}
function create_else_block$3(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);
	let div_levels = [/*$$restProps*/ ctx[8], { class: /*classes*/ ctx[4] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (29:0) {#if tabs}
function create_if_block$3(ctx) {
	let navitem;
	let current;

	navitem = new NodeModulesSveltestrapSveltestrapDistNavItemNavItemSvelte({
			props: {
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			SvelteInternal.create_component(navitem.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(navitem, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const navitem_changes = {};

			if (dirty & /*$$scope, tabOpen, disabled, tabId, tab*/ 16399) {
				navitem_changes.$$scope = { dirty, ctx };
			}

			navitem.$set(navitem_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(navitem.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(navitem.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(navitem, detaching);
		}
	};
}

// (32:6) {#if tab}
function create_if_block_1$3(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*tab*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*tab*/ 2) SvelteInternal.set_data(t, /*tab*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (31:4) <NavLink active={tabOpen} {disabled} on:click={() => setActiveTab(tabId)}>
function create_default_slot_1$1(ctx) {
	let t;
	let current;
	let if_block = /*tab*/ ctx[1] && create_if_block_1$3(ctx);
	const tab_slot_template = /*#slots*/ ctx[12].tab;
	const tab_slot = SvelteInternal.create_slot(tab_slot_template, ctx, /*$$scope*/ ctx[14], get_tab_slot_context);

	return {
		c() {
			if (if_block) if_block.c();
			t = SvelteInternal.space();
			if (tab_slot) tab_slot.c();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			SvelteInternal.insert(target, t, anchor);

			if (tab_slot) {
				tab_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*tab*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (tab_slot) {
				if (tab_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					SvelteInternal.update_slot_base(
						tab_slot,
						tab_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: SvelteInternal.get_slot_changes(tab_slot_template, /*$$scope*/ ctx[14], dirty, get_tab_slot_changes),
						get_tab_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(tab_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(tab_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}

			if (if_block) if_block.d(detaching);
			if (tab_slot) tab_slot.d(detaching);
		}
	};
}

// (30:2) <NavItem>
function create_default_slot$2(ctx) {
	let navlink;
	let current;

	navlink = new NodeModulesSveltestrapSveltestrapDistNavLinkNavLinkSvelte({
			props: {
				active: /*tabOpen*/ ctx[3],
				disabled: /*disabled*/ ctx[0],
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			}
		});

	navlink.$on("click", /*click_handler*/ ctx[13]);

	return {
		c() {
			SvelteInternal.create_component(navlink.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(navlink, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const navlink_changes = {};
			if (dirty & /*tabOpen*/ 8) navlink_changes.active = /*tabOpen*/ ctx[3];
			if (dirty & /*disabled*/ 1) navlink_changes.disabled = /*disabled*/ ctx[0];

			if (dirty & /*$$scope, tab*/ 16386) {
				navlink_changes.$$scope = { dirty, ctx };
			}

			navlink.$set(navlink_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(navlink.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(navlink.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(navlink, detaching);
		}
	};
}

function create_fragment$6(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$3, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tabs*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class","active","disabled","tab","tabId"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let $activeTabId;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { active = false } = $$props;
	let { disabled = false } = $$props;
	let { tab = undefined } = $$props;
	let { tabId = undefined } = $$props;
	const tabs = SvelteInternal.getContext('tabs');
	const { activeTabId, setActiveTab } = SvelteInternal.getContext('tabContent');
	SvelteInternal.component_subscribe($$self, activeTabId, value => $$invalidate(11, $activeTabId = value));

	SvelteInternal.onMount(() => {
		if (active) setActiveTab(tabId);
	});

	let tabOpen = active;
	const click_handler = () => setActiveTab(tabId);

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ('active' in $$new_props) $$invalidate(10, active = $$new_props.active);
		if ('disabled' in $$new_props) $$invalidate(0, disabled = $$new_props.disabled);
		if ('tab' in $$new_props) $$invalidate(1, tab = $$new_props.tab);
		if ('tabId' in $$new_props) $$invalidate(2, tabId = $$new_props.tabId);
		if ('$$scope' in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$activeTabId, tabId*/ 2052) {
			if ($activeTabId !== undefined) $$invalidate(3, tabOpen = $activeTabId === tabId);
		}

		if ($$self.$$.dirty & /*className, tabOpen*/ 520) {
			$$invalidate(4, classes = classnames('tab-pane', className, { active: tabOpen, show: tabOpen }));
		}
	};

	return [
		disabled,
		tab,
		tabId,
		tabOpen,
		classes,
		tabs,
		activeTabId,
		setActiveTab,
		$$restProps,
		className,
		active,
		$activeTabId,
		slots,
		click_handler,
		$$scope
	];
}

class NodeModulesSveltestrapSveltestrapDistTabPaneTabPaneSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$6, create_fragment$6, SvelteInternal.safe_not_equal, {
			class: 9,
			active: 10,
			disabled: 0,
			tab: 1,
			tabId: 2
		});
	}

	get class() {
		return this.$$.ctx[9];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get active() {
		return this.$$.ctx[10];
	}

	set active(active) {
		this.$$set({ active });
		SvelteInternal.flush();
	}

	get disabled() {
		return this.$$.ctx[0];
	}

	set disabled(disabled) {
		this.$$set({ disabled });
		SvelteInternal.flush();
	}

	get tab() {
		return this.$$.ctx[1];
	}

	set tab(tab) {
		this.$$set({ tab });
		SvelteInternal.flush();
	}

	get tabId() {
		return this.$$.ctx[2];
	}

	set tabId(tabId) {
		this.$$set({ tabId });
		SvelteInternal.flush();
	}
}

const colorMode = SvelteStore.writable(getInitialColorMode());

colorMode.subscribe((mode) => useColorMode(mode));

function getInitialColorMode() {
  const currentTheme = globalThis.document?.documentElement.getAttribute('data-bs-theme') || 'light';
  const prefersDarkMode =
    typeof globalThis.window?.matchMedia === 'function'
      ? globalThis.window?.matchMedia('(prefers-color-scheme: dark)').matches
      : false;

  return currentTheme === 'dark' || (currentTheme === 'auto' && prefersDarkMode) ? 'dark' : 'light';
}

function useColorMode(element, mode) {
  let target = element;

  if (arguments.length === 1) {
    target = globalThis.document?.documentElement;

    if (!target) {
      return;
    }

    mode = element;
    colorMode.update(() => mode);
  }

  target.setAttribute('data-bs-theme', mode);
}

function toggleColorMode(element) {
  const target = element || globalThis.document?.documentElement;

  if (!target) {
    return;
  }

  const currentMode = target.getAttribute('data-bs-theme');
  const newMode = currentMode === 'dark' ? 'light' : 'dark';

  if (!element) {
    colorMode.update(() => newMode);
  }

  target.setAttribute('data-bs-theme', newMode);
}

function add_css(target) {
	SvelteInternal.append_styles(target, "svelte-f2gsno", "span.svelte-f2gsno{display:contents}");
}

function create_fragment$5(ctx) {
	let span;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			span = SvelteInternal.element("span");
			if (default_slot) default_slot.c();
			SvelteInternal.attr(span, "class", "svelte-f2gsno");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			/*span_binding*/ ctx[4](span);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(span);
			}

			if (default_slot) default_slot.d(detaching);
			/*span_binding*/ ctx[4](null);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { theme = 'dark' } = $$props;
	let ref = null;

	function span_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('theme' in $$props) $$invalidate(1, theme = $$props.theme);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*ref, theme*/ 3) {
			ref && useColorMode(ref, theme);
		}
	};

	return [ref, theme, $$scope, slots, span_binding];
}

class NodeModulesSveltestrapSveltestrapDistThemeThemeSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$5, create_fragment$5, SvelteInternal.safe_not_equal, { theme: 1 }, add_css);
	}

	get theme() {
		return this.$$.ctx[1];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}
}
(() => {
if (typeof document !== "undefined") {
const styleSheet = document.createElement("style");
styleSheet.innerText = decodeURI(`span.svelte-f2gsno%7Bdisplay:contents%7D`);
document.head.appendChild(styleSheet);
}
                        })();

/* nodeModulesSveltestrapSveltestrapDistThemeThemeTogglerSvelte.svelte generated by Svelte v4.2.8 */


const get_default_slot_changes = dirty => ({
	currentColorMode: dirty & /*currentColorMode*/ 1
});

const get_default_slot_context = ctx => ({
	currentColorMode: /*currentColorMode*/ ctx[0],
	toggleColorMode
});

function create_fragment$4(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], get_default_slot_context);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, currentColorMode*/ 3)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, get_default_slot_changes),
						get_default_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let $colorMode;
	SvelteInternal.component_subscribe($$self, colorMode, $$value => $$invalidate(3, $colorMode = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	let currentColorMode = $colorMode;

	colorMode.subscribe(value => {
		$$invalidate(0, currentColorMode = value);
	});

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [currentColorMode, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistThemeThemeTogglerSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$4, create_fragment$4, SvelteInternal.safe_not_equal, {});
	}
}

/* nodeModulesSveltestrapSveltestrapDistToastBodyToastBodySvelte.svelte generated by Svelte v4.2.8 */


function create_fragment$3(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (default_slot) default_slot.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["class"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 4) {
			$$invalidate(0, classes = classnames(className, 'toast-body'));
		}
	};

	return [classes, $$restProps, className, $$scope, slots];
}

class NodeModulesSveltestrapSveltestrapDistToastBodyToastBodySvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();
		SvelteInternal.init(this, options, instance$3, create_fragment$3, SvelteInternal.safe_not_equal, { class: 2 });
	}

	get class() {
		return this.$$.ctx[2];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistToastHeaderToastHeaderSvelte.svelte generated by Svelte v4.2.8 */

const get_close_slot_changes = dirty => ({});
const get_close_slot_context = ctx => ({});
const get_icon_slot_changes = dirty => ({});
const get_icon_slot_context = ctx => ({});

// (29:2) {:else}
function create_else_block$2(ctx) {
	let current;
	const icon_slot_template = /*#slots*/ ctx[8].icon;
	const icon_slot = SvelteInternal.create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[7], get_icon_slot_context);

	return {
		c() {
			if (icon_slot) icon_slot.c();
		},
		m(target, anchor) {
			if (icon_slot) {
				icon_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (icon_slot) {
				if (icon_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					SvelteInternal.update_slot_base(
						icon_slot,
						icon_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: SvelteInternal.get_slot_changes(icon_slot_template, /*$$scope*/ ctx[7], dirty, get_icon_slot_changes),
						get_icon_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(icon_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(icon_slot, local);
			current = false;
		},
		d(detaching) {
			if (icon_slot) icon_slot.d(detaching);
		}
	};
}

// (17:2) {#if icon}
function create_if_block_1$2(ctx) {
	let svg;
	let rect;
	let svg_class_value;

	return {
		c() {
			svg = SvelteInternal.svg_element("svg");
			rect = SvelteInternal.svg_element("rect");
			SvelteInternal.attr(rect, "fill", "currentColor");
			SvelteInternal.attr(rect, "width", "100%");
			SvelteInternal.attr(rect, "height", "100%");
			SvelteInternal.attr(svg, "class", svg_class_value = `rounded text-${/*icon*/ ctx[0]}`);
			SvelteInternal.attr(svg, "width", "20");
			SvelteInternal.attr(svg, "height", "20");
			SvelteInternal.attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			SvelteInternal.attr(svg, "preserveAspectRatio", "xMidYMid slice");
			SvelteInternal.attr(svg, "focusable", "false");
			SvelteInternal.attr(svg, "role", "img");
		},
		m(target, anchor) {
			SvelteInternal.insert(target, svg, anchor);
			SvelteInternal.append(svg, rect);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 1 && svg_class_value !== (svg_class_value = `rounded text-${/*icon*/ ctx[0]}`)) {
				SvelteInternal.attr(svg, "class", svg_class_value);
			}
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(svg);
			}
		}
	};
}

// (35:2) {#if toggle}
function create_if_block$2(ctx) {
	let current;
	const close_slot_template = /*#slots*/ ctx[8].close;
	const close_slot = SvelteInternal.create_slot(close_slot_template, ctx, /*$$scope*/ ctx[7], get_close_slot_context);
	const close_slot_or_fallback = close_slot || fallback_block(ctx);

	return {
		c() {
			if (close_slot_or_fallback) close_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (close_slot_or_fallback) {
				close_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (close_slot) {
				if (close_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					SvelteInternal.update_slot_base(
						close_slot,
						close_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: SvelteInternal.get_slot_changes(close_slot_template, /*$$scope*/ ctx[7], dirty, get_close_slot_changes),
						get_close_slot_context
					);
				}
			} else {
				if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & /*closeAriaLabel, toggle*/ 6)) {
					close_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(close_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(close_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (close_slot_or_fallback) close_slot_or_fallback.d(detaching);
		}
	};
}

// (36:23)        
function fallback_block(ctx) {
	let button;
	let current;

	button = new NodeModulesSveltestrapSveltestrapDistButtonButtonSvelte({
			props: {
				close: true,
				"aria-label": /*closeAriaLabel*/ ctx[2]
			}
		});

	button.$on("click", function () {
		if (SvelteInternal.is_function(/*toggle*/ ctx[1])) /*toggle*/ ctx[1].apply(this, arguments);
	});

	return {
		c() {
			SvelteInternal.create_component(button.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(button, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty & /*closeAriaLabel*/ 4) button_changes["aria-label"] = /*closeAriaLabel*/ ctx[2];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(button, detaching);
		}
	};
}

function create_fragment$2(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t0;
	let strong;
	let t1;
	let current;
	const if_block_creators = [create_if_block_1$2, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*icon*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	let if_block1 = /*toggle*/ ctx[1] && create_if_block$2(ctx);
	let div_levels = [/*$$restProps*/ ctx[5], { class: /*classes*/ ctx[4] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if_block0.c();
			t0 = SvelteInternal.space();
			strong = SvelteInternal.element("strong");
			if (default_slot) default_slot.c();
			t1 = SvelteInternal.space();
			if (if_block1) if_block1.c();
			SvelteInternal.attr(strong, "class", /*tagClassName*/ ctx[3]);
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			SvelteInternal.append(div, t0);
			SvelteInternal.append(div, strong);

			if (default_slot) {
				default_slot.m(strong, null);
			}

			SvelteInternal.append(div, t1);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block0, 1);
				if_block0.m(div, t0);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*tagClassName*/ 8) {
				SvelteInternal.attr(strong, "class", /*tagClassName*/ ctx[3]);
			}

			if (/*toggle*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*toggle*/ 2) {
						SvelteInternal.transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$2(ctx);
					if_block1.c();
					SvelteInternal.transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				SvelteInternal.check_outros();
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5],
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block0);
			SvelteInternal.transition_in(default_slot, local);
			SvelteInternal.transition_in(if_block1);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block0);
			SvelteInternal.transition_out(default_slot, local);
			SvelteInternal.transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if_blocks[current_block_type_index].d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let classes;
	let tagClassName;
	const omit_props_names = ["class","icon","toggle","closeAriaLabel"];
	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { icon = null } = $$props;
	let { toggle = null } = $$props;
	let { closeAriaLabel = 'Close' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(5, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('icon' in $$new_props) $$invalidate(0, icon = $$new_props.icon);
		if ('toggle' in $$new_props) $$invalidate(1, toggle = $$new_props.toggle);
		if ('closeAriaLabel' in $$new_props) $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 64) {
			$$invalidate(4, classes = classnames(className, 'toast-header'));
		}

		if ($$self.$$.dirty & /*icon*/ 1) {
			$$invalidate(3, tagClassName = classnames('me-auto', { 'ms-2': icon !== null }));
		}
	};

	return [
		icon,
		toggle,
		closeAriaLabel,
		tagClassName,
		classes,
		$$restProps,
		className,
		$$scope,
		slots
	];
}

class NodeModulesSveltestrapSveltestrapDistToastHeaderToastHeaderSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$2, create_fragment$2, SvelteInternal.safe_not_equal, {
			class: 6,
			icon: 0,
			toggle: 1,
			closeAriaLabel: 2
		});
	}

	get class() {
		return this.$$.ctx[6];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get icon() {
		return this.$$.ctx[0];
	}

	set icon(icon) {
		this.$$set({ icon });
		SvelteInternal.flush();
	}

	get toggle() {
		return this.$$.ctx[1];
	}

	set toggle(toggle) {
		this.$$set({ toggle });
		SvelteInternal.flush();
	}

	get closeAriaLabel() {
		return this.$$.ctx[2];
	}

	set closeAriaLabel(closeAriaLabel) {
		this.$$set({ closeAriaLabel });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistToastToastSvelte.svelte generated by Svelte v4.2.8 */


function create_if_block$1(ctx) {
	let div;
	let t;
	let current_block_type_index;
	let if_block1;
	let div_transition;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*header*/ ctx[4] && create_if_block_2(ctx);
	const if_block_creators = [create_if_block_1$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*body*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let div_levels = [
		/*$$restProps*/ ctx[9],
		{ class: /*classes*/ ctx[7] },
		{ "data-bs-theme": /*theme*/ ctx[5] },
		{ role: "alert" }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = SvelteInternal.assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = SvelteInternal.element("div");
			if (if_block0) if_block0.c();
			t = SvelteInternal.space();
			if_block1.c();
			SvelteInternal.set_attributes(div, div_data);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			SvelteInternal.append(div, t);
			if_blocks[current_block_type_index].m(div, null);
			current = true;

			if (!mounted) {
				dispose = [
					SvelteInternal.listen(div, "introstart", /*introstart_handler*/ ctx[14]),
					SvelteInternal.listen(div, "introend", /*introend_handler*/ ctx[15]),
					SvelteInternal.listen(div, "outrostart", /*outrostart_handler*/ ctx[16]),
					SvelteInternal.listen(div, "outroend", /*outroend_handler*/ ctx[17])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*header*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*header*/ 16) {
						SvelteInternal.transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					SvelteInternal.transition_in(if_block0, 1);
					if_block0.m(div, t);
				}
			} else if (if_block0) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				SvelteInternal.check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block1, 1);
				if_block1.m(div, null);
			}

			SvelteInternal.set_attributes(div, div_data = SvelteInternal.get_spread_update(div_levels, [
				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
				(!current || dirty & /*theme*/ 32) && { "data-bs-theme": /*theme*/ ctx[5] },
				{ role: "alert" }
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block0);
			SvelteInternal.transition_in(if_block1);

			if (local) {
				SvelteInternal.add_render_callback(() => {
					if (!current) return;

					if (!div_transition) div_transition = SvelteInternal.create_bidirectional_transition(
						div,
						SvelteTransition.fade,
						{
							duration: /*fade*/ ctx[3] && /*duration*/ ctx[2]
						},
						true
					);

					div_transition.run(1);
				});
			}

			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block0);
			SvelteInternal.transition_out(if_block1);

			if (local) {
				if (!div_transition) div_transition = SvelteInternal.create_bidirectional_transition(
					div,
					SvelteTransition.fade,
					{
						duration: /*fade*/ ctx[3] && /*duration*/ ctx[2]
					},
					false
				);

				div_transition.run(0);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div);
			}

			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			if (detaching && div_transition) div_transition.end();
			mounted = false;
			SvelteInternal.run_all(dispose);
		}
	};
}

// (113:4) {#if header}
function create_if_block_2(ctx) {
	let toastheader;
	let current;

	toastheader = new NodeModulesSveltestrapSveltestrapDistToastHeaderToastHeaderSvelte({
			props: {
				toggle: /*toggle*/ ctx[6],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			SvelteInternal.create_component(toastheader.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(toastheader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toastheader_changes = {};
			if (dirty & /*toggle*/ 64) toastheader_changes.toggle = /*toggle*/ ctx[6];

			if (dirty & /*$$scope, header*/ 262160) {
				toastheader_changes.$$scope = { dirty, ctx };
			}

			toastheader.$set(toastheader_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(toastheader.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(toastheader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(toastheader, detaching);
		}
	};
}

// (114:6) <ToastHeader {toggle}>
function create_default_slot_1(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*header*/ ctx[4]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*header*/ 16) SvelteInternal.set_data(t, /*header*/ ctx[4]);
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (122:4) {:else}
function create_else_block$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (118:4) {#if body}
function create_if_block_1$1(ctx) {
	let toastbody;
	let current;

	toastbody = new NodeModulesSveltestrapSveltestrapDistToastBodyToastBodySvelte({
			props: {
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			SvelteInternal.create_component(toastbody.$$.fragment);
		},
		m(target, anchor) {
			SvelteInternal.mount_component(toastbody, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toastbody_changes = {};

			if (dirty & /*$$scope*/ 262144) {
				toastbody_changes.$$scope = { dirty, ctx };
			}

			toastbody.$set(toastbody_changes);
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(toastbody.$$.fragment, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(toastbody.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			SvelteInternal.destroy_component(toastbody, detaching);
		}
	};
}

// (119:6) <ToastBody>
function create_default_slot$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*isOpen*/ ctx[0] && create_if_block$1(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						SvelteInternal.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					SvelteInternal.transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				SvelteInternal.check_outros();
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"class","autohide","body","delay","duration","fade","header","isOpen","theme","toggle"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = SvelteInternal.createEventDispatcher();
	let { class: className = '' } = $$props;
	let { autohide = false } = $$props;
	let { body = false } = $$props;
	let { delay = 5000 } = $$props;
	let { duration = 200 } = $$props;
	let { fade = true } = $$props;
	let { header = undefined } = $$props;
	let { isOpen = true } = $$props;
	let { theme = null } = $$props;
	let { toggle = null } = $$props;

	/**
 * The timer ID for the autohide timeout.
 * @type {number}
 */
	let timeout;

	SvelteInternal.onDestroy(() => {
		return () => clearTimeout(timeout);
	});

	const introstart_handler = () => dispatch('opening');
	const introend_handler = () => dispatch('open');
	const outrostart_handler = () => dispatch('closing');
	const outroend_handler = () => dispatch('close');

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(9, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(10, className = $$new_props.class);
		if ('autohide' in $$new_props) $$invalidate(11, autohide = $$new_props.autohide);
		if ('body' in $$new_props) $$invalidate(1, body = $$new_props.body);
		if ('delay' in $$new_props) $$invalidate(12, delay = $$new_props.delay);
		if ('duration' in $$new_props) $$invalidate(2, duration = $$new_props.duration);
		if ('fade' in $$new_props) $$invalidate(3, fade = $$new_props.fade);
		if ('header' in $$new_props) $$invalidate(4, header = $$new_props.header);
		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ('theme' in $$new_props) $$invalidate(5, theme = $$new_props.theme);
		if ('toggle' in $$new_props) $$invalidate(6, toggle = $$new_props.toggle);
		if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*isOpen, autohide, delay*/ 6145) {
			if (isOpen && autohide) {
				// @ts-ignore
				timeout = setTimeout(() => $$invalidate(0, isOpen = false), delay);
			}
		}

		if ($$self.$$.dirty & /*className, isOpen*/ 1025) {
			$$invalidate(7, classes = classnames(className, 'toast', { show: isOpen }));
		}
	};

	return [
		isOpen,
		body,
		duration,
		fade,
		header,
		theme,
		toggle,
		classes,
		dispatch,
		$$restProps,
		className,
		autohide,
		delay,
		slots,
		introstart_handler,
		introend_handler,
		outrostart_handler,
		outroend_handler,
		$$scope
	];
}

class NodeModulesSveltestrapSveltestrapDistToastToastSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance$1, create_fragment$1, SvelteInternal.safe_not_equal, {
			class: 10,
			autohide: 11,
			body: 1,
			delay: 12,
			duration: 2,
			fade: 3,
			header: 4,
			isOpen: 0,
			theme: 5,
			toggle: 6
		});
	}

	get class() {
		return this.$$.ctx[10];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get autohide() {
		return this.$$.ctx[11];
	}

	set autohide(autohide) {
		this.$$set({ autohide });
		SvelteInternal.flush();
	}

	get body() {
		return this.$$.ctx[1];
	}

	set body(body) {
		this.$$set({ body });
		SvelteInternal.flush();
	}

	get delay() {
		return this.$$.ctx[12];
	}

	set delay(delay) {
		this.$$set({ delay });
		SvelteInternal.flush();
	}

	get duration() {
		return this.$$.ctx[2];
	}

	set duration(duration) {
		this.$$set({ duration });
		SvelteInternal.flush();
	}

	get fade() {
		return this.$$.ctx[3];
	}

	set fade(fade) {
		this.$$set({ fade });
		SvelteInternal.flush();
	}

	get header() {
		return this.$$.ctx[4];
	}

	set header(header) {
		this.$$set({ header });
		SvelteInternal.flush();
	}

	get isOpen() {
		return this.$$.ctx[0];
	}

	set isOpen(isOpen) {
		this.$$set({ isOpen });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[5];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}

	get toggle() {
		return this.$$.ctx[6];
	}

	set toggle(toggle) {
		this.$$set({ toggle });
		SvelteInternal.flush();
	}
}

/* nodeModulesSveltestrapSveltestrapDistTooltipTooltipSvelte.svelte generated by Svelte v4.2.8 */


function create_if_block(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*outer*/ ctx[6];

	function switch_props(ctx, dirty) {
		return {
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		};
	}

	if (switch_value) {
		switch_instance = SvelteInternal.construct_svelte_component(switch_value, switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) SvelteInternal.create_component(switch_instance.$$.fragment);
			switch_instance_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (switch_instance) SvelteInternal.mount_component(switch_instance, target, anchor);
			SvelteInternal.insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*outer*/ 64 && switch_value !== (switch_value = /*outer*/ ctx[6])) {
				if (switch_instance) {
					SvelteInternal.group_outros();
					const old_component = switch_instance;

					SvelteInternal.transition_out(old_component.$$.fragment, 1, 0, () => {
						SvelteInternal.destroy_component(old_component, 1);
					});

					SvelteInternal.check_outros();
				}

				if (switch_value) {
					switch_instance = SvelteInternal.construct_svelte_component(switch_value, switch_props(ctx));
					SvelteInternal.create_component(switch_instance.$$.fragment);
					SvelteInternal.transition_in(switch_instance.$$.fragment, 1);
					SvelteInternal.mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				const switch_instance_changes = {};

				if (dirty & /*$$scope, $$restProps, classes, id, theme, popperPlacement, tooltipEl, children*/ 524734) {
					switch_instance_changes.$$scope = { dirty, ctx };
				}

				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) SvelteInternal.transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) SvelteInternal.transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(switch_instance_anchor);
			}

			if (switch_instance) SvelteInternal.destroy_component(switch_instance, detaching);
		}
	};
}

// (210:8) {:else}
function create_else_block(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = SvelteInternal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
					SvelteInternal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? SvelteInternal.get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: SvelteInternal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (208:8) {#if children}
function create_if_block_1(ctx) {
	let t;

	return {
		c() {
			t = SvelteInternal.text(/*children*/ ctx[1]);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 2) SvelteInternal.set_data(t, /*children*/ ctx[1]);
		},
		i: SvelteInternal.noop,
		o: SvelteInternal.noop,
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(t);
			}
		}
	};
}

// (196:2) <svelte:component this={outer}>
function create_default_slot(ctx) {
	let div2;
	let div0;
	let t;
	let div1;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*children*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let div2_levels = [
		/*$$restProps*/ ctx[8],
		{ class: /*classes*/ ctx[7] },
		{ id: /*id*/ ctx[2] },
		{ role: "tooltip" },
		{ "data-bs-theme": /*theme*/ ctx[3] },
		{
			"x-placement": /*popperPlacement*/ ctx[4]
		}
	];

	let div_data_2 = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div_data_2 = SvelteInternal.assign(div_data_2, div2_levels[i]);
	}

	return {
		c() {
			div2 = SvelteInternal.element("div");
			div0 = SvelteInternal.element("div");
			t = SvelteInternal.space();
			div1 = SvelteInternal.element("div");
			if_block.c();
			SvelteInternal.attr(div0, "class", "tooltip-arrow");
			SvelteInternal.attr(div0, "data-popper-arrow", "");
			SvelteInternal.attr(div1, "class", "tooltip-inner");
			SvelteInternal.set_attributes(div2, div_data_2);
		},
		m(target, anchor) {
			SvelteInternal.insert(target, div2, anchor);
			SvelteInternal.append(div2, div0);
			SvelteInternal.append(div2, t);
			SvelteInternal.append(div2, div1);
			if_blocks[current_block_type_index].m(div1, null);
			/*div2_binding*/ ctx[18](div2);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				SvelteInternal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				SvelteInternal.transition_in(if_block, 1);
				if_block.m(div1, null);
			}

			SvelteInternal.set_attributes(div2, div_data_2 = SvelteInternal.get_spread_update(div2_levels, [
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8],
				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
				(!current || dirty & /*id*/ 4) && { id: /*id*/ ctx[2] },
				{ role: "tooltip" },
				(!current || dirty & /*theme*/ 8) && { "data-bs-theme": /*theme*/ ctx[3] },
				(!current || dirty & /*popperPlacement*/ 16) && {
					"x-placement": /*popperPlacement*/ ctx[4]
				}
			]));
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(div2);
			}

			if_blocks[current_block_type_index].d();
			/*div2_binding*/ ctx[18](null);
		}
	};
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*isOpen*/ ctx[0] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = SvelteInternal.empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			SvelteInternal.insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						SvelteInternal.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					SvelteInternal.transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				SvelteInternal.group_outros();

				SvelteInternal.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				SvelteInternal.check_outros();
			}
		},
		i(local) {
			if (current) return;
			SvelteInternal.transition_in(if_block);
			current = true;
		},
		o(local) {
			SvelteInternal.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				SvelteInternal.detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let classes;
	let outer;

	const omit_props_names = [
		"class","animation","children","container","id","isOpen","placement","target","theme"
	];

	let $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = '' } = $$props;
	let { animation = true } = $$props;
	let { children = '' } = $$props;
	let { container = undefined } = $$props;
	let { id = `tooltip_${uuid()}` } = $$props;
	let { isOpen = false } = $$props;
	let { placement = 'top' } = $$props;
	let { target = '' } = $$props;
	let { theme = null } = $$props;

	/**
 * @type {string}
 */
	let bsPlacement;

	/**
 * @type {object}
 */
	let popperInstance;

	/**
 * @type {string}
 */
	let popperPlacement = placement;

	/**
 * @type {HTMLDivElement | null}
 */
	let targetEl;

	/**
 * @type {HTMLDivElement | null}
 */
	let tooltipEl;

	const checkPopperPlacement = {
		name: 'checkPopperPlacement',
		enabled: true,
		phase: 'main',
		// @ts-ignore
		fn({ state }) {
			$$invalidate(4, popperPlacement = state.placement);
		}
	};

	const open = () => $$invalidate(0, isOpen = true);
	const close = () => $$invalidate(0, isOpen = false);
	SvelteInternal.onMount(registerEventListeners);
	SvelteInternal.onDestroy(unregisterEventListeners);

	function registerEventListeners() {
		// eslint-disable-next-line eqeqeq
		if (target == null || !target) {
			$$invalidate(16, targetEl = null);
			return;
		}

		// Check if target is HTMLElement
		try {
			if (target instanceof HTMLElement) {
				// @ts-ignore
				$$invalidate(16, targetEl = target);
			}
		} catch(e) {
			
		} // fails on SSR

		// If targetEl has not been found yet
		// eslint-disable-next-line eqeqeq
		if (targetEl == null) {
			// Check if target can be found via querySelector
			try {
				$$invalidate(16, targetEl = document.querySelector(`#${target}`));
			} catch(e) {
				
			} // fails on SSR
		}

		// If we've found targetEl
		if (targetEl) {
			targetEl.addEventListener('mouseover', open);
			targetEl.addEventListener('mouseleave', close);
			targetEl.addEventListener('focus', open);
			targetEl.addEventListener('blur', close);
		}
	}

	function unregisterEventListeners() {
		if (targetEl) {
			targetEl.removeEventListener('mouseover', open);
			targetEl.removeEventListener('mouseleave', close);
			targetEl.removeEventListener('focus', open);
			targetEl.removeEventListener('blur', close);
			targetEl.removeAttribute('aria-describedby');
		}
	}

	function div2_binding($$value) {
		SvelteInternal.binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			tooltipEl = $$value;
			$$invalidate(5, tooltipEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = SvelteInternal.assign(SvelteInternal.assign({}, $$props), SvelteInternal.exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = SvelteInternal.compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ('animation' in $$new_props) $$invalidate(10, animation = $$new_props.animation);
		if ('children' in $$new_props) $$invalidate(1, children = $$new_props.children);
		if ('container' in $$new_props) $$invalidate(11, container = $$new_props.container);
		if ('id' in $$new_props) $$invalidate(2, id = $$new_props.id);
		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ('placement' in $$new_props) $$invalidate(12, placement = $$new_props.placement);
		if ('target' in $$new_props) $$invalidate(13, target = $$new_props.target);
		if ('theme' in $$new_props) $$invalidate(3, theme = $$new_props.theme);
		if ('$$scope' in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*isOpen, tooltipEl, targetEl, placement, popperInstance*/ 102433) {
			{
				if (isOpen && tooltipEl) {
					// @ts-ignore
					$$invalidate(15, popperInstance = createPopper(targetEl, tooltipEl, {
						placement,
						modifiers: [checkPopperPlacement]
					}));
				} else if (popperInstance) {
					// @ts-ignore
					popperInstance.destroy();

					// @ts-ignore
					$$invalidate(15, popperInstance = undefined);
				}
			}
		}

		if ($$self.$$.dirty & /*target*/ 8192) {
			if (target) {
				unregisterEventListeners();
				registerEventListeners();
			}
		}

		if ($$self.$$.dirty & /*targetEl, isOpen, id*/ 65541) {
			if (targetEl) {
				if (isOpen) {
					targetEl.setAttribute('aria-describedby', id);
				} else {
					targetEl.removeAttribute('aria-describedby');
				}
			}
		}

		if ($$self.$$.dirty & /*popperPlacement*/ 16) {
			{
				if (popperPlacement === 'left') {
					$$invalidate(14, bsPlacement = 'start');
				} else if (popperPlacement === 'right') {
					$$invalidate(14, bsPlacement = 'end');
				} else {
					$$invalidate(14, bsPlacement = popperPlacement);
				}
			}
		}

		if ($$self.$$.dirty & /*className, animation, bsPlacement, isOpen*/ 17921) {
			$$invalidate(7, classes = classnames(className, 'tooltip', animation ? 'fade' : false, `bs-tooltip-${bsPlacement}`, isOpen ? 'show' : false));
		}

		if ($$self.$$.dirty & /*container*/ 2048) {
			$$invalidate(6, outer = container === 'inline' ? NodeModulesSveltestrapSveltestrapDistInlineContainerInlineContainerSvelte : NodeModulesSveltestrapSveltestrapDistPortalPortalSvelte);
		}
	};

	return [
		isOpen,
		children,
		id,
		theme,
		popperPlacement,
		tooltipEl,
		outer,
		classes,
		$$restProps,
		className,
		animation,
		container,
		placement,
		target,
		bsPlacement,
		popperInstance,
		targetEl,
		slots,
		div2_binding,
		$$scope
	];
}

class NodeModulesSveltestrapSveltestrapDistTooltipTooltipSvelte extends SvelteInternal.SvelteComponent {
	constructor(options) {
		super();

		SvelteInternal.init(this, options, instance, create_fragment, SvelteInternal.safe_not_equal, {
			class: 9,
			animation: 10,
			children: 1,
			container: 11,
			id: 2,
			isOpen: 0,
			placement: 12,
			target: 13,
			theme: 3
		});
	}

	get class() {
		return this.$$.ctx[9];
	}

	set class(className) {
		this.$$set({ class: className });
		SvelteInternal.flush();
	}

	get animation() {
		return this.$$.ctx[10];
	}

	set animation(animation) {
		this.$$set({ animation });
		SvelteInternal.flush();
	}

	get children() {
		return this.$$.ctx[1];
	}

	set children(children) {
		this.$$set({ children });
		SvelteInternal.flush();
	}

	get container() {
		return this.$$.ctx[11];
	}

	set container(container) {
		this.$$set({ container });
		SvelteInternal.flush();
	}

	get id() {
		return this.$$.ctx[2];
	}

	set id(id) {
		this.$$set({ id });
		SvelteInternal.flush();
	}

	get isOpen() {
		return this.$$.ctx[0];
	}

	set isOpen(isOpen) {
		this.$$set({ isOpen });
		SvelteInternal.flush();
	}

	get placement() {
		return this.$$.ctx[12];
	}

	set placement(placement) {
		this.$$set({ placement });
		SvelteInternal.flush();
	}

	get target() {
		return this.$$.ctx[13];
	}

	set target(target) {
		this.$$set({ target });
		SvelteInternal.flush();
	}

	get theme() {
		return this.$$.ctx[3];
	}

	set theme(theme) {
		this.$$set({ theme });
		SvelteInternal.flush();
	}
}

export { NodeModulesSveltestrapSveltestrapDistAccordionAccordionSvelte as Accordion, NodeModulesSveltestrapSveltestrapDistAccordionHeaderAccordionHeaderSvelte as AccordionHeader, NodeModulesSveltestrapSveltestrapDistAccordionItemAccordionItemSvelte as AccordionItem, NodeModulesSveltestrapSveltestrapDistAlertAlertSvelte as Alert, NodeModulesSveltestrapSveltestrapDistBadgeBadgeSvelte as Badge, NodeModulesSveltestrapSveltestrapDistBreadcrumbBreadcrumbSvelte as Breadcrumb, NodeModulesSveltestrapSveltestrapDistBreadcrumbItemBreadcrumbItemSvelte as BreadcrumbItem, NodeModulesSveltestrapSveltestrapDistButtonButtonSvelte as Button, NodeModulesSveltestrapSveltestrapDistButtonDropdownButtonDropdownSvelte as ButtonDropdown, NodeModulesSveltestrapSveltestrapDistButtonGroupButtonGroupSvelte as ButtonGroup, NodeModulesSveltestrapSveltestrapDistButtonToolbarButtonToolbarSvelte as ButtonToolbar, NodeModulesSveltestrapSveltestrapDistCardCardSvelte as Card, NodeModulesSveltestrapSveltestrapDistCardBodyCardBodySvelte as CardBody, NodeModulesSveltestrapSveltestrapDistCardColumnsCardColumnsSvelte as CardColumns, NodeModulesSveltestrapSveltestrapDistCardDeckCardDeckSvelte as CardDeck, NodeModulesSveltestrapSveltestrapDistCardFooterCardFooterSvelte as CardFooter, NodeModulesSveltestrapSveltestrapDistCardGroupCardGroupSvelte as CardGroup, NodeModulesSveltestrapSveltestrapDistCardHeaderCardHeaderSvelte as CardHeader, NodeModulesSveltestrapSveltestrapDistCardImgCardImgSvelte as CardImg, NodeModulesSveltestrapSveltestrapDistCardImgOverlayCardImgOverlaySvelte as CardImgOverlay, NodeModulesSveltestrapSveltestrapDistCardLinkCardLinkSvelte as CardLink, NodeModulesSveltestrapSveltestrapDistCardSubtitleCardSubtitleSvelte as CardSubtitle, NodeModulesSveltestrapSveltestrapDistCardTextCardTextSvelte as CardText, NodeModulesSveltestrapSveltestrapDistCardTitleCardTitleSvelte as CardTitle, NodeModulesSveltestrapSveltestrapDistCarouselCarouselSvelte as Carousel, NodeModulesSveltestrapSveltestrapDistCarouselCaptionCarouselCaptionSvelte as CarouselCaption, NodeModulesSveltestrapSveltestrapDistCarouselControlCarouselControlSvelte as CarouselControl, NodeModulesSveltestrapSveltestrapDistCarouselIndicatorsCarouselIndicatorsSvelte as CarouselIndicators, NodeModulesSveltestrapSveltestrapDistCarouselItemCarouselItemSvelte as CarouselItem, NodeModulesSveltestrapSveltestrapDistColColSvelte as Col, NodeModulesSveltestrapSveltestrapDistCollapseCollapseSvelte as Collapse, NodeModulesSveltestrapSveltestrapDistColumnColumnSvelte as Column, NodeModulesSveltestrapSveltestrapDistContainerContainerSvelte as Container, NodeModulesSveltestrapSveltestrapDistDropdownDropdownSvelte as Dropdown, NodeModulesSveltestrapSveltestrapDistDropdownItemDropdownItemSvelte as DropdownItem, NodeModulesSveltestrapSveltestrapDistDropdownMenuDropdownMenuSvelte as DropdownMenu, NodeModulesSveltestrapSveltestrapDistDropdownToggleDropdownToggleSvelte as DropdownToggle, NodeModulesSveltestrapSveltestrapDistFadeFadeSvelte as Fade, NodeModulesSveltestrapSveltestrapDistFigureFigureSvelte as Figure, NodeModulesSveltestrapSveltestrapDistFormFormSvelte as Form, NodeModulesSveltestrapSveltestrapDistFormCheckFormCheckSvelte as FormCheck, NodeModulesSveltestrapSveltestrapDistFormFeedbackFormFeedbackSvelte as FormFeedback, NodeModulesSveltestrapSveltestrapDistFormGroupFormGroupSvelte as FormGroup, NodeModulesSveltestrapSveltestrapDistFormTextFormTextSvelte as FormText, NodeModulesSveltestrapSveltestrapDistIconIconSvelte as Icon, NodeModulesSveltestrapSveltestrapDistImageImageSvelte as Image, NodeModulesSveltestrapSveltestrapDistInlineContainerInlineContainerSvelte as InlineContainer, NodeModulesSveltestrapSveltestrapDistInputInputSvelte as Input, NodeModulesSveltestrapSveltestrapDistInputGroupInputGroupSvelte as InputGroup, NodeModulesSveltestrapSveltestrapDistInputGroupTextInputGroupTextSvelte as InputGroupText, NodeModulesSveltestrapSveltestrapDistJumbotronJumbotronSvelte as Jumbotron, NodeModulesSveltestrapSveltestrapDistLabelLabelSvelte as Label, NodeModulesSveltestrapSveltestrapDistListGroupListGroupSvelte as ListGroup, NodeModulesSveltestrapSveltestrapDistListGroupItemListGroupItemSvelte as ListGroupItem, NodeModulesSveltestrapSveltestrapDistModalModalSvelte as Modal, NodeModulesSveltestrapSveltestrapDistModalBackdropModalBackdropSvelte as ModalBackdrop, NodeModulesSveltestrapSveltestrapDistModalBodyModalBodySvelte as ModalBody, NodeModulesSveltestrapSveltestrapDistModalFooterModalFooterSvelte as ModalFooter, NodeModulesSveltestrapSveltestrapDistModalHeaderModalHeaderSvelte as ModalHeader, NodeModulesSveltestrapSveltestrapDistNavNavSvelte as Nav, NodeModulesSveltestrapSveltestrapDistNavItemNavItemSvelte as NavItem, NodeModulesSveltestrapSveltestrapDistNavLinkNavLinkSvelte as NavLink, NodeModulesSveltestrapSveltestrapDistNavbarNavbarSvelte as Navbar, NodeModulesSveltestrapSveltestrapDistNavbarBrandNavbarBrandSvelte as NavbarBrand, NodeModulesSveltestrapSveltestrapDistNavbarTogglerNavbarTogglerSvelte as NavbarToggler, NodeModulesSveltestrapSveltestrapDistOffcanvasOffcanvasSvelte as Offcanvas, NodeModulesSveltestrapSveltestrapDistOffcanvasBackdropOffcanvasBackdropSvelte as OffcanvasBackdrop, NodeModulesSveltestrapSveltestrapDistOffcanvasBodyOffcanvasBodySvelte as OffcanvasBody, NodeModulesSveltestrapSveltestrapDistOffcanvasHeaderOffcanvasHeaderSvelte as OffcanvasHeader, NodeModulesSveltestrapSveltestrapDistPaginationPaginationSvelte as Pagination, NodeModulesSveltestrapSveltestrapDistPaginationItemPaginationItemSvelte as PaginationItem, NodeModulesSveltestrapSveltestrapDistPaginationLinkPaginationLinkSvelte as PaginationLink, NodeModulesSveltestrapSveltestrapDistPopoverPopoverSvelte as Popover, NodeModulesSveltestrapSveltestrapDistPortalPortalSvelte as Portal, NodeModulesSveltestrapSveltestrapDistProgressProgressSvelte as Progress, NodeModulesSveltestrapSveltestrapDistRowRowSvelte as Row, NodeModulesSveltestrapSveltestrapDistSpinnerSpinnerSvelte as Spinner, NodeModulesSveltestrapSveltestrapDistStylesStylesSvelte as Styles, NodeModulesSveltestrapSveltestrapDistTabContentTabContentSvelte as TabContent, NodeModulesSveltestrapSveltestrapDistTabPaneTabPaneSvelte as TabPane, NodeModulesSveltestrapSveltestrapDistTableTableSvelte as Table, NodeModulesSveltestrapSveltestrapDistThemeThemeSvelte as Theme, NodeModulesSveltestrapSveltestrapDistThemeThemeTogglerSvelte as ThemeToggler, NodeModulesSveltestrapSveltestrapDistToastToastSvelte as Toast, NodeModulesSveltestrapSveltestrapDistToastBodyToastBodySvelte as ToastBody, NodeModulesSveltestrapSveltestrapDistToastHeaderToastHeaderSvelte as ToastHeader, NodeModulesSveltestrapSveltestrapDistTooltipTooltipSvelte as Tooltip, colorMode, toggleColorMode, useColorMode };
