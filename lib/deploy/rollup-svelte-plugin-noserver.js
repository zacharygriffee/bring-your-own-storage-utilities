import {svelteCompile, setSvelteCompiler} from "./svelte-compile.js";
import camelCase from "lodash-es/camelCase.js";
import {endsWith} from "../util/endsWith.js";
import {rollupExternalGlobalsPlugin} from "./rollup-external-globals-plugin.js";

export {setSvelteCompiler};

/**
 * Compile svelte file. It must end with `**.svelte**` extension to be registered in this plugin.
 * So even if you use the virtual plugin, make sure your file ends with `.svelte`.
 *
 * Yes, I hate global pollution too, but this only way I can efficiently get svelte to operate properly in browser without
 * a server.
 *
 * This changes all imports referencing svelte to global. This keeps a svelte instance in global scope so that
 * each component knows about each other. There are plans to define different scopes, but for now, there is only one
 * svelte instance scope produced with this. Any security concerns you may have in this should be considered.
 *
 * These will need to be in global scope for any scripts generated by this plugin to work only:
 * The critical ones are Svelte and SvelteInternal and in 90% of the time SvelteStore.
 * The others are only necessary if you have it in your code.
 *
 * <pre>
 * [Specifier]                      = [Global Name]
 * svelte                           = SvelteInternal
 * svelte/compiler                  = SvelteCompiler
 * svelte/store                     = SvelteStore
 * svelte/internal                  = SvelteInternal
 * svelte/animate                   = SvelteAnimate
 * svelte/easing                    = SvelteEasing
 * svelte/motion                    = SvelteNotion
 * svelte/transition                = SvelteTransition
 * @sveltestrap/sveltestrap         = SvelteStrap
 * **This one is not optional**
 * svelte/internal/disclose-version = SvelteVersion
 * </pre>
 *
 * There are two ways I suggest the developer to globalize svelte. In bring-your-own-storage-utilities/dist/svelte are
 * modified minification of svelte files that globalizes itself to match the global name in the above list.
 *
 * Or you can import your own svelte files (e.g. import map or script ele tag) and ensure that you add them to global scope
 * under the names of the above list.
 *
 * @param config This is the same configuration as {@link svelteCompile$ svelteCompile$} including the following
 * @param [config.svelteCompiler] See Deploy.setSvelteCompiler. This is a convenience function to set the compiler from
 * here. However, if you've already set the compiler or have already run svelteCompiler function, this will do nothing.
 * @returns {{transform(*, *): (*|undefined), options(*): *}|*}
 * @memberof Deploy
 */
export function rollupSveltePluginNoServer(config = {}) {
    const {
        svelteCompiler,
        ...restConfig
    } = config;
    const ready = svelteCompiler ? setSvelteCompiler(svelteCompiler) : Promise.resolve();

    return {
        options(config) {
            config.plugins ||= [];
            config.plugins.push(
                rollupExternalGlobalsPlugin({
                    "svelte": "SvelteInternal",
                    "svelte/compiler": "SvelteCompiler",
                    "svelte/store": "SvelteStore",
                    "svelte/internal": "SvelteInternal",
                    "svelte/animate": "SvelteAnimate",
                    "svelte/easing": "SvelteEasing",
                    "svelte/motion": "SvelteNotion",
                    "svelte/transition": "SvelteTransition",
                    "svelte/internal/disclose-version": "SvelteVersion",
                    "@sveltestrap/sveltestrap": "SvelteStrap"
                })
            );

            return config;
        },
        async transform(code, id) {
            await ready;
            if (endsWith(id, ".svelte")) {
                return svelteCompile(code, {
                    ...restConfig,
                    name: camelCase(id),
                });
            }
        }
    }
}